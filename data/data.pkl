(dp0
S'228684'
p1
(lp2
Vdeclare structure header used multiple files c sourcec file struct: struct int struct b int j struct used another file ie funcc create new header file declare struct include header funcc define whole struct header file include sourcec funcc struct declared extern files typedef 
p3
aVah: ifndef a_h define a_h struct int struct b int j endif go need include ah files want use structure 
p4
aVstructure definition used across one source file definitely put header file include header file source file needs structure extern declaration used structure definitions instead used variable declarations data value structure type defined want use variable across one source file declare extern header file like: extern struct myavalue _one_ source file define actual variable: struct myavalue forget accidentally define two source files linker let know 
p5
aV structure used file funcc type used file ie funcc file must visible worst way copy paste source file needed right way putting header file include header file whenever needed shall open new header file declare structure include header funcc solution like makes code highly modular would code struct as: ifndef some_header_guard_with_unique_name define some_header_guard_with_unique_name struct int struct b int j endif would put functions using structure header function semantically part interface usually could name file structure name use name choose header guards defines need declare function using pointer struct wont need full struct definition simple forward declaration like: struct enough decreases coupling define total structure header file include sourcec funcc another way easier somewhat less modular: code needing structure work would still include types c could lead interesting complication topic c tag wont elaborate declare structure extern files fail see point perhaps greg hewgill good answer post declare structure header used multiple files c declareastructureinaheaderthatistobeusedbymultiplefiles inc228691 shall typedef using c dont using c reason c struct managing pain: declare struct keyword everywhere used: struct mystruct forward declaration struct mystruct etc void dosomethingstruct mystruct p parameter struct mystruct variable etc typedef enable write without struct keyword struct mystructtag forward declaration typedef struct mystructtag etc mystruct void dosomethingmystruct p parameter mystruct variable etc important still keep name struct writing: typedef struct etc mystruct create anonymous struct typedefed name wont able forwarddeclare keep following format: typedef struct mystructtag etc mystruct thus youll able use mystruct everywhere want avoid adding struct keyword still use mystructtag typedef wont work ie forward declaration edit: corrected wrong assumption c99 struct declaration rightfully remarked jonathan leffler 
p6
asS'31607507'
p7
(lp8
Vc language standards specify support global register variables read gcc provides support define global variables register stored variables want know standards specifications support 
p9
aVstandards specify feature like storage class register behaves like auto cannot used global variables rule thumb everything intrinsic certain machine part standard c 
p10
aVfirst foremost allocation _register stored variables_ job compiler c standard specify anything _mandatory_ said _global_ variable cannot defined register storage class per c11 chapter §69 storageclass specifiers auto register shall appear declaration specifiers external declaration use register guarantee allocation register chapter §671 _emphasis mine_ declaration identifier object storageclass specifier register suggests access object fast possible extent suggestions effective implementation defined 
p11
aVregister may used global variables covered c11 692: constraints storageclass specifiers auto register shall appear declaration specifiers external declaration _external declaration_ means declaration within function confused extern external linkage 
p12
aVglobal register variables varshtml supported permitted c99 c11 standards see sourav ghoshs mcnabbs _extension_ gcc register int foo asm a5 declare _global_ int variable sitting register a5 rarely useful need understand gcc generates code allocates registesr calling conventions abi able use without fears btw probably weaken gcc optimization abilities gcc specific clangllvm clang support extension even supporting several gcc extensions eg computed gotos 
p13
aVcommon misconsception cs keyword register talks hardware registers might origin concept modern c purpose real effect register allowed beast may realized way compiler wants hardware registers instruction immediates stack wouldnt know know register variable cant alias variables answer question directly register file scope part c language would would allow us declare register const variables almost base could serve sort global constants mapping hardware register specific variables extension compilers provide eg gcc gccs feature extension also works file scope quite prohibitive since usually cpus dont many hardware registers spare 
p14
asS'3549879'
p15
(lp16
Vmain predefined function c  possible duplicate: main c c java c maininccjavac im new programming general c particular every example ive looked main function predefined way name takes special meaning compiler runtime merely common idiom among c programmers like using foo bar arbitrary variable names 
p17
aVcouldnt define one predefined meaning entry point present defined 
p18
aVneed define main program since called run time however interface main must provide predefined must return int must take either zero arguments two first int second char equivalently char c c standards specify function external linkage named main acts entry point program1 least term normally used predefined function would one sin printf thats standard library use without write 1if want get technical thats true hosted implementation ie kind us use time produces programs run operating system freestanding implementation one produces program run directly bare metal operating system free define entry points sees fit freestanding implementation also leave normal runtime library providing handful headers eg stddefh virtually standard library functions 
p19
aVyes main predefined function general sense word defined words c language standard specifies function called program startup shall named main merely convention used programmers foo bar _the fine print: perspective technical meaning word defined context c programming main function predefined compiler c library supply predefined function named main need define implementation main function obviously name main_ 
p20
aVtypically piece code normal c programs linked does: extern int mainint argc char argv char envp file stdin file stdout file stderr setup argv setup envp setup stdio stdin fdopen0 r stdout fdopen1 w stderr fdopen2 w int rc rc mainargc argv envp envp may present systems exitrc note code c c expects main c function also note code error checking leaves lot system dependent stuff probably happens also ignores things happen c objective c various languages may linked notably constructor destructor calling possibly main within c trycatch block anyway code knows main function takes arguments main looks like: int mainvoid still gets passed arguments ignored code specially linked called program starts completely free write version code many architectures relies intimate knowledge operating system starts new program well c c possibly objective c run time likely require assembly programming use compiler extensions properly build c compiler driver command usually call call compiler passes object file containing often called crt00 c run time along rest program linker unless told building operating system kernel embedded program often want use standard crto file also may want use building normal application another programming language nonstandard requirements 
p21
asS'98391'
p22
(lp23
Vdifference echo date echo date echo date difference three commands echo date echo date echo date confused differences actually think around means string therefore echo would literally output string date instead displaying date 
p24
aVdate return output date command however removes extra space characters places one consecutive space characters output date double quotes weak quotes expand variables try pwd perform command substitution date single quotes stronger quotes allow expansion variables command substitution within refer link explanation edited first point correctly pointed michael suelmann comment differencebetweenechodateechodateandechodatecomment149792_98394 
p25
aVecho date echo date display date output latter looks like output running date theres difference though: one surrounded quotes sent echo single argument quotes encapsulate output entire command one argument since echo prints arguments order spaces basically look heres example subtle difference: echo date produces: fri nov 1 01:48:45 est 2013 but: echo date produces: fri nov 1 01:48:49 est 2013 note two spaces nov reduced one without quotes shell parsing spaceseparated element sending result echo 6 arguments quote echo receives one single argument quotes retain space becomes much important commands echo example imagine command foo wants two arguments: date email address work scenario: foo date joeuser@examplecom confuse script sending 7 arguments: foo date joeuser@examplecom 
p26
aVdate get output date split multiple words word splitting done command substitution date get output date one wordparameter command substitution double quotes output parsed valid variable expansion like example date get literal date command substitution single quotes perhaps differences 3 forms visible way: date echo done fr 1 nov 12:25:30 cet 2013 date echo done fr 1 nov 12:25:38 cet 2013 date echo done date 
p27
aVposix shells date ancient form command substitution modern syntax date cases expand output date trailing newline characters stripped provided output doesnt contain nul characters however within double quotes list contexts instance arguments simple commands like echo case expansion subject to: 1 word splitting: _output date trailing newline characters stripped_ split according current value ifs variable default containing space tab newline nul zsh several _words_ instance date outputs fri 1 nov 14:11:15 gmt 2013\u005cn like often english locale mainland british timezone ifs currently contains : split 3 _words_: fri 1 nov 14 11 15 gmt 2013 2 filename generation aka _globbing_ except zsh: word resulting splitting looked wildcard characters though shells expanded list filenames match patterns instance output date 33 uvc 3432 like often venusian locales uvc timezone ifs default value expands nonhidden 3 character filenames current directory whose middle character 33 nonhidden files nonhidden subdirectories nonhidden subdirectories current directory uvc 3432 why: 1 always quote double quotes command substitutions unless want either _word splitting_ _filename generation_ performed upon expansion 2 want _word splitting_ set ifs characters want split 3 want _word splitting_ _filename generation_ need issue set f disable single quotes quote everything cause backtick characters taken literally example using x makes easier see whats going on: bash norc x bash42 ifs: ifs: bash42 echo date date echo fri 1 nov 14 42 33 gmt 2013 fri 1 nov 14 42 33 gmt 2013 bash42 echo date date echo fri 1 nov 14:42:41 gmt 2013 fri 1 nov 14:42:41 gmt 2013 bash42 cd libmodules cd libmodules bash42 export tzuvc lc_allvs_vs export tzuvc lc_allvs_vs tzuvc lc_allvs_vs bash42 unset ifs get default behaviour unset ifs bash42 echo date date echo 33 3102amd64buildarch 3102amd64buildinclude 3102amd64buildmakefile 3102amd64buildmodulesymvers 3102amd64buildscripts 3102amd64kernelarch 3102amd64kernelcrypto 3102amd64kerneldrivers 3102amd64kernelfs 3102amd64kernellib 3102amd64kernelmm 3102amd64kernelnet 3102amd64kernelsound 3102amd64sourcearch 3102amd64sourceinclude 3102amd64sourcemakefile 3102amd64sourcescripts 3102amd64updatesdkms 3103amd64buildarch 3103amd64buildinclude 3103amd64buildmakefile 3103amd64buildmodulesymvers 3103amd64buildscripts 3103amd64kernelarch 3103amd64kernelcrypto 3103amd64kerneldrivers 3103amd64kernelfs 3103amd64kernellib 3103amd64kernelmm 3103amd64kernelnet 3103amd64kernelsound 3103amd64sourcearch 3103amd64sourceinclude 3103amd64sourcemakefile 3103amd64sourcescripts 3103amd64updatesdkms uvc 3432 33 3102amd64buildarch 3102amd64buildinclude 3102amd64buildmakefile 3102amd64buildmodulesymvers 3102amd64buildscripts 3102amd64kernelarch 3102amd64kernelcrypto 3102amd64kerneldrivers 3102amd64kernelfs 3102amd64kernellib 3102amd64kernelmm 3102amd64kernelnet 3102amd64kernelsound 3102amd64sourcearch 3102amd64sourceinclude 3102amd64sourcemakefile 3102amd64sourcescripts 3102amd64updatesdkms 3103amd64buildarch 3103amd64buildinclude 3103amd64buildmakefile 3103amd64buildmodulesymvers 3103amd64buildscripts 3103amd64kernelarch 3103amd64kernelcrypto 3103amd64kerneldrivers 3103amd64kernelfs 3103amd64kernellib 3103amd64kernelmm 3103amd64kernelnet 3103amd64kernelsound 3103amd64sourcearch 3103amd64sourceinclude 3103amd64sourcemakefile 3103amd64sourcescripts 3103amd64updatesdkms uvc 3432 bash42 echo date date echo 33 uvc 3432 33 uvc 3432 output contains nul characters behaviour varies shell shell: remove truncate output first nul character zsh preserves note anyway external commands cannot take arguments containing nuls 
p28
asS'9434207'
p29
(lp30
Vreading file using fgets reading file format 1 32 43 23 32 43 123 43 54 243 123 2222 2 code snippet string100 whilefeoffp fgetsstring100fp put every string last string getting repetition ambiguities like something else also gets printed say 123 solve problem 
p31
aVeof reached _after_ attempted read file end use return value fgets instead returns null eof error pointer given otherwise: char string100 whilefgetsstring 100 fp stuff string checking return value like cause never hit eof inside body loop like one instead condition 
p32
aVneed check return value fgets successful fgets returns pointer buffer passed ie string example endoffile encountered characters read fgets returns null try this: char string100 whilefgetsstring 100 fp printfs\u005cn string 
p33
asS'13443189'
p34
(lp35
Vglobal const pointer const data guaranteed placed separate readonly section gcc compiler cc given following definition global static local variable: static const type const ptr var1 var2 may rely upon fact _ptr_ _data_ initializer list placed separate readonly section generated object file ie placed data similar sections containing nonconst variables question relates gcc cc compiler behavior common architecturesplatforms least readonly memory exists doesnt imply platform processor os linker startup runtime libraries etc please dont ask im going know im information provided enough answer issue considered xxxspecific generic answer already read questionsanswers subject mentioned close: impact type qualifiers storage locations qualifiersonstoragelocations readonly memory implemented c implementedinc const mean readonly something cc onlyorsomethingmoreincc compiler allow write const variable towriteaconstvariablehere gcc c arm const pointer struct field tostructfield memcpy destination pointer const data pointertoconstdata didnt found assured direct answer 
p36
aVaccording stackoverflow thread constant variables stored c storedinc implementations specific personally would even rely thought gcc ports implemented way thats example avr port introduced progmem attribute according dont ask im enough information answer attitude id say here: answer portable way guarantee something like fact even instruct compiler linker place something like readonly section section lies ram prevent write access section 
p37
asS'32577808'
p38
(lp39
Vcreate new instance struct c c define struct correct way create new instance ive seen two ways: struct listitem int val char def struct listitem next first way xcode says redefining struct wrong: struct listitem newitem mallocsizeofstruct listitem second way: listitem newitem mallocsizeoflistitem alternatively another way 
p40
aVsecond way works used typedef struct listitem listitem declaration variable type listitem also statically allocate structure rather dynamically allocating it: struct listitem newitem way youve demonstrated like following every int want create: int myint mallocsizeofint 
p41
aV struct listitem newitem automatic allocation newitemval 5 heres quick rundown structs: 
p42
aVdepends want pointer better call structure like : typedef struct s_data int char b etc t_data instanciate nopointer structure : t_data my_struct my_structa 8 want pointer need malloc like : t_data my_struct my_struct mallocsizeoft_data my_structa 8 hope answer question 
p43
asS'22734051'
p44
(lp45
Vc string function calls pass value reference trouble figuring going thought c pass value simple function confuses works include stdioh include stringh include stdlibh void testfuncchar string1 char string250 end strcatstring1 string2 printfin func \u005cn string1 void main char string150 start printfin main \u005cn string1 testfuncstring1 printfin main \u005cn string1 confusingly output is: main thestart func thestarttheend main thestarttheend going c really passing address char array instead copying value thought char would behave char 
p46
aVc always passes arguments value string like arrays converted pointer first element pointer passed value 
p47
aVpassing value string1 address starting position char array value passed void testfuncchar string1 void testfuncchar string1 
p48
aVcant pass copy array function use name array evaluates pointer 1 element array commonly said decays pointer happens everywhere except using array name sizeof operator passing pointer 1 element array testfunc testfuncstring1 exactly testfuncstring10 also function argument list char actually means char 3 declarations exactly void testfuncchar string1 void testfuncchar string1 void testfuncchar string111 dont want alter passed string use something like: eg void testfuncchar string1 char string250 const char end end strcpystring2 string1 strcatstring2 end awake using strcpystrcat easy overflow arrays like 
p49
aVcase function parameter equivalent write: void testfuncchar string1 body void testfuncchar string1 body fact c first one always converted second type function definationso case function parameter n element array type converted array type tremember enjoy c programming note happens case function parameters 
p50
asS'21165114'
p51
(lp52
Vcall value call reference following code pass function pointer example10 entire array include stdioh void function int int main int example10 functionexample return 0 void function int example10 return question following code: include stdioh struct example int ex void function struct example int main struct example e functione return 0 void function struct example e return 
p53
aVc call value formally values passed functions value however arrays handled bit differently c compared data first example array example converted pointer first element pointer passed value function second example e pointer struct never set point anywhere pass pointer value function cases parameter passing done value pass pointer variable called function make changes original variable 
p54
aVc parameters passed value including pointers case passing arrays array decays pointer initial element first function passes pointer block ten unitialized pointers int may useful functionint change pointers inside array valid pointers example allowed: void function int example10 int 0 10 allocate triangular array examplei malloci1sizeofint course caller responsible allocated memory second function passes uninitialized pointer entirely useless functionstruct example e neither assign dereference pointer legally would illegal: void function struct example e eex 123 undefined behavior e uninitialized would effect value e caller: void function struct example e e mallocsizeofstruct example legal useless caller 
p55
asS'5545068'
p56
(lp57
Vcommon ways read file ruby common ways read file ruby instance one method: fileobj filenewfilename r line fileobjgets putsline end fileobjclose know ruby extremely flexible benefitsdrawbacks approach 
p58
aV fileopenmyfilepath r f feach_line line puts line end end file closed automatically end block also possible explicitly close file pass block open closes you: f fileopenmyfilepath r feach_line line puts line end fclose 
p59
aVeasiest way file isnt long is: puts filereadfile_name indeed ioread fileread automatically close file need use fileopen block 
p60
aVone simple method use readlines docorgdocsprogrammingrubyhtmlref_c_iohtmlioreadlines: my_array ioreadlinesfilenametxt line input file entry array method handles opening closing file 
p61
aVusually this: openpath_in_string :read give whole text string object works ruby 19 
p62
aVwary slurping files thats read entire file memory problem doesnt scale well could developing code reasonably sized file put production suddenly find youre trying read files measuring gigabytes host freezing tries read allocate memory linebyline io fast almost always effective slurping surprisingly fast actually like use: ioforeachtestfile x print got x fileforeachtestfile x print got x file inherits io foreach io use either benchmarks showing impact trying read big files via read vs linebyline io slurping file bad 
p63
aVread file once: content filereadlines filetxt contenteach_with_indexline puts i1: line file large may large usually better process linebyline: fileforeach filetxt line puts line end sometimes want access file handle though control reads yourself: fileopen filetxt f loop break line fgets puts flineno: line end end case binary files may specify nilseparator block size like so: fileopenfilebin rb f loop break buf fgetsnil 80 puts bufunpackh end end finally without block example processing multiple files simultaneously case file must explicitly closed improved per comment @antinome: begin f fileopen filetxt line fgets puts line end ensure fclose end references: file api api 
p64
aVreturn last _n_ lines your_filelog txt path filejoinrailsroot your_folderyour_filelog last_100_lines tail n 100 path 
p65
aV file_content filereadfilename extension puts file_content 
p66
asS'28779640'
p67
(lp68
Vunderstanding getchar putchar c getchar function reads character screen returns ascii value function reads single character time putchar function puts passed character screen returns ascii value character function puts single character time consider code 1 includestdioh void main int cgetchar putcharc output: abcd consider code 2: includestdioh void main int cgetchar whileceof putcharc cgetchar output: abcd abcd z code 1 working fine type 1 character getchar function reads first character return ascii value case code 2 loop whole string getting printed instead 1 character 
p69
aV code snippet 1 reads unsigned character prints ends program code snippet 2 reads unsigned characters read eof typically 1 characters printed another unsigned character read program starts printing else eof read instead program ends 
p70
aVknown line discipline icanon make long story short: input terminals handled line nothing passed program hit return makes possible edit line erase last char overtype case error handled kernel getchar usually implemented macro see similarly output buffered inside libc actually sent kernel newline \u005cn char seen unless explicitly flush note differs handled libc input handled kernel want process input characters one time right typed must set line discipline specific terminal used cbreak many terminal handling libraries eg: ncurses look man page stty 1 discussion back snippet: happens chars buffered kernel correctly echoed first line hit cr point whole line passed program happily loops eating chars spitting back cr reached libc actually converts linefeed \u005cn whole line built one char time spit back kernel hence terminal hitting ctrlz interpreted _by kernel_ eof returned via libc getchar would fail return 1 want able read chars including ctrlz win thar would ctrld unixlinux need set line discipline raw advanced feature likely lock terminal 
p71
aVcode 2 type string say abcdand press enter key data entered gets standard input streamstdin1 getchar reads character stdin execution program reaches loop loopputchar outputs character stored c first character entered next call getchar wait input saw characters stdin2 getchar reads next character b since eof loop continues process continues getchar reads eof characterwhich input using ctrlz finally program ends 1: data includes enter key press 2: also means getchar waits input character stdin empty 
p72
asS'22823926'
p73
(lp74
Vcall file pointer function need scan file letters form scrambled word everything looks okay debugger doesnt execute command advice would greatly appreciated code: void playgamechar array1size fileaptr aptr fopenwordstxt r int 0 size fscanfaptr c array1i printfc array1i heres call function main playgamescramblesize inptr array scramble declared fileinptr also size defined 10 
p75
aVcalling code have: file fp 0 char gamesize given youre opening file function closing need change file function call could be: playgamegame fp fp 0 fclosefp function changed to: void playgamechar array1size file aptr file fp fopenwordstxt r fp 0 aptr fp code alternatively file opened closed calling code file pointer simply passed playgame: file fp fopenwordstxt r fp 0 playgamegame fp fclosefp interface fopen fclose call playgame keeps current interface void playgamechar gamesize file fp makes sense often correct function opens file responsible closing exceptions many 
p76
asS'19231612'
p77
(lp78
Vwrite argv argc understand argv argc theyre used need recreate c would write function imitate 
p79
aVargc argv used starting program command line want pass variables program argc contains number arguments argv array pointers arguments strings arguments main mainint argc char argv syntax char argv declares argv pointer pointer character pointer character array character stringin words array character strings could also write char argv run program array argv contains order information command line entered command strings delineated whitespace including command integer argc gives total number strings therefore equal equal number arguments plus one example typed aout 2 g x 3 4 program would receive argc 7 argv0 aout argv1 argv2 2 argv3 g argv4 x argv5 3 argv6 4 
p80
aVc c function prototype main function looks like this: int mainint argc char argv 
p81
aVcannot recreate could change names main could type int mainint numberofarguments char arrayofarguments use numberofarguments argc arrayofarguments argv 
p82
aVcreate array store parameters pass argv set argc accordingly something like int argc 3 char argvargc 1 argv0 binary name argv1 first parameter argv2 second parameter argv3 null int result mainargc argv 
p83
asS'22877309'
p84
(lp85
Vf work c hey need know f works printffnumber extract floating point number series bits number consider code: main int i1 printf\u005cnd d\u005cnf fii output : d 1 f 0000000 ultimately doesnt depend variable depends usage d whatever need know f extracts float number corresponding series bits misunderstood question know f cant used integer would load garbage values size integer smaller float case size integer float 4 bytes let clear value 1 corresponding binary value this: 0000 0000 0000 0000 0000 0000 0000 0001 32 bits would f extract 00000 case series bitshow knows put decimal point etc cant find ieee 754 please correct wrong explanation assumpion 
p86
aVundefined behavior use f int answer question is: dont need know shouldnt output depends format specifier like f instead type argument variadic functions like printf scanf way knowing type variable argument part 
p87
aVwell easy see integer packed bytes represent decimals simplest technique fixed point: n bits first m point rest good representation however bits wasted numbers _uniform precision_ real life desired decimals 0 1 enter floating point ieee 754 interpreting bits since almost universally accepted high nearzero precision compact expandable allows large numbers well linked articles good read 
p88
aVothers said giving mismatched specifier arguments undefined behavior according c standard anything happen _does_ happen case modern computers this: printf looks place memory data interprets whatever data finds floatingpoint number prints number since printf function take variable number arguments floats converted doubles sent function printf expects find double normal modern computers 64 bits send int 32 bits printf look 32 bits int 32 bits garbage happened tried seems combination bit pattern corresponding double floatingpoint value 00 
p89
aVoutput floatingpoint number float x manually treating value black box extracting digits onebyone first check x 0 output minussign negate number know positive next output integer portion assign floatingpoint number integer variable truncate ie int integer x determine many digits using base10 logarithm log10 note log100 undefined youll handle zero special case iterate 0 number digits time dividing 10digit_index move desired digit units position take 10residue modulus idigits i0 dig integer pow10i 10 output decimal point fractional part subtract integer original absolute value remember floatingpoint number output digit similar way time multiplying 10frac_digits wont able predict number significant fractional digits way use fixed precision constant number fractional digits c code fill string representation floatingpoint number although make claims readability ieee formats store number normalized binary fraction similar scientific notation like 357×102 instead 3570 stored exponentmantissa pair normalized means theres actually implicit additional 1 bit front mantissa stored hopefully thats enough help understand detailed description format elsewhere remember _binary_ theres decimal point exponentmantissa notation isnt even _binary point_ format implicitly represented exponent tangentiallyrelated issue passing floats printf remember _variadic_ function declare types arguments receives arguments passed undergo automatic conversions float automatically promote double youre substituting hex brevity passing 2 64bit values: double f double f 0xabcdefgh 0xijklmnop 0xabcdefgh 0xijklmnop tell printf interpret sequence words int followed double 32bit int seen printf first half floatingpoint number floatingpoint number seem printf words reversed fourth word never used get integer representation youll need use _typepunning_ pointer printfd f\u005cn int f f reads righttoleft: take address float treat pointertoint follow pointer 
p90
asS'42381345'
p91
(lp92
Vbinary search tree pointer reference parameter working binary search tree function add ampsign front node pointer thought already pointer already points location understand add node need make sure parent node point new node parents node still point null dont pass node pointer nodeamp bool bst::remove123int data node x x null return false else xgetdata data return remove123data xright else xgetdata data return remove123data xleft else node old x xleft null x xright else xright null x xleft else replacementold xleft delete old return true thank 
p93
aVnode x reference node means bst::remove123 modifies x point different address code called bst::remove123 sees change node variable passed method declared x parameter node x instead bst::remove123 would modifying _copy_ variable passed parameter changes would lost method returned used designate reference different operator often used pointers returns address variable following int n 10 int pn n create pointer int set address n int rn n create int reference set reference variable n pn 5 set n 5 via dereferenced pn dereferencing operator needed indicate want change memory pn points address pointer contains rn 20 set n 20 via reference rn unlike pointers references use dereferencing operator 
p94
asS'1941464'
p95
(lp96
Vget file pointer file descriptor im playing around mkstemp provides file descriptor want generate formatted output via fprintf easy way transform file descriptor provided mkstemp file structure suitable use fprintf 
p97
aVuse fdopen file fp fdopenfd w 
p98
aVfile f fdopend w man fdopen output: synopsis include stdioh file fdopenint fildes const char mode fdopen function associates stream existing file descriptor fildes mode stream must compatible mode file descriptor stream closed via fclose3 fildes closed also 
p99
aVstandard way reverse c standard nothing say file descriptors specific platform may may provide mechanism 
p100
asS'9132049'
p101
(lp102
Vdeclare object array java  possible duplicate: declare array java java suppose object car class vehicle want create array n number cars declare java vehiclen carnew vehicle right 
p103
aV vehicle car new vehiclen 
p104
aVway round: vehicle car new vehiclen makes sense number elements array isnt part type car _is_ part initialization array whose reference youre initially assigning car reassign another statement: car new vehicle10 creates new array note ive changed type name match java naming conventions information arrays see section 10 java language specification 
p105
aVlike vehicle car new vehicle10 
p106
aVcorrect way: declare length array veicle cars new veiclen 
p107
asS'34364277'
p108
(lp109
Vparameter ref whose value implicitly reinitialized dlang describes parameter as: parameter initialized upon function entry default value type parameter initialized default value function entry isnt essentially ref import stdstdio void fooout int x writelnx prints 0 x 2 void main int x 1 writelnx prints 1 foox writelnx prints 2 dont see documentation comparing ref accurate conceptualize parameter shortcut writing: import stdstdio void fooref int x x xinit happens implicitly writelnx prints 0 x 2 void main int x 1 writelnx prints 1 foox writelnx prints 2 dont know intricacies language im worried impression cause future grief unforeseen circumstances stronger distinction made parameter storage classes truly ref param thats automatically reinitialized 
p110
aV parameter ref whose value implicitly reinitialized yes parameter initialized default value function entry isnt essentially ref yes stronger distinction made parameter storage classes truly ref param thats automatically reinitialized latter least thats think hope im missing something 
p111
aVyes thats implementation today thats exactly means semantically think params additional return values rather arguments traditional sense ok function cannot take address return value receive data parameter shouldnt used ways either d didnt used ref instead used inout parameter storage classes meant means still going look modify store reference latter makes distinct const \u005c allowed store const scope params lets compiler theory optimize memory allocation data consumption means function going store data variable going look store value already beforehand lost function writes result compiler resets upon function entry guarantee program doesnt depend value passed finally old inout would take data store value today well starting like five years ago usage long gone inout means something entirely different const returning constness conditional input constimmutablemutable qualifiers old usage replaced ref also expanded meaning: longer data going fullblown reference another variable meaning allowed things like take address implemented ref plus automatic reinitialization remember original meaning: write data dont anything else take address thats legal ref unless scope ref ref incorrect supposed write nothing 
p112
asS'33394038'
p113
(lp114
Vrewind working expected simple program program printing first character newly created text file e expected simple program tried look issue aspects couldnt find reason text file created d drive content efghi reason e read even rewind read using getc output 1 includestdioh includestdlibh int main int x file fp fpfopenf:\u005c\u005cdemotxtw iffpnull putswrite error fputsefghifp rewindfp xgetcfp printfdx fclosefp updated: includestdioh includestdlibh int main int x file fp fpfopenf:\u005c\u005cdemotxtw iffpnull putswrite error exitexit_success fputsefghifp rewindfp whilefeoffp xgetcfp printfd\u005cnx fclosefp 
p115
aVfile mode w opens file writing _only_ use w open file writing _and_ reading please see man fopen file modes regarding getc returning 1 verbatim man getc getc returns character read unsigned char cast int eof end file error eof typically equals 1 test printfeofd\u005cn eof 
p116
aVfpfopenf:\u005c\u005cdemotxtw opens file writing try read thats going work ill also note program keeps trying use fp even fails created since checking fp prints error doesnt stop program 
p117
asS'18783482'
p118
(lp119
Vglobal variable c global variable c language different global variable another ones global variable : int globalvariable : int subtractnumbersint number_1 int number_2 int result 0 result number_1 number_2 return result 
p120
aVglobal variables accessed anywhere application deemed bad practice variables modified another function without realizing may give unexpected results want local variables declare inside method ie subtractnumbers 
p121
aVlocal variable stores functions stack visible inside function global variable stores datasection memory visible line program declaration clanguages hides details stack data section programmers also global variable usually lives program running local variable frees memory function ends thats enough 
p122
aVtwo aspects: lifetime lexical scope global variable lifetime program contrast local auto variables lifetime function call explicitly allocated memory locations arbitrary lifetime determined programmer global variable almost universal lexical scope following two caveats first local variable declared function name within function local variable mask global variable prevent accessed normally second global variable declared static accessible source files even though lifetime still program qualified static distinct variable global variables name defined source files program contrast local auto variable lexical scope within block defined particular cannot accessed even function called defining function even though variable alive kicking time 
p123
aV_global variables_ opposed _automatic variables_ stored stack frame functions basically c variable said _automatic_ attached scope function problem variable stop existing outside scope function declared sometimes need variables existing outside scope functions order communicate information functions program best example come would consider verbose flag program verbose may impact point program need shared every function might produce text output practically declare global variable need declare outside scope function something like this: static int myglobal 0 int main return 0 global variable specific location memory outside stack accessed function 
p124
aVglobal variable variable accessed throughout program changes made global variable persist local variable used within block declared eg: int globalvariable0 int main int localvariable0 used within main return 1 int dis globalvariable5 accessed functions made changes 
p125
asS'3266051'
p126
(lp127
Vshell scripting exactly shell scripting bash korn expect use commands linux terminal shell scripting confused exactly shell scripting 
p128
aVshell scripting process creating file containing several shell commands ie ls cd grep etc executed bash korn shells allow interface computer command line rather running programs clicking icons purpose shell scripting automate repetitive tasks setting environment launch program checking see logfiles changed archiving directory set directories number tasks check 
p129
aVterminal runs shell probably bash similar shells different features syntax probably use mostly run commands shells interpreter command language defined shell programs language called shell script see howto bash 
p130
aV shell scripting lets automate tasks command line 
p131
aVaddition interaction environment shell original bourne shell binsh one many alternatives ksh csh bash zsh tcsh different extended syntax provides _programming language like features_ looping conditionals functions variables shell scripting less _writing program favorite shell_ line using shell scripting fuzzy id put near solving class problems writing shell code smart way 
p132
aVshell script script written shell command line interpreter operating system often considered simple domainspecific programming language typical operations performed shell scripts include file manipulation program execution printing text many shell script interpreters double command line interface various unix shells windows powershell msdos commandcom others applescript graphical windows script host wscriptexe add scripting capability computing environments without requiring command line interface examples programming languages primarily intended shell scripting include dcl jcl 
p133
aVshell allows create one _pipelines_ processes one hallmark _pipes filters_ theme _combining together tools tools filters \u005c eg ls egrep paste bc wc_ create filterstools combine shell defines syntax combining filters using _pipes_ also gives way test condition via _if keyword_ \u005c write loops write functions short write programs using tools mostly create powerful tailor made functionality suite needs quickly scripting combine reuse existing tools _scripts_ fruitful ways example consider pipeline seq 100 paste d 123456789109899100 person wrote seq filter would imagined seq used like seq program simple ability _arbitrarily connect_ seq paste filter tool makes extremely powerful concept example consider pipeline seq 100 paste d bc 93326215443944152681699 takes expression feeds bc \u005c yet another filter bc evaluates multiplication expression short _shell script_ allows _combinereuse_ existing tools flow control mechanisms like create powerful _programs_ pretty short time 
p134
asS'20598420'
p135
(lp136
Vc error: assignment readonly variable c code returns error: error: assignment readonly variable \u2018parking\u2019 code: char const const parking false phidgetsvaluephidget3v_1 1000 parking true else parking false error mean fix 
p137
aVparking set const char const const parking false cannot modified parking true raises compile time error reproduce problem simply illustrate: include iostream int main const int j 5 j 7 const means constant meaning allowed change it: error: assignment readonly variable \u2018j\u2019 
p138
aVcode set parking variable const telling compiler modified later modify parking later setting true false using std::string far idiomatic c though would instead: includestring std::string parking false phidgetsvaluephidget3v_1 1000 parking true leds_onleds_red else parking false leds_offleds_red std::string message value: parking abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxy std::string overloads concatenation think last line previously adding pointers probably doesnt think 
p139
aVdeclared parking constant pointer char const const parking false point string literal false may changed also statement char const const message value: parking abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxy invalid addition operator pointers 
p140
asS'5845558'
p141
(lp142
Videntifier variables c say identifier alias variables identifier variables 
p143
aVint f f identifier variable 
p144
aVc99 621: identifier denote object function tag member structure union enumeration typedef name label name macro name macro parameter 
p145
aVsay another way identifiers names given things variables functions identify thing naming 
p146
aVidentifier fancy term used mean \u2018name\u2019 c identifiers used refer number things: weve already seen used name variables functions also used give names things havent seen yet amongst labels \u2018tags\u2019 structures unions enums identifier used variable function data definition etc c programming language identifier combination alphanumeric characters first letter alphabet underline remaining letter alphabet numeric digit underline know variables please check c chapter 1 
p147
asS'655065'
p148
(lp149
Vuse new keyword c ive using c short ive wondering _new_ keyword simply using 1 _new_ keyword myclass myclass new myclass myclassmyfield world 2 without _new_ keyword myclass myclass myclassmyfield world implementation perspective dont seem different im sure however primary language c course 1st method im used difficulty seems method 1 harder use std c classes method use update 1: recently used _new_ keyword _heap_ memory _free store_ large array going scope ie returned function using stack caused half elements corrupt outside scope switching heap usage ensured elements tact yay update 2: friend mine recently told theres simple rule using new keyword every time type new type delete foobar foobar new foobar delete foobar todo: move right place helps prevent memory leaks always put delete somewhere ie cut paste either destructor otherwise 
p150
aVshort answer yes new keyword incredibly important use object data stored heap opposed stack important 
p151
aVsimple answer yes new creates object heap unfortunate side effect manage lifetime explicitly calling delete whereas second form creates object stack current scope object destroyed goes scope 
p152
aVmethod 1 using new allocates memory object free store requires explicitly delete object later dont delete could create memory leak memory stays allocated delete ie could return object created using new example question leak memory method 2 using new allocates memory object stack local variables go generally less memory available stack allocate many objects risk stack overflow wont need delete later memory longer allocated goes scope ie shouldnt return pointer object stack far one use choose method works best given constraints easy cases: dont want worry calling delete potential cause memory leaks youd like return pointer object function must use new 
p153
aVsecond method creates instance stack along things something declared int list parameters passed function first method makes room _pointer_ stack youve set location memory new myclass allocated heap free store first method also requires delete create new whereas second method class automatically destructed freed falls scope next closing brace usually 
p154
aVwithout new keyword youre storing call stack variables stack lead stack overflow 
p155
aV method use almost never determined typing preferences context need keep object across stacks heavy stack allocate free store also since allocating object also responsible releasing memory lookup delete operator ease burden using freestore management people invented stuff like auto_ptr unique_ptr strongly recommend take look might even help typing issues 
p156
aVpassing myclass function expecting exist outside function others said scope arent allocating heap leave function goes away eventually one classic mistakes made beginners attempt create local object class function return without allocating heap remember debugging kind thing back earlier days c 
p157
aVvariable used within context single function youre better using stack variable ie option 2 others said manage lifetime stack variables constructed destructed automatically also allocatingdeallocating variable heap slow comparison function called often enough youll see tremendous performance improvement use stack variables versus heap variables said couple obvious instances stack variables insufficient stack variable large memory footprint run risk overflowing stack default stack size thread 1 mb windows unlikely youll create stack variable 1 mb size keep mind stack utilization cumulative function calls function calls another function calls another function stack variables functions take space stack recursive functions run problem quickly depending deep recursion problem increase size stack recommended allocate variable heap using new operator recommended likely condition variable needs live beyond scope function case youd allocate variable heap reached outside scope given function 
p158
aVimportant difference two everything allocated new behaves much like value types c people often say objects allocated stack probably commonobvious case always true precisely objects allocated without using new _automatic storage duration_ everything allocated new allocated heap pointer returned exactly like reference types c anything allocated stack constant size determined compiletime compiler set stack pointer correctly object member another class adjust size class thats arrays c reference types reference types decide runtime much memory ask applies arrays constant size size determined compiletime allocated automatic storage duration stack dynamically sized arrays allocated heap calling new thats similarity c stops anything allocated stack automatic storage duration actually declare variable auto default storage type specified keyword isnt really used practice comes automatic storage duration means exactly sounds like duration variable handled automatically contrast anything allocated heap manually deleted heres example: void foo bar b bar b2 new bar function creates three values worth considering: line 1 declares variable b type bar stack automatic duration line 2 declares bar pointer b2 stack automatic duration _and_ calls new allocating bar object heap dynamic duration function returns following happen: first b2 goes scope order destruction always opposite order construction b2 pointer nothing happens memory occupies simply freed importantly memory _points to_ bar instance heap touched pointer freed pointer automatic duration second b goes scope since automatic duration destructor called memory freed barinstance heap probably still one bothered delete weve leaked memory example see anything automatic duration _guaranteed_ destructor called goes scope thats useful anything allocated heap lasts long need dynamically sized case arrays also useful use manage memory allocations foo class allocated memory heap constructor deleted memory destructor could get best worlds safe memory allocations guaranteed freed without limitations forcing everything stack pretty much exactly c code works look standard librarys std::vector example typically allocated stack dynamically sized resized internally allocating memory heap necessary user class never sees theres chance leaking memory forgetting clean allocated principle called raii resource acquisition initialization extended resource must acquired released network sockets files database connections synchronization locks acquired constructor released destructor youre guaranteed resources acquire get freed general rule never use newdelete directly high level code always wrap class manage memory ensure gets freed yes may exceptions rule particular smart pointers require call new directly pass pointer constructor takes ensures delete called correctly still important rule thumb 
p159
aVwriting c probably writing performance using new free store much slower using stack especially using threads use need others said need new object needs live outside function object scope object really large dont know size array compile time also try avoid ever using delete wrap new smart pointer instead let smart pointer call delete cases smart pointer isnt smart never store std::auto_ptrlt inside stl container delete pointer soon copy operations inside container another case really large stl container pointers objects boost::shared_ptrlt ton speed overhead bumps reference counts better way go case put stl container another object give object destructor call delete every pointer container 
p160
asS'18379848'
p161
(lp162
Vnewline character c language: \u005cr \u005cn newline character c know different os different lineending characters get translated c newline character character 
p163
aVmean newline newline character \u005cn \u005cr carrier return character mean newline line ending depends operating system: dos uses carriage return line feed \u005cr\u005cn line ending unix uses line feed \u005cn 
p164
aV\u005cr carriage return \u005cn line feed fact different behaviors use different osin unix \u005cn \u005cr\u005cn windowsi hope help 
p165
aV\u005cn youre reading writing text mode files stdinstdout etc must use \u005cn c handle translation youre dealing binary files definition 
p166
aVnewline may thought _some_ char value \u005cn c11 521 c newline comes 3 places: c source code single char endofline file io _text_ mode 1 many compilers treat source text ascii case codes 10 sometimes 13 sometimes paired 1310 newline source code source code another character set different codes may used newline typically marks end line source code actually bit complicated comment directives 2 source code 2 characters text \u005cn represent char newline ascii used char would value 10 3 file io _in text mode_ upon reading bytes input file stdin _depending environment_ bytes values 10 unix _1310_ 1 windows 13 old mac variations translated \u005cn upon writing file stdout reverse translation occurs note: file io binary mode makes translation \u005cr source code carriage return char 1 lone _13_ andor _10_ may also translate \u005cn 
p167
asS'1788923'
p168
(lp169
Vparameter vs argument  possible duplicate: arguments parameters argumentsorparameters got _parameter_ _argument_ kind mixed really pay attention use one use please tell 
p170
aVparameter variable part method\u2019s signature method declaration argument expression used calling method consider following code: void fooint float f things void bar int anint 1 fooanint 20 f parameters anint 20 arguments 
p171
asS'129084'
p172
(lp173
Vbash echo variable name variable value suppose variable var bash assign value example make string: vartest want echo name var value held var latter echo var actually want former answer question fromforloopinbash says use echo var echo returns blank line example bash script binbash echo hi vartest echo var echo bye returns output: hi bye blank line hi bye instead var wrong im running bash 4151 ubuntu 10044 
p174
aV_shell parameter expansion_ name@ name could trick foobar var_namefoo@ echo var_name foo foo bar although feasible cant imagine utility 
p175
aVheres even shorter one: echo \u005cvar 
p176
asS'645994'
p177
(lp178
Vpointer reference reading answers question c pros cons tootherlanguages got doubt reading comments programmers frequently find confusing pointer reference another confusion type std::string evaluates char const pointer array pointer conversion \u2013 johannes schaub litb dec 22 08 1:56 shows doesnt use conventions later languages \u2013 le dorfier dec 22 08 3:35 id call thing pretty trivial issue though oops thanks catching errors examples undefined behavior : although dont understand info size anything first one pointer simply allowed point outside allocated memory \u2013 jalf dec 22 08 4:18 constant poiner \u2013 yesraaj dec 22 08 6:35 constant method const int getfoo const lt\u005c scope getfoo constant therefore readonly prevents bugs provides level guarantee caller object wont change \u2013 doug dec 22 08 16:42 cant reassign ie cannot ampother rvalue type type const ie nonconstant pointer const method pointer const const pointer nonconst \u2013 johannes schaub litb dec 22 08 17:53 think like this: define this_ 0 compiler creates this_ pointer object makes keyword cant assign this_ 0 rvalue course thats macro help understand \u2013 johannes schaub litb dec 22 08 17:55 question pointer reference particular reason making pointer arguments reference would make sense: consider item 1 effective c: use references guaranteed valid object ie null interpretation furthermore references considered safer pointers cant screw memory stray pointer thirdly syntax accessing references little bit nicer shorter accessing pointers 
p179
aVlanguage first evolving early releases real users references pointers references added operator overloading added requires references work consistently one uses object get pointer reference wed write hand write assignment operator return would look simpler return blank slate could argue either way c evolved gradually response feedback community users like successful things value backward compatibility totally overwhelms minor advantagesdisadvantages stemming reference pointer 
p180
aVlittle late party straight horses mouth heres stroupstrup say essentially repeated taken design evolution c book: reference introduced c really c classes references added also chose follow simula usage rather later smalltalk use self 
p181
aVirrespective got think lucky _this_ pointer reference helps make sense _delete_ it: void a::f delete think case without necessarily design c better 
p182
aVc standard states 9321 body nonstatic 93 member function keyword non lvalue expression whose value address object function called type member function class x x member function declared const type const x member function declared volatile type volatile x member function declared const volatile type const volatile x references found something else someone took initiative shot mail mr stroustrup followed found 
p183
asS'399003'
p184
(lp185
Vsizeofsome pointer always equal four example: sizeofchar returns 4 int long long everything ive tried exceptions 
p186
aVcompiling 64bit machine may 8 
p187
aVrecall based size memory address system 32bit address scheme sizeof return 4 since thats 4 bytes 
p188
aVreason size pointer 4 bytes compiling 32bit architecture fryguy pointed 64bit architecture would see 8 
p189
aVgeneral sizeofpretty much anything change compile different platforms 32 bit platform pointers always size platforms 64 bit obvious example change 
p190
aVpointer container address 32 bit machine address range 32 bits pointer always 4 bytes 64 bit machine address range 64 bits pointer 8 bytes 
p191
aVguarantee get sizeofchar 1 guarantees including guarantee sizeofint sizeofdouble practice pointers size 2 16bit system find one 4 32bit system 8 64bit system theres nothing gained relying given size 
p192
aVsize pointer may vary depending architecture numerous exceptions 
p193
aVaddition 163264 bit differences even odder things occur machines sizeofint one value probably 4 sizeofchar larger machines naturally address words instead bytes augment character pointers specify portion word really want order properly implement cc standard unusual hardware designers learned value byte addressability 
p194
aValways equal sizeof size_t 32bit machines tends 4 64bit machines tends 8 
p195
aVanother exception already posted list 32bit platforms pointers take 6 4 bytes: include stdioh include stdlibh int main char far ptr note far pointer printf d\u005cn sizeof ptr return exit_success compile program open watcom run youll get 6 far pointers supports consist 32bit offset 16bit segment values 
p196
aVaddition people said 64bit whatever systems kinds pointer pointertoobject pointertomember might almost size depending theyre implemented compiler: arent necessarily even size try pointertomember pod class pointertomember inherited one base classes class multiple bases fun 
p197
aVtechnically speaking c standard guarantees sizeofchar 1 rest implementation modern x86 architectures eg intelamd chips fairly predictable youve probably heard processors described 16bit 32bit 64bit etc usually means processor uses nbits integers since pointers store memory addresses memory addresses integers effectively tells many bits going used pointers sizeof usually measured bytes code compiled 32bit processors report size pointers 4 32 bits 8 bits per byte code 64bit processors report size pointers 8 64 bits 8 bits per byte limitation 4gb ram 32bit processors comes memory address corresponds byte address memory need integers larger 32bits 
p198
aVeven plain x86 32 bit platform get variety pointer sizes try example: struct struct b : virtual public struct c struct d : public public c int main cout a: sizeofvoid a:: endl cout b: sizeofvoid b:: endl cout d: sizeofvoid d:: endl visual c 2008 get 4 12 8 sizes pointersto memberfunction raymond chen talked 
p199
aV8 bit 16 bit pointers used low profile microcontrollers means every washing machine micro fridge older tvs even cars could say nothing real world programming one real world example: arduino 124k ram depending chip 2 byte pointers recent cheap accessible everyone worths coding 
p200
aVsize pointer int 2 bytes turbo c compiler windows 32 bit machine size pointer compiler specific generally compilers implemented support 4 byte pointer variable 32 bit 8 byte pointer variable 64 bit machine size pointer machines 
p201
aVsize pointer basically depends architecture system implemented example size pointer 32 bit 4 bytes 32 bit 8 bytes64 bit 64 bit machines bit types machine nothing memory address 32 bit machines 232 address space 64 bit machines upto 264 address spaces pointer variable points memory location able point memory address 232 32 bit 264 64 bit machines holds reason see size pointer 4 bytes 32 bit machine 8 bytes 64 bit machine 
p202
aVcompleteness historic interest 64bit world different platform conventions sizes long long long types named llp64 lp64 mainly unixtype systems windows old standard named ilp64 also made int 64bit wide microsoft maintained llp64 longlong 64 bit wide long remained 32 easier porting type ilp64 lp64 llp64 char 8 8 8 short 16 16 16 int 64 32 32 long 64 64 32 long long 64 64 64 pointer 64 64 64 source: 
p203
asS'15801957'
p204
(lp205
Vrecursive sum array c im learning recursion c trying find sum elements main: int main int arr 12345 int sum sum arr_sumarr4 printf\u005cnsum is:dsum return 0 recursive function: n last index array int arr_sum int arr int n must recursive int sum 0 base case: n 0 return sum else sum sum arrn make problem smaller arr_sumarrn1 output is: sum :0 
p206
aVcould add third argument running total calculated far start 0 recursively call function pass running total int arr_sum int arr int n int sum must recursive n 0 return sum else sum arrn return arr_sumarr n sum 
p207
aVproblem code everytime recursive function calls initializes sum 0 declare sum outside recursive method solve problem 
p208
aVtry recursive function: int arr_sum int arr int n n 0 base case: return 0 else return arrn arr_sumarr n1 need add nth case n1 case get base case 
p209
aVreturning thing else partyou also return like return arr_sumarrn1arrn call function n zero got point 
p210
aVtry modified version program work penpaper way flows hope helps include stdioh n last index array int arr_sumint arr int n base case: n 0 return arr0 return arrn arr_sumarrn1 int mainvoid int arr 12345 int sum sum arr_sumarr4 printf\u005cnsum is:d\u005cnsum return 0 
p211
asS'5691795'
p212
(lp213
Vcompile c programming windows 7 looking free tools compile c programs windows 7 ive always compiled c code ubuntu using gcc past compile c code windows 7 please teach : 
p214
aVget gcc windows install mingw well use visual studio 2010 express edition well link 
p215
aVmicrosoft visual studio express full ide powerful debugging tools syntax highlighting etc 
p216
aVmingw _edit:_ apparently wrong thats get talking something know little tauran points project aims provide mingw toolkit current version gcc download website however im sure recommend serious windows development youre idealistic fanboy cant stomach notion ever using microsoft software _highly_ recommend investigating visual studio comes bundled microsofts cc compiler express version includes compiler paidfor editions absolutely free download addition compiler visual studio also provides worldclass ide makes developing windowsspecific applications much easier yes detractors ramble fact fully standardscompliant world writing windows applications theyre never going truly portable include windowsh idealistic dedication ends waste time 
p217
aVfamiliar gcc indicated question install mingw set linuxlike compile environment win7 otherwise visual studio 2010 express best choice 
p218
aVget mingw others suggested would recommend getting simple ide vs express try dev c mingw internally write compile single c files without creating fullblown project 
p219
aVcompiling programs windows 7: download configured borland compiler put borland\u2019s \u2018bin\u2019 folder environmental variables go inside folder \u2018bin\u2019 amp edit file bcc32cfg per folder structure file contains settings headers amp libraries id:\u005cborland\u005cinclude ld:\u005cborland\u005clibd:\u005cborland\u005clib\u005cpsdk create cc program say myprogramcpp use following command compile bunch code: f:\u005cbcc32 myprogramcpp 
p220
asS'838079'
p221
(lp222
Vpassbyname work exactly ive check wikipedia googled still cant wrap mind around passbyname works algol 60 
p223
aVfound good explanation passbyname parameter passing essentially body function interpreted call time textually substituting actual parameters function body sense evaluation method similar c preprocessor macros substituting actual parameters function body function body read write given parameters sense evaluation method similar passbyreference difference since passbyname parameter _evaluated_ inside function parameter ai depends current value inside function rather referring value ai function called page linked examples passbyname useful dangerous techniques made possible passbyname largely superseded today safer techniques passbyreference lambda functions 
p224
aVfuture: concepts programming languages john c mitchell also helpful passbyname perhaps strangest feature algol 60 retrospect use passbyname passbyname result procedure call formal parameter substituted body procedure rule defining result procedure call copying procedure substituting formal parameters called algol 60 copy rule although copy rule works well pure functional programs illustrated \u03b2 reduction lambda calculus interaction side effects formal parameter bit strange example program showing technique referred jensens device: passing expression variable contains procedure procedure use one parameter change location referred other: begin integer integer procedure sumi j integer j comment parameters passed name begin integer sm sm : 0 : 1 step 1 100 sm : sm j sum : sm end printsumi i10 end program procedure sumij adds values j goes 1 100 look code realize procedure makes sense unless changes cause change value j otherwise procedure computes 100j call sumi i10 shown loop body procedure sum adds value i10 goes 1 100 
p225
aVflatlander illuminating example works scala part3passbynamehtml suppose wanted implement _while_: def mywhilecondition: booleanbody: unit: unit condition body mywhileconditionbody call follows: var 0 mywhile 10 printlni 1 scala algol 60 maybe sheds light 
p226
aVim assuming mean callbyname algol 60 callbyname similar callbyreference change value passed parameter differs callbyreference parameter _not_ evaluated procedure called instead evaluated lazily evaluated parameter actually used example suppose procedure fx y pass i2 initially equal 10 f sets x 42 evaluates y see value 21 whereas call reference call value would still see 5 expression i2 isnt evaluated y evaluated many ways appears behave like literal textsubstitution parameters renaming avoid name conflicts practice however implemented using thunks basically closures passed expressions wikipedia article jensens device example using call name particular pay attention term parameter used 
p227
aVpass name symbolic form variable allows updated accessed simultaneously example lets say want triple variable x type int : start doublex real x begin x : x 3 end 
p228
aValgol designed mathematical algorithms like summation function example call name sorry algol bit rusty syntax probably right function sumvarfromtofunction begin real sum 0 var sum function return sum end could use sum like y sumx14sumy38xy inner sumy38xy would generate unnamed function pass outer sum call variables x y passed value name case variables call name equivalent call address reference c gets bit confusing recursion involved borrows made algol machines 48 bit word memory 3 flag bits flag bits implemented cal name algol stack machine function loaded onto stack call name fag would cause called compiler would generate unnamed functions expressions used arguments variable would simple indirect reference error would occur writing function 
p229
aVactually callbyname historical curiosity call byname windows batch files myriad scripting languages knowing works use effectively programming open neat solutions problems know passing strings later expansion manipulated similar effects callby name call :assign x 1 exit b :assign setlocal enabledelayedexpansion endlocal :: argument 1 name variable set 12 exit b 
p230
asS'10757380'
p231
(lp232
Vbash variable variables variable foosomething would like use: barfoo echo bar get something echoed 
p233
aVeval echo \u005c\u005cbar\u005c would 
p234
aVbash use variable use variable variables foosomething barfoo echo bar 
p235
aVaccepted answer great however @edison asked arrays trick want variable holding @ array expanded check function dump variables: function dump_variables var @ echo varvar done stringhello world arrayab cd dump_variables string array array@ outputs: stringhello world arrayab array@ab cd given array first element shown thats whats expanded giving array@ format get array values expanded 
p236
aVmake clear arrays: arr b c construct var assigning string representation variable array value: vararr@ echo var 
p237
asS'8454208'
p238
(lp239
Vscope rules c recently read scope rules c says local auto variable available inside block function declared outside function longer visible also lifetime till end final closing braces function body problem happens address local variable returned function calling function example : main int pfun int fun int localvar0 return localvar control returns back function fun variable localvar longer alive main able access contents address 
p240
aVreferencing location memory function returned dangerous course location still exists may still contain value longer claim memory region likely overwritten new data program continues new local variables allocated stack gcc gives following warning: tc: function \u2018test\u2019: tc:3:2: warning: function returns address local variable enabled default consider test program: int testint p int loc p return loc int mainvoid int c test4 test5 printfd\u005cn c return 0 think prints 
p241
aVaddress returned value stored address cannot reliably read indeed even clear safely assign though chances machines wouldnt problem often read address behaviour undefined read _bad: avoided costs_ particular address may used variables functions access calling functions definitely unlikely see last value stored variable function returned pointer function returning pointer ever required one reason often dynamic memory malloc family functions return pointer new nonstack memory another reason found something location value passed consider strchr strstr another reason returning pointer static object either hidden function file containing source function consider asctime et al worry threadsafety probably others probably common note none return pointer local stackbased variable 
p242
aVvariable gone memory location still exists might even still contain value set however probably get overwritten pretty fast functions called memory address gets reused another functions local variables learn reading call stack local variables functions stored 
p243
asS'342089'
p244
(lp245
Vsign shebang apache httpd projects supportapxsin script text surrounded @ signs comes first line script is: @perlbin@ w perl thing unix kernel thing words possible execute script using pathtoscriptscript_namein reason start script 
p246
aVlooks like placeholder gnu automake template going filled configure script neither perl unix kernel thing gnu autotools thing probably file source distribution file installed system make install package manager alternatively broken build gnu autotools never defined perlbin properly file suffix confirms supposed processed configure execute file placeholder replaced proper path perl executable run configure 
p247
asS'36056662'
p248
(lp249
Vmemory location static extern storage class c two files sharing global variables mainc includestdioh static int b extern int b main extern int printfad a:p\u005cnaa printfbd b:p\u005cnbb fn func includestdioh int b25 int a10 fn printfin fnad a:p\u005cnaa printfin fnbd b:p\u005cnbb compile files im getting compilation error finethe output a10 a:0x804a018 b0 b:0x804a024 fna10 a:0x804a018 fnb25 b:0x804a014 mainc alter lines extern int b static int b like includestdioh extern int b static int b main extern int printfad a:p\u005cnaa printfbd b:p\u005cnbb fn compilation im getting error mainc:6:12: error: static declaration \u2018b\u2019 follows nonstatic declaration mainc:5:12: note: previous declaration \u2018b\u2019 issue memory static extern variables stored couldnt able conclude exact reason compilation error second time note: im using gcc compiler 
p250
aVtwo quotes c standard 622 linkages identifiers help understand problem 4 identifier declared storageclass specifier extern scope prior declaration identifier visible31 prior declaration specifies internal external linkage linkage identifier later declaration linkage specified prior declaration prior declaration visible prior declaration specifies linkage identifier external linkage 7 within translation unit identifier appears internal external linkage behavior undefined translation unit includestdioh static int b extern int b main extern int printfad a:p\u005cnaa printfbd b:p\u005cnbb fn indentifier b internal linkage read first quote first declaration b declares identifier internal linkage due storagecalss specifier static second declaration b storageclass specifier extern prior declaration b first declaration storage class specifier static linkage identifer linkage prior declared identifier translation unit includestdioh extern int b static int b main extern int printfad a:p\u005cnaa printfbd b:p\u005cnbb fn identifier b declared external internal linkage read quotes compiler issues message first identifier b declared external linkage prior declaration given linkage due specifier static identifier declared internal linkage 
p251
asS'840501'
p252
(lp253
Vfunction pointers c work experience lately function pointers c going tradition answering questions decided make small summary basics need quick divein subject 
p254
aV function pointers c lets start basic function _pointing to_: int addintint n int m return nm first thing lets define pointer function receives 2 ints returns int: int functionptrintint safely point function: functionptr addint pointer function lets use it: int sum functionptr2 3 sum 5 passing pointer another function basically same: int add2to3int functionptrint int return functionptr2 3 use function pointers return values well try keep gets messy: function called functionfactory receives parameter n returns pointer another function receives two ints returns another int int functionfactoryint nint int printfgot parameter d n int functionptrintint addint return functionptr much nicer use typedef: typedef int myfuncdefint int note typedef name indeed myfuncdef myfuncdef functionfactoryint n printfgot parameter d n myfuncdef functionptr addint return functionptr 
p255
aVone favorite uses function pointers cheap easy iterators include stdioh define max_colors 256 typedef struct char name int red int green int blue color color colorsmax_colors void eachcolor void fpcolor c int i0 imax_colors fpcolorsi void printcolorcolor c cname printfs iii\u005cn cname cred cgreen cblue int main colors0namered colors0red255 colors1nameblue colors1blue255 colors2nameblack eachcolorprintcolor 
p256
aVfunction pointers c used perform objectoriented programming c example following lines written c: string s1 newstring s1sets1 yes lack new operator dead give away sure seems imply setting text string class using function pointers possible emulate methods c accomplished string class actually struct bunch function pointers act way simulate methods following partial declaration string class: typedef struct string_struct string struct string_struct char getconst void self void setconst void self char value int lengthconst void self char getstringconst void self void setstringconst void self char value int lengthstringconst void self string newstring seen methods string class actually function pointers declared function preparing instance string newstring function called order set function pointers respective functions: string newstring string self stringmallocsizeofstruct string_struct selfget getstring selfset setstring selflength lengthstring selfsetself return self example getstring function called invoking get method defined following: char getstringconst void self_obj return stringself_objinternalvalue one thing noticed concept instance object methods actually part object self object must passed invocation internal hidden struct omitted code listing earlier way performing information hiding relevant function pointers rather able s1sethello one must pass object perform action s1sets1 minor explanation pass reference way well move next part inheritance c lets say want make subclass string say immutablestring order make string immutable set method accessible maintaining access get length force constructor accept char: typedef struct immutablestring_struct immutablestring struct immutablestring_struct string base char getconst void self int lengthconst void self immutablestring newimmutablestringconst char value basically subclasses available methods function pointers time declaration set method present therefore cannot called immutablestring implementation immutablestring relevant code constructor function newimmutablestring: immutablestring newimmutablestringconst char value immutablestring self immutablestringmallocsizeofstruct immutablestring_struct selfbase newstring selfget selfbaseget selflength selfbaselength selfbasesetselfbase charvalue return self instantiating immutablestring function pointers get length methods actually refer stringget stringlength method going base variable internally stored string object use function pointer achieve inheritance method superclass continue polymorphism c example wanted change behavior length method return 0 time immutablestring class reason would done to: 1 add function going serve overriding length method 2 go constructor set function pointer overriding length method adding overriding length method immutablestring may performed adding lengthoverridemethod: int lengthoverridemethodconst void self return 0 function pointer length method constructor hooked lengthoverridemethod: immutablestring newimmutablestringconst char value immutablestring self immutablestringmallocsizeofstruct immutablestring_struct selfbase newstring selfget selfbaseget selflength lengthoverridemethod selfbasesetselfbase charvalue return self rather identical behavior length method immutablestring class string class length method refer behavior defined lengthoverridemethod function must add disclaimer still learning write object oriented programming style c probably points didnt explain well may mark terms best implement oop c purpose try illustrate one many uses function pointers information perform objectoriented programming c please refer following questions: objectorientation c write object oriented code c 
p257
aVfunction pointers become easy declare basic declarators: id: id: _id a_ pointer: d: _d pointer to_ function: dparameters: _d function taking parameters returning_ d another declarator built using rules end somewhere ends id see example name declared entity lets try build function taking pointer function taking nothing returning int returning pointer function taking char returning int typedefs like typedef int returnfunctionchar typedef int parameterfunctionvoid returnfunction fparameterfunction p see pretty easy build using typedefs without typedefs hard either declarator rules applied consistently see missed part pointer points thing function returns thats appears left declaration interest: added end one built declarator already lets building consistently first wordy showing structure using : function taking pointer function taking void returning int returning pointer function taking char returning int see one describe type completely appending declarators one construction done two ways one bottomup starting right thing leaves working way identifier way topdown starting identifier working way leaves ill show ways bottom construction starts thing right: thing returned function taking char keep declarators distinct im going number them: d1char inserted char parameter directly since trivial adding pointer declarator replacing d1 d2 note wrap parentheses around d2 known looking precedence operator functioncall operator without parentheses compiler would read d2char p would plain replace d1 d2 anymore course parentheses always allowed around declarators dont make anything wrong add much actually d2char return type complete lets replace d2 function declarator _function taking parameters returning_ d3parameters d3parameterschar note parentheses needed since _want_ d3 function declarator pointer declarator time great thing left parameters parameter done exactly weve done return type char replaced void ill copy it: d3 id1voidchar ive replaced d2 id1 since finished parameter already pointer function need another declarator id1 name parameter told end one adds type declarator modify one appearing left every declaration functions becomes return type pointers pointed type etc interesting written type appear opposite order right : anyway substituting yields complete declaration times int course int id0int id1voidchar ive called identifier function id0 example top starts identifier left description type wrapping declarator walk way right start _function taking parameters returning_ id0parameters next thing description returning _pointer to_ lets incorporate it: id0parameters next thing _functon taking parameters returning_ parameter simple char put right away since really trivial id0parameterschar note parentheses added since want binds first _then_ char otherwise would read _function taking parameters returning function _ noes functions returning functions arent even allowed need put parameters show short version deriveration since think already idea pointer to: id1 function taking void returning: id1void put int declarators like bottomup finished int id0int id1voidchar nice thing bottomup topdown better im used bottomup people may comfortable topdown matter taste think incidentally apply operators declaration end getting int: int v id0some_function_pointersome_char nice property declarations c: declaration asserts operators used expression using identifier yields type left like arrays hope liked little link people wonder strange declaration syntax functions tried put little c internals possible feel free editfix things 
p258
aVsince function pointers often typed callbacks might want look type safe callbacks applies entry points etc functions callbacks c quite fickle forgiving time : 
p259
aVguide getting fired: abuse function pointers gcc x86 machines compiling code hand: 1 returns current value eax register int eax int\u005cxc3 returns value eax register 2 write swap function int 10 b 20 voidintint\u005cx8b\u005cx44\u005cx24\u005cx04\u005cx8b\u005cx5c\u005cx24\u005cx08\u005cx8b\u005cx00\u005cx8b\u005cx1b\u005cx31\u005cxc3\u005cx31\u005cxd8\u005cx31\u005cxc3\u005cx8b\u005cx4c\u005cx24\u005cx04\u005cx89\u005cx01\u005cx8b\u005cx4c\u005cx24\u005cx08\u005cx89\u005cx19\u005cxc3 swaps values bab 3 write forloop counter 1000 calling function time int\u005cx66\u005cx31\u005cxc0\u005cx8b\u005cx5c\u005cx24\u005cx04\u005cx66\u005cx40\u005cx50\u005cxff\u005cxd3\u005cx58\u005cx66\u005cx3d\u005cxe8\u005cx03\u005cx75\u005cxf4\u005cxc3function calls function 11000 4 even write recursive function counts 100 const char lol \u005cx8b\u005cx5c\u005cx24\u005cx4\u005cx3d\u005cxe8\u005cx3\u005cx0\u005cx0\u005cx7e\u005cx2\u005cx31\u005cxc0\u005cx83\u005cxf8\u005cx64\u005cx7d\u005cx6\u005cx40\u005cx53\u005cxff\u005cxd3\u005cx5b\u005cxc3\u005cxc3 recursively calls function address lol intlollol 
p260
aV another good use function pointers: switching versions painlessly theyre handy use want different functions different times different phases development instance im developing application host computer console final release software put avnet zedboard ports displays consoles neededwanted final release development use printf view status error messages im done dont want anything printed heres ive done: versionh first undefine macros associated versionh undef debug_version undef release_version undef invalid_version define version want use define debug_version current version define release_version uncommented finished debugging ifndef __version_h_ prevent circular inclusions define __version_h_ using protection macros void board_init void noprintfconst char c mimic printf prototype endif mimics printf function prototype ill actually use print stuff screen void zprintfconst char debug version use printf ifdef debug_version include stdioh endif debug release version error ifdef debug_version ifdef release_version define invalid_version endif endif neither debug release version error ifndef debug_version ifndef release_version define invalid_version endif endif ifdef invalid_version wont allow compilation without valid version define error invalid version definition endif versionc define 2 function prototypes present versionh versionc include versionh @name board_init sets application based version type defined versionh includes allowing prohibiting printing stdout must called first thing main @return none void board_init assign print function correct function pointer ifdef debug_version zprintf printf else defined function zprintf noprintf endif @name noprintf simply returns actions performed @return none void noprintfconst char c return notice function pointer prototyped versionh void zprintfconst char referenced application start executing wherever pointing yet defined versionc notice board_initfunction zprintf assigned unique function whose function signature matches depending version defined versionh zprintf printf zprintf calls printf debugging purposes zprintf noprint zprintf returns run unnecessary code running code look like this: mainprogc include versionh include stdlibh int main must run board_init assigns function pointer actual function board_init void ptr malloc100 allocate 100 bytes memory malloc returns null unable allocate memory ptr null zprintfunable allocate memory\u005cn return 1 things return 0 code use printf debug mode nothing release mode much easier going entire project commenting deleting code need change version versionh code rest 
p261
aVstarting scratch function memory address start executing assembly language called call functions memory addressnow come back c function memory address manipulated pointers cso rules c 1first need declare pointer function 2pass address desired function notethe functions type simple programme illustrate every thing includestdioh void print declare function pointers void sayhellodeclare function whose address passed functions type int main printsayhelloaddressof sayhello assigned print printprint call function return 0 void sayhello printf\u005cn world enter image description lets see machine understands themglimpse machine instruction programme 32 bit architecture red mark area showing address exchanged storing eaxthen call instruction eax eax contains desired address function 
p262
aVfunction pointer usually defined typedef used param amp return value answers already explained lot give full example: include stdioh define num_a 1 define num_b 2 define function pointer type typedef int two_num_operationint int actual standalone function static int sumint int b return b use function pointer param static int sum_via_pointerint int b two_num_operation funp return funpa b use function pointer return value static two_num_operation get_sum_fun return sum test use function pointer variable void test_pointer_as_variable create pointer function two_num_operation sum_p sum call function via pointer printfpointer variable:\u005ct d d d\u005cn num_a num_b sum_pnum_a num_b test use function pointer param void test_pointer_as_param printfpointer param:\u005ct d d d\u005cn num_a num_b sum_via_pointernum_a num_b sum test use function pointer return value void test_pointer_as_return_value printfpointer return value:\u005ct d d d\u005cn num_a num_b get_sum_funnum_a num_b int main test_pointer_as_variable test_pointer_as_param test_pointer_as_return_value return 0 
p263
aVone big uses function pointers c call function selected runtime example c runtime library two routines qsort bsearch take pointer function called compare two items sorted allows sort search respectively anything based criteria wish use basic example one function called printint x int y turn may require call add function sub similar types add one function pointer argument print function shown below: int add return 10010 int sub return 10010 void printint x int y int func printfvalue : d xyfunc int main int x100 y200 printxyadd printxysub return 0 
p264
aVfunction pointers useful many situations eg: com objects members pointer function ag: thislpvtbladdrefthis addref pointer function function callback example user defined function compares two variables passed callback special sort function useful plugin implementation application sdk 
p265
asS'7109964'
p266
(lp267
Vcreating header file c anyone explain create header file c simple example beginning end 
p268
aV ifndef my_header_h define my_header_h put function headers endif my_header_h serves doubleinclusion guard function headers need define signature without parameter names like this: int foochar really want also include parameters identifier necessary identifier would used functions body implementation case header parameter signature missing declares function foo accepts char returns int source file would have: include my_headerh int foochar name stuff return 0 
p269
aVfooh ifndef foo_h_ include guard define foo_h_ int fooint x example function declaration endif foo_h_ fooc include fooh include header strictly necessary int fooint x function definition return x 5 mainc include stdioh include fooh include header obtain function declaration int mainvoid int y foo3 use function printfd\u005cn y return 0 compile using gcc gcc o my_app mainc fooc 
p270
aVheader files contain prototypes functions define c cppcxx file depending youre using c c want place ifndefdefines around h code include h twice different parts programs prototypes included clienth ifndef client_h define client_h short socketconnectchar hostunsigned short portchar sendbufchar recievebuf long rbufsize endif client_h youd implement h c file like so: clientc include clienth short socketconnectchar hostunsigned short portchar sendbufchar recievebuf long rbufsize short ret 1 implementation return ret 
p271
aVmyfileh ifndef _myfile_h define _myfile_h void function endif myfilec include myfileh void function 
p272
asS'170911'
p273
(lp274
Vprint current month day year using awk date cant seem grab month day year using awk print 2 3 6 date anyone know 
p275
aVtry piping output date command instead like so: date awk print 2 3 6 dec 1 2014 truly want take output date using command similar youll need redirect using herestring aka ltltlt assuming zsh shell fairly recent version ksh93 bash awk print 2 3 6 date dec 1 2014 second form take output command date redirect awk via stdin using awk needed date command formatting abilities date b d y dec 01 2014 
p276
aVuse awk date b d y gives values without hassle 
p277
aVpipe output date awk: date awk print 2 3 6 1 dec 2014 get date format you: date d b y 01 dec 2014 
p278
asS'29731672'
p279
(lp280
Vgetting filemode file struct piece c code function specific operates file depending mode file opened certain things cannot way obtain mode file opened file info rely created somewhere else program actual filename long lost reaches function cannot influence would prefer portable solution edit: im interested filerestrictions specifying users file mostly irrelevant dealt upon file opening bit code care openmode 
p281
aVassuming linuxunix: see fstat permissions get file descriptor us fileno function 
p282
aVposix sufficiently similar systems fcntlfilenof f_getfl return modeflags open file form would passed open fopen check whether opened readonly readwrite writeonly something like: int mode fcntlfilenof f_getfl switch mode o_accmode case o_rdonly: case o_wronly: case o_rdwr: also check flags like o_append etc 
p283
asS'35076280'
p284
(lp285
Vneed declare function extern works without new concept extern today work came across large number extern functions declared inside header file fooh somewhere mess folders found fooc file contained definition said functions include fooh got home decided play around extern storage class examples reading c book came expect work mainc include stdioh int data int main data 6 printfd\u005cn getdata data 8 printfd\u005cn getdata return 0 externsc int getdata extern int data return data bash gcc mainc externsc o externs didnt think would work function technically least verbose defined main work default storage class int getdata extern even bother following example similar saw work main2c include stdioh include externsh int data int main data 6 printfd\u005cn getdata data 8 printfd\u005cn getdata return 0 externsh ifndef _externsh_ define _externsh_ extern int getdata endif externsc int getdata extern int data return data bash gcc main2c externsc o externs 
p286
aVfunctions implicitly extern change declaring static right redundant say extern int getdata compared int getdata people feel improves code clarity note since c99 first example illformed calls getdata without function declared c89 performed implicit int getdata declaration since c99 removed use compiler switches stdc99 pedantic test 
p287
aVdefault gcc version 4x earlier compiles c89c90 compatibility mode require functions declared use undeclared functions inferred return type int default gcc 5x later compiles c11 compatibility mode require functions declared use \u2014 c99 given code compiled without complaints infer using gcc 4x even obliged provide full prototypes though would foolish routinely compile code options: gcc stdc11 o3 g wall wextra werror wmissingprototypes wstrictprototypes \u005c woldstyledefinition woldstyledeclaration \u2026 suspect redundancy options catch many problems get around running code 
p288
asS'492384'
p289
(lp290
Vfind sizeof pointer pointing array first code: int main int days 12345 int ptr days printfu\u005cn sizeofdays printfu\u005cn sizeofptr return 0 way find size array ptr pointing instead giving size four bytes 32bit system 
p291
aVcant compiler doesnt know pointer pointing tricks like ending array known outofband value counting size value thats using sizeof another trick one mentioned zan size somewhere example youre dynamically allocating array allocate block one int bigger one need stash size first int return ptr1 pointer array need size decrement pointer peek stashed value remember free whole block starting beginning array 
p292
aVanswer c programmers store size array somewhere part structure programmer cheat bit malloc memory requested order store length value start array 
p293
aVdynamic arrays _malloc_ c _new_ need store size array mentioned others perhaps build array manager structure handles add remove count etc unfortunately c doesnt nearly well c since basically build different array type storing cumbersome multiple types arrays need manage static arrays one example common macro used get size recommended check parameter really static array macro used real code though eg linux kernel headers although may slightly different one below: definedarray_size define array_sizex sizeofx sizeofx0 endif int main int days 12345 int ptr days printfu\u005cn array_sizedays printfu\u005cn sizeofptr return 0 google reasons wary macros like careful possible c stdlib vector much safer easier use 
p294
aVspecific example yes use typedefs see course way youre well use sizeof_days since know pointer pointing void pointer returned malloc like way determine data structure pointer pointing thus way determine size include stdioh define num_days 5 typedef int days_t num_days define sizeof_days sizeof days_t int main days_t days days_t ptr days printf sizeof_days: u\u005cn sizeof_days printf sizeofdays: u\u005cn sizeofdays printf sizeofptr: u\u005cn sizeofptr printf sizeofptr: u\u005cn sizeofptr return 0 output: sizeof_days: 20 sizeofdays: 20 sizeofptr: 20 sizeofptr: 4 
p295
aVclean solution c templates without using sizeof following getsize function returns size static array: include cstddef templatetypename size_t size size_t getsizet size return size example foo_t structure: include cstddef templatetypename size_t size size_t getsizet size return size struct foo_t int ball int main foo_t foos3 123 foo_t foos5 12345 printfu\u005cn getsizefoos3 printfu\u005cn getsizefoos5 return 0 output: 3 5 
p296
aVcorrect answers stated cannot get information decayed pointer value array alone decayed pointer argument received function size originating array provided way function come know size heres suggestion different provided thus farthat work: pass pointer array instead suggestion similar c style suggestions except c support templates references: define array_sz 10 void foo int arrarray_sz printfu\u005cn unsignedsizeofarrsizeofarr suggestion kind silly problem since function defined know exactly size array passed hence little need use sizeof array though offer type safety prohibit passing array unwanted size int x20 int y10 foox error fooy ok function supposed able operate size array provide size function additional information 
p297
aVpossible find sizeof value pointer compiler doesnt know long pointer poiting sizeof pointer 2 4 depending compiler 
p298
aV define array_size 10 struct int16 size int16 arrayarray_size int16 property1array_size161 int16 property2array_size161 array1 array_size 0 1 2 3 4 5 6 7 8 9 undef array_size array_size passing _size_ variable: define array_size 30 struct int16 size int16 arrayarray_size int16 property1array_size161 int16 property2array_size161 array2 array_size undef array_size usage is: void main int16 size array1size int i0 isize array1arrayi 2 
p299
aVsolution problem save length array struct array metainformation array include stdioh include stdlibh struct array int length double array typedef struct array array array newarrayint length allocate memory struct array array newarray array mallocsizeofarray insert nonnegative lengths newarraylength length 0 length : 0 newarrayarray double malloclengthsizeofdouble return newarray void setarrayarray structureint lengthdouble array structurelength length structurearray array void printarrayarray structure ifstructurelength 0 int printflength: d\u005cn structurelength 0 structurelength printfg\u005cn structurearrayi else printfempty array length 0\u005cn int main int array negativetest days newarray5 double moredays 12345678910 0 dayslength daysarrayi i1 printarraydays setarraydays10moredays printarraydays negativetest newarray5 printarraynegativetest return 0 care set right length array want store way check length like massively explained 
p300
aVfunctions might help get around problem mention zan lynx paul tomblin correct says include stdioh include stdlibh int main int truint 12345679 int intlength snprintf null 0 d truint printfsize truint d: \u005cn intlength int ptr_truint truint printfsize ptr_truint d: \u005cn snprintf null 0 d ptr_truint0 int daysint 123456789 int ptrintdays daysint printfsize ptrdays d: \u005cn\u005cn getintpointersizeptrintdays char stringpointer1 123456789 printfsize stringpointer d: \u005cn getcharpointersizestringpointer char dayschar 123456789\u005c0 printfsize dayschar u: \u005cn sizeofdayschar char ptrdayschar dayschar printfsize ptrdayschar2 u: \u005cn getcharpointersizeptrdayschar char dayschar2 123456789 char ptrdayschar2 dayschar2 printfsize ptrdayschar2 u: \u005cn getcharpointersizeptrdayschar2 return 0 int getintpointersizeunsigned pointer int i1 whilepointeri \u005c0 return int getcharpointersizechar pointer int i1 whilepointeri \u005c0 return 
p301
aVcant use sizeofptr find size array ptr pointing though allocating extra memorymore size array helpful want store length extra space 
p302
aV int main int days 12345 int ptr days printfu\u005cn sizeofdays printfu\u005cn sizeofptr return 0 size days 20 elements size data type size pointer 4 matter pointing pointer points element storing address 
p303
aVmagic solution c reflective language objects dont automatically know many choices: 1 obviously add parameter 2 wrap call macro automatically add parameter 3 use complex object define structure contains dynamic array also size array pass address structure 
p304
asS'12262696'
p305
(lp306
Vusing unset vs setting variable empty im currently writing bash testing framework test function standard bash tests well predefined matchers used matchers wrappers besides returning return code set meaningful message saying expected example: string_equals 1 2 error_messageexpected 1 2 return 1 fi matcher used fails error_message set point later test whether tests succeeded succeeded print expectation green failed red furthermore may error_message set test message exists print unset following test may set error_message: error_message printf s\u005cn error_message unset v error_message fi question better unset variable set like error_message one better actually make difference maybe additional flag indicating message set 
p307
aVterms environment variables difference empty string set: var var produce thing bash man pages confirm using unset though actually deletes variable mostly dont see difference unless using set u: homeuser1 var homeuser1 echo var homeuser1 set u homeuser1 echo var homeuser1 unset var homeuser1 echo var bash: var: unbound variable really depends going test variable add preferred way testing set is: n var true zero length z var true zero length add setting empty string using unset drastically different effects arrays guess case 
p308
aVsaid using unset different arrays well foo4 5 6 foo2 echo foo 3 unset foo2 echo foo 2 
p309
asS'32049884'
p310
(lp311
Vfile pointer c  trying understand file pointer increment means declared file pointer fp assuming use fopen file say test99txt try read compiler dynamically allocate memory heap ofcourse think internally fopen make use malloc order put file main memory file streamdata file put memory assuming fp contains start address file stream incrementing fp 1 fp pointer type file increasehop position fp total size datastream inside file test99txt lets say incrementing fp move fp pointer next character 1 byte within file stream output fp moved 16 bytes:see diff misunderstanding _information : size file 66 bytes8kb using program unix platform 64 bit machine ia64 hp server compiler hp hpacclink program c_ includestdioh includestdlibh int main file fp char ch fpfopenhomeakhilsfile_dirtest99txtr printfaddress file d fp printf\u005cnlets see value fp d\u005cn fp fclosefp output : address file 2130569600 lets see value fp 2130569616 
p312
aVincrementing file pointers points one file structure allocated fopen 
p313
aVfp pointer object type file doesnt refer data actual file contains internal data like handles stuff increase pointer increased size file object depends implementation 16 bytes example 2130569600 become 2130569616 try access something incremented address probably get error 
p314
aVincremental function adds number weight type using pointers permits go next pointer table pointer otherwise bad use adds 16 bytes original address file pointer weight 16 bytes like pointers like maxim egorushkin said point structure allocated sorry bad english hope ill helpfull 
p315
asS'5787867'
p316
(lp317
Vfile read write file ive managed open file read writing another file varfopenfiler w even r w moded cant open file alter contents imagine this: int formatacao char originalse cadeia nao tiver escrita em maiusculas esta funçao vai alteralas para tal int val1 file original_open original_open fopen originalr original_open0 printf ficheiro c 1original val1fgetcoriginal_openeof val1aval1zval1 fputcval132original_open else fputcval1original_open fclose original_open return 0 code works errors warning problem is: erases contents file use like works: int main int val1val2nr0 file fp1 file fp2 fp1fopen dnaexampletxtr fp2fopen dnaexample1txtw fp10 printf epic fail 1\u005cn val1fgetcfp1eof val1aval1zval1 fputcval132fp2 else fputcval1fp2 fclose fp1 fclose fp2 return 0 flawlessly open file read char char decide want change char 
p318
aVopen file option order append file: fopen dnaexampletxta w erase file exists create new specified doesnt exist open existing file able edit read file operations here: 
p319
aVopen file append mode original_open fopen originala 
p320
aVneed intervene file positioning function output input unless eof found input works me: include stdioh int formatacao char original int val1 file original_open int write_at read_at original_open fopenoriginal r original_open 0 printfficheiro s\u005cn original write_at read_at 0 val1 fgetcoriginal_open eof read_at ftelloriginal_open fseekoriginal_open write_at seek_set val1 val1 z fputcval1 32 original_open else fputcval1 original_open write_at ftelloriginal_open fseekoriginal_open read_at seek_set fcloseoriginal_open return 0 int mainvoid formatacao5787867txt return 0 
p321
asS'4955198'
p322
(lp323
Vdereferencing pointer mean please include example explanation 
p324
aVcode explanation pointer basics dereference operation starts pointer follows arrow access pointee goal may look pointee state change pointee state dereference operation pointer works pointer pointee pointee must allocated pointer must set point common error pointer code forgetting set pointee common runtime crash error code failed dereference operation java incorrect dereference flagged politely runtime system compiled languages c c pascal incorrect dereference sometimes crash times corrupt memory subtle random way pointer bugs compiled languages difficult track reason void main int x allocate pointer x x mallocsizeofint allocate int pointee set x point x 42 dereference x store 42 pointee 
p325
aVdereferencing pointer means getting value stored memory location pointed pointer operator used called dereferencing operator int 10 int ptr printfd ptr ptr im dereferencing pointer means asking value pointed pointer ptr pointing location memory variable location 10 dereferencing gives value since indirect control location modify content using pointer indirect way access ptr 20 content longer 10 modified 20 
p326
aV reviewing basic terminology _usually_ good enough unless youre programming assembly envisage _pointer_ containing numeric memory address 1 referring second byte processs memory 2 third 3 fourth happened 0 first byte well well get later see _null pointers_ accurate definition pointers store memory addresses relate see _more memory addresses probably dont need know_ want access datavalue memory pointer points contents address numerical index _dereference_ pointer different computer languages different notations tell compiler interpreter youre interested pointedto value focus c c pointer scenario consider c given pointer p const char p abc four bytes numerical values used encode letters b c 0 byte denote end textual data stored somewhere memory numerical address data stored p example string literal happened address 0x1000 p 32bit pointer 0x2000 memory content would be: memory address hex variable name contents 1000 97 ascii 1001 b 98 1002 c 99 1003 0 20002003 p 1000 hex note variable nameidentifier address 0x1000 indirectly refer string literal using pointer storing address: p dereferencing pointer refer characters p points dereference p using one notations c: assertp first character address p assertp1 b p1 actually dereferences pointer created adding p 1 times size things p points: case theyre char 1 byte c assertp 1 b another notation p1 also move pointers pointedto data dereferencing go: p increment p 0x1001 assertp b p 0x1001 b data written things like this: int x 2 int p_x x put address x variable pointer p_x p_x 4 change memory address p_x 4 assertx 4 check x 4 must known compile time would need variable called x code asks compiler arrange stored ensuring address available via x dereferencing accessing structure data member c variable pointer structure data members access members using dereferencing operator: typedef struct x int i_ double d_ x x x x p x pd_ 314159 dereference access data member xd_ pd_ 1 another equivalent notation accessing xd_ multibyte data types use pointer computer program also needs insight type data pointed data type needs one byte represent pointer normally points lowestnumbered byte data looking slightly complex example: double sizes 103 134 112 194 double p sizes assertp0 103 knows look bytes first double value assertp1 134 actually looks bytes address p 1 sizeofdouble sizeofdouble almost always eight bytes assertp advance p sizeofdouble assertp 134 double memory beginning address p value 134 p 2 298 change sizes3 194 298 note: earlier p 2 sizes3 pointers dynamically allocated memory sometimes dont know much memory youll need program running sees data thrown dynamically allocate memory using malloc common practice store address pointer int p mallocsizeofint get memory somewhere p 10 dereference pointer memory write value fnp call function passing value address p p 3 change value adding 3 freep release memory back heap allocation library c memory allocation normally done new operator deallocation delete: int p new int10 memory one int initial value 10 delete p p new int10 memory ten ints unspecified initial value delete p p new int10 memory ten ints value initialised 0 delete p see also _c smart pointers_ losing leaking addresses often pointer may indication data buffer exists memory ongoing use databuffer needed ability call free delete avoid leaking memory programmer must operate copy pointer const char p asprintfname: name common nonstandard printfonheap replace nonprintable characters underscores const char q p q q isprintq q _ printfs\u005cn p q modified freep carefully orchestrate reversal changes const size_t n p n p n restore earlier value c smart pointers c best practice use smart pointer manage pointers automatically deallocating smart pointers destructors run since c11 standard library provides two unique_ptr theres single owner allocated object std::unique_ptrt pnew t42 meaning call_a_functionp function might throw delete unreliable ps destructors guaranteed run calling delete shared_ptr share ownership using reference counting std::shared_ptrt pnew t314 pi number_storagemay_addp might copy p container ps destructor delete number_storage didnt copy null pointers c null 0 \u005c additionally c nullptr \u005c used indicate pointer doesnt currently hold memory address variable shouldnt dereferenced used pointer arithmetic example: const char p_filename null 0 nullptr c char c c getoptargc argv f: eof switch c case f: p_filename optarg break p_filename null converts false get f flag specified c c inbuilt numeric types dont necessarily default 0 bools false pointers always set null set 0falsenull theyre static variables c direct indirect member variables static objects bases undergo zero initialisation eg new new tx y z perform zero initialisation ts members including pointers whereas new assign 0 null nullptr pointer bits pointer necessarily reset: pointer may contain 0 hardware level refer address 0 virtual address space compiler allowed store something else reason whatever come along compare pointer 0 null nullptr another pointer assigned comparison must work expected source code compiler level null potentially bit magical c c languages memory addresses probably dont need know strictly initialised pointers store bitpattern identifying either null often virtual simple case numeric offset processs entire virtual address space complex cases pointer may relative specific memory area cpu may select based cpu segment registers manner segment id encoded bitpattern andor looking different places depending machine code instructions using address example int properly initialised point int variable might casting float \u005c access value gpu memory quite distinct int variable cast function pointer might refer distinct memory holding machine opcodes function 3gl programming languages like c c tend hide complexity that: compiler gives pointer variable function dereference freely long variables destructeddeallocated meanwhile compilers problem whether eg particular cpu register needs restored beforehand distinct machine code instruction used get pointer element array use pointer arithmetic move anywhere else array even form address onepasttheend array thats legal compare pointers elements array similarly moved pointer arithmetic onepasttheend value c c compiler ensure works specific os functions eg shared memory mapping may give pointers theyll work within range addresses makes sense attempts move legal pointers beyond boundaries cast arbitrary numbers pointers use pointers cast unrelated types typically _undefined behaviour_ 
p327
aVpointer reference value much like library call number reference book dereferencing call number physically going retrieving book int a4 int pa printf referencecall number variable p\u005cn pa causes pa dereference via callnumber pa printf d\u005cn pa prints 4 book isnt librarian starts shouting shuts library couple people set investigate cause person going find book isnt 
p328
aVsimple words dereferencing means accessing value certain memory location pointer pointing 
p329
aVthink previous answers wrong state dereferencing means accessing actual value wikipedia gives correct definition instead: operates pointer variable returns lvalue equivalent value pointer address called dereferencing pointer said dereference pointer without ever accessing value points example: char p null p dereferenced null pointer without accessing value could do: p1 p sz sizeofp dereferencing never accessing value code crash: crash happens actually _access_ data invalid pointer however unfortunately according standard dereferencing invalid pointer undefined behaviour exceptions even dont try touch actual data short: dereferencing pointer means applying dereference operator operator returns lvalue future use 
p330
asS'17148411'
p331
(lp332
Vfile read problems c im random glitches occur reading writing file c typically algorithms work correctly occasionally ill get hiccup loop im using stops working file im using reading writing says incomplete last line 1 line 2 characters vi looks like working im keeping track value file counting every time function executes however loops freeze vi file reads 1 line 3 characters mention incomplete last line would make sense file read line incomplete case actually works normally fix deleting file letting program recreate meant monitoring application need squash glitch completely im using fprintf fgets read write file knowledge supposed terminate file correctly wrong help would much appreciated thanks im enclosing code ive written whole algorithm below: loop executes set countdown timer outage email 24 hours access filepath f_ok 1 file exist exist nothing else filefd fopen filepath w 0 generates file fclosefilefd filefd fopen filepath r 0 fprintffilefd d bridgetimer_limit reset timer default countdown rewindfilefd fgetsbridgeonetimeleft 10 filefd bridgeonedowncount atoibridgeonetimeleft fclosefilefd filefd fopen filepath r 0 fgetsbridgeonetimeleft 10 filefd rewindfilefd bridgeonedowncount atoibridgeonetimeleft bridgeonedowncount 0 timer still counting continue timer countdown decrementing 15 minutes per count bridgeonedowncount bridgeonedowncount 1 fprintffilefd d bridgeonedowncount rewindfilefd pinfobridgeonedowncount counting d bridgeonedowncount else bridgeonedowncount 1 0 time reaches 0 sprintfcmd2which send_alert_email \u005cs\u005c reasontext systemcmd2 fclosefilefd else filefd fopen filepath r 0 fprintffilefd d bridgetimer_limit reset timer default countdown rewindfilefd fgetsbridgeonetimeleft 10 filefd bridgeonedowncount atoibridgeonetimeleft fclosefilefd return 
p333
aVdifficult explain error code please check issue may path condition closes program need open close several times open close lastly need abort rest operation loop use continue keyword fclosefilefd finally loop use iffilefd null fclosefilefd 
p334
asS'17003696'
p335
(lp336
Vdifference file open modes c says r w read write fileso way r w different file modes write middle filehere want overwrite content file particular position inserting 
p337
aVr open text file reading w create text file writing discard previous contents append open create text file writing end file r open text file update ie reading writing w create text file update discard previous contents append open create text file update writing end w w modes u write using fseek note w creates file doesnt exists 
p338
aVw mode truncate empty file want change contents rather write new file use r note tim cooper noted cannot append middle file overwite certain parts using fseek write functions cannot insert text middle without rewriting everything comes 
p339
asS'29813663'
p340
(lp341
Verror: arguments function new c college course learning started functions first lab dealing keep getting error case switch statement sure correct error: arguments function void addfractionint int int int include iostream include cstdlib using namespace std void clearscreen void printmenu void getfractionint int void addfractionint int int int void subfractionint int int int void mulfractionint int int int void divfractionint int int int void reducfractionint int int main clearscreen printmenu return 0 function clears screen void clearscreen cout string50 \u005cn function prints menu screen void printmenu int menu cout fraction calculator\u005cn cout \u005cn cout 1 add fraction\u005cn cout 2 subtract fraction\u005cn cout 3 multiply fraction\u005cn cout 4 divide fraction\u005cn cout 5 quit\u005cn cout : cin menu switch statement drive menu switch menu case 1: addfraction break case 2: subfraction break case 3: mulfraction break case 4: divfraction break case 5: exit0 break default: cout endl invalid choice\u005cn endl printmenu void addfractionint f1n int f1d int f2n int f2d clearscreen getfractionf1n f1d getfractionf2n f2d int fan fad fan f1n f2d f2n f1d fad f1d f2d reducfraction cout fan endl endl fad void subfractionint f1n int f1d int f2n int f2d clearscreen getfractionf1n f1d getfractionf2n f2d int fan fad fan f1n f2d f2n f1d fad f1d f2d reducfraction cout fan endl endl fad void mulfractionint f1n int f1d int f2n int f2d clearscreen getfractionf1n f1d getfractionf2n f2d int fan fad fan f1n f2n fad f1d f2d reducfraction cout fan endl endl fad void divfractionint f1n int f1d int f2n int f2d clearscreen getfractionf1n f1d getfractionf2n f2d int fan fad fan f1n f2d fad f2n f1d reducfraction cout fan endl endl fad void getfractionint numerator int denominator cout please enter numerator: cin numerator cout please enter denominator: cin denominator whiledenominator 0 cout invalid denominator enter new one: cin denominator clearscreen 
p342
aVtry: case 1: addfraction1 2 3 4 break mentioned comments code calling method undeclared variables 
p343
aVplease input parameter value calling function example: case 1: addfraction1234 break 
p344
aVdeclared addfraction function takes four parameters void addfractionint f1n int f1d int f2n int f2d call within switch statement provide 0 arguments addfraction must pass function 4 arguments example following would valid call: addfraction1 2 3 4 
p345
aVfunctions used arguments passed calling functions switch case passing arguments take fractions users first call functions operate fractions 1 ask user fractions 2 use fraction values function calling case 1: addfraction1 2 3 4 break 
p346
aVcall functions without arguments switch menu case 1: addfraction break case 2: subfraction break case 3: mulfraction break case 4: divfraction break case 5: exit0 functions declared multiple parameters void addfractionint int int int void subfractionint int int int void mulfractionint int int int void divfractionint int int int must supply required arguments functions calls fact could declare functions without parameters example void addfraction int f1n f1d int f2n f2d clearscreen getfractionf1n f1d getfractionf2n f2d int fan fad fan f1n f2d f2n f1d fad f1d f2d reducfraction cout fan endl endl fad way functions could defined declared 
p347
asS'32972089'
p348
(lp349
Vreturn statement work c question return statement c really returns: int baseint ifa 1 return 0 int inherit base1 rest code within inherit function base called executes return 0 case rest code inherit still execute return statement really work 
p350
aVsince didnt returned result base reason inherit wont execute rest lines function keeps executing reaches return statement inherit met function call base calling function returns value doesnt mean returning result example someone sends fetch receipt store fact store gave receipt doesnt mean neccesarily gave one sent first place hand return result base wont execute rest code int inherit return base1 rest code 
p351
aVcall return code code function stop working reaches point control move back function called program end depending program return located 
p352
aVcourse continues execute rest code base method returns explicit return counts also inherit method want inherit method return value base add return keyword int inherit return base1 rest code left actually nitpick: example compiler probably complain return value case 1 would add something like int baseint ifa 1 return 0 else return 1 
p353
aV within inherit function base called return 0 case rest code inherit still execute yes execute return function base give back control value calling function rest calling function inherit executed scope ends return encountered inherit _note_ \u005c function base also return value condition met pointed others invoke undefined behaviour 
p354
aVyes calling base code continue run _undefined behavior shouldknowhtml_ edits illustrate capturing return value using branch statement always include return statement nonvoid function: int baseint ifa 1 return 0 else return 1function provided alternative return path int inherit int status base1 ifstatus 0 rest code return status 
p355
aVreturn statement returns value caller use return value influence anything callers code caller uses value eg checking value statement return executed called function stops executing local variables released return statement return single wordsized value int pointer newer c versions return statement return composite values eg struct case compiler immediately performs copy operation struct returned could local automatic variable called function variables allocated stack destroyed overwritten next call caller hence compiler must save immediately note returning pointer local automatic variable called function error variable released upon return overwritten often valued returned returned register traditionally intel eax register examples: return return value int return p return pointer p struct my_struct 0 local struct stack return return whole structure caller: struct my_struct s2 myfunction compiler copies s2 struct my_struct 0 local struct stack return return pointer error: caller: struct my_struct myfunction overwritten nex call 
p356
aVwrite int inherit int x99 xbase1 dothis rest code x 0 program goes next line dothis 
p357
aVcode little minimal comfort id feel happier with: int baseint 1 return 0 return 37 int inheritvoid int n base1 printfbase1 d\u005cn n return n 3 inherit calls base current state stored function base run returns value code return value captured variable n used printf call return within inherit thats return works: unilaterally stops execution current function continues calling function even main return terminates current function returns value calling function c runtime \u2014 c runtime ensures process exits usually relaying returned value environment shell program unix example note revised code ensures base always returns value would lead undefined behaviour general function ever called value 1 argument would ok calling function first place always ensure function supposed return value returns function including particular one end function returns value original code return end \u2014 thats bad 
p358
aVconsidering obvious mistake missing return value: int inherit int return_value base1 rest code return statement really work function calls case inherit calls base need return instruction following function call program continues execution cycle return requires two pieces information: 1a return statement indicates end execution function semantics low level high level languages1 2return address: processor knows return completing function call piece information normally stored function called function called among things2 return address stored two special places mostly used: special register stack thus return statement reached _flow control_ transferred address instruction following _function call_3 addition return specific values eg result computation etc predefined _returning type_ function signature whose value direct implication whether execution continue case return valid value type int function base undefined implication rest execution base provide return statement possible inputs lead _undefined behaviour_ rest code inherit still execute value calling ie:1 continues execute whatever follows inherit base function returns value 1\u005c high level languages allow default fallthrough mechanism dont explicitly specify end procedure control returned end block 2\u005c modifies pc program counter 3\u005c actual return address stored depends processor processors sparc store address call instruction others mips pentium store address instruction following call instruction 
p359
aV c procedure oriented programming langauge unlike oop focus variable data structures amp subroutineshowever oop also works way program executing int inherit function makes call int baseint supplying value 1 athis subroutinesince subroutine essentially group computational instructions grouped programmer various reasons might ease coding better organizationetc base1 subroutine finishes execution next instruction loadedexecuted one immediately follows need know inherit function keeps executing encounters code signals stopthe common exit0exit entire program return valwhere val stores integercontrol returns calling functionor program exits function code executed functionroutine code function doesnt execute could even return void function typing : return 
p360
aVbehavior return statement defined iso c standard quoting n1570 draft section 6864: return statement terminates execution current function returns control caller function may number return statements return statement expression executed value expression returned caller value function call expression expression type different return type function appears value converted assignment object return type function function like: int funcvoid return 42 call function even function see _recursion_: include stdioh int mainvoid int result func printfd\u005cn result function call func _expression_ yields value 42 function defined return type void doesnt return value return statement function return expression terminates execution function value returned 
p361
asS'35217413'
p362
(lp363
Vbash unset local variable inside function unset local variables end function bash script example following function: square local var1 var var var echo var unset var curious best practices thanks 
p364
aVcomment unset var end subroutine would need unset would go scope right anyway 
p365
aVwerent using local command would want unset variable leaving function avoid polluting global namespace square var1 var global could used square returns var var var echo var unset var remove global namespace problem approach square doesnt know actually _created_ var first place may overwritten ultimately unset global variable use square called using local guaranteed create _new_ variable visible inside function global var value ignored duration function function exits local var discarded global var used var3 echo var 3 square 9 81 echo var 3 
p366
asS'484277'
p367
(lp368
Vget home directory username want obtain home dir user echo echo puchuu homepuchuu cant use variable echo user puchuu echo echo user puchuu 
p369
aVuse eval: eval echo user see andrew glenn 
p370
aVmight work you: homedir getent passwd user cut d: f6 also work users instance homedir getent passwd someotheruser cut d: f6 
p371
aVseems user echo home 
p372
aVdont know helps placing tilde outside expression works zsh bash: echo echo user 
p373
aVlogin run cd go home directory run pwd print working directory 
p374
asS'3661251'
p375
(lp376
Vcompile c program might newbie question ever compile c program i\u2019ve downloaded source c program ffmpeg precise compile 
p377
aVunixstyle c programs incantation is: configure make sudo make install already documented install file additionally may contain useful information 
p378
aVdepends os compilers typically sequence is: configure make sudo make install 
p379
aVsingle file cc filec gcc whatever c compiler called complex project like ffmpeg either make cmake configure check documentation 
p380
aVcompile simple math program enough ltinclude mathhgt see gcc filec lmath o program_bin single c file using ffmpeg libraries made way: gcc wall g live_segmenterc o live_segmenter lavformat lavcodec lavutil lbz2 lm lz lfaac lmp3lame lx264 lfaad lpthread ihomedevicerffmpeginclude lhomedevicerffmpeglib notice l options serious projects usually set pkg config ffmpeg \u005c install lame required libraries chris said btw sometimes requires gmake make also look configure prefix homedevicerffmpeg mentioned used segmenter compilation 
p381
asS'211378'
p382
(lp383
Vhidden features bash shell scripts often used glue automation simple oneoff tasks favorite hidden features bash shellscripting language one feature per answer give example short description feature link documentation label feature using bold title first line see also: hidden features c hidden features c hidden features c hidden features delphi hidden features python hidden features java hidden features javascript hidden features ruby hidden features php hidden features perl hidden features vbnet 
p384
aVusing infix boolean operators consider simple if: 2 lt 3 echo numbers still good fi lt looks kinda ugly modern use double brackets around boolean expression normal boolean operators 2 3 echo numbers still good fi 
p385
aVusing arithmetic: 21 12 echo still ok fi 
p386
aVrecently read csh programming considered harmful unixfaqshellcshwhynot contained astounding gem: consider pipeline: b c want know status c well thats easy: status csh want youre luck youre csh bourne shell get although bit tricky heres something ran dds stderr grep v pipe get rid records inout noise return dds exit status greps: devicedevrmt8 dd_noise09\u005c09 records inout exec 31 statusdd ifdevice ibs64k 21 13 3 4 echo 4 egrep v dd_noise 12 3 4 41 exit status 
p387
aVspecial variable random: random 6 0 echo bang else echo try fi 
p388
aVlike x feature allowing see whats going script bash x scriptsh 
p389
aValmost everything listed expansion section manual particular parameter expansion: ifoobar echo iooaa replacement faabar echo i:1:2 substring oo echo ibar trailing substitution foo echo ifoo leading substitution bar 
p390
aVarrays: binbash array0a string array1a string spaces \u005cquotation\u005c marks array2a string spaces \u005cquotation marks\u005c parenthesis echo array elements array n array@ echo element n done details arrays advanced bash scripting stuff found advanced bashscripting guide 
p391
aVtwo favorites: check syntax wo really executing script use: bash n scriptsh go back last directory yes know pushd popd quicker cd 
p392
aVget back history commands arguments possible selectively access previous commands arguments using operator useful working long paths check last commands history use previous commands n n index command history negative numbers count backwards last command history ls l foo bar touch foo bar 2 use previous arguments :n zero command 1 arguments ls l foo touch :2 cp :1 bar combine n:m touch foo bar ls l :1 :2 rm 2:1 2:2 2 also use argument ranges n:xy touch boo far ls l :12 special modifiers are: arguments ls l foo bar ls first argument :1 last argument ls l foo bar cat devnull 
p393
aVc style numeric expressions: let xrandom28 echo n x 0b i8 i0 let n2i xn n echo n 1 else echo n 0 fi done echo 
p394
aVtruncate content file zeroing file file specifically good truncating log files file open another process still may write file 
p395
aVregular expression handling recent bash releases feature regular expression matching do: mystring regex echo match fi regex raw regular expression format described man re_format matches bracketed parts stored bash_rematch array starting element 1 element 0 matched string entirety use regexpowered parsing 
p396
aVembedded command substitution: hostname ampamp dig short hostname ampamp dig short x dig short hostname command good checking rdns mail server :p 
p397
aVinsert preceding lines final parameter alt useful key combination ever try see reason one knows one press select older last parameters great want something else something used moment ago 
p398
aVwant keep process running log out: disown h pid useful bash builtin unlike nohup run disown already running process first stop job controlz get pid ps use echo use bg send background use disown h flag dont forget background job killed logout 
p399
aVquick amp dirty correction typos especially useful long commands slow connections using command history scrolling would horrible: cat proccupinfo cat: proccupinfo: file directory cupcpu also try :soldnew substitutes old new previous command want substitute many occurrences global substitution :gsoldnew use gs commands history event eg 2:soldnew substitute old new second last command 
p400
aVone favorites sets tab completion case sensitive really great quickly typing directory paths especially mac file system case sensitive default put inputrc home folder set completionignorecase 
p401
aVrunning command displaying bash prompt set command prompt_command env variable run automatically prompt example: lsc@home export prompt_commanddate fri jun 5 15:19:18 bst 2009 lsc@home ls file_a file_b file_c fri jun 5 15:19:19 bst 2009 lsc@home ls next april fools add export prompt_commandcd someones bashrc sit back watch confusion unfold 
p402
aVseconds0 sleep 5 echo took approximately seconds seconds seconds time parameter referenced number seconds since shell invocation returned value assigned seconds value returned upon subsequent references number seconds since assignment plus value assigned seconds unset loses special properties even subsequently reset 
p403
aVusing let builtin bash command basic arithmetic a10 let ba 10 1 b101 let bb 8 b12 let floating point let brandom 6 1 b random number 1 6 floating point evaluations use bc command part bash fpecho scale4 10 3 bc fp33333 
p404
aVproperties another one favorites export histcontrolerasedups export histsize1000 first one makes sure bash doesnt log commands really improves historys usefulness expands history size 1000 default 100 actually set 10000 machines 
p405
aVctrlx ctrle load current command editor defined variable visual really useful long commands like listed use vi editor: export visualvi 
p406
aVeasily move around multiple directories hidden feature much flexible pushd requires stack like navigation alias 1cd\u005c pwd cd somewhere type 1 later typing 1 return directory 
p407
aVfavorite: sudo rerun previous command sudo 
p408
aVone use lot refer last word last command: less foobartxt dont want file rm 
p409
aV magic key combinations bash man pages: ctrl \u005c ctrl \u005c e move cursor beginning end current line respectively ctrl \u005c alt \u005c transpose character word cursor current one move cursor forward alt \u005c u alt \u005c l convert current word cursor end uppercase lowercase hint: press alt \u005c followed either commands convert _beginning_ current word bonus man tips: viewing man pages use search text within pages use n jump ahead next match n previous match speed search particular command subsection within man pages taking advantage formatting: o instead typing history expansion find section try history using caret find lines _begin_ history o try read leading spaces search builtin command builtins always indented man pages 
p410
aV magic key combinations: ctrl \u005c r begins reverse incremental search command history continue type retrieves recent command contains text enter tab completes word youve typed far unambiguous tab tab lists completions word youve typed far alt \u005c _inserts_ possible completions particularly helpful say youve entered potentially destructive command wildcards: rm r sourcedc alt \u005c rm r sourcedelete_mec sourcedo_not_delete_mec ctrl \u005c alt \u005c e performs alias history shell expansion current line words current line redisplayed processed shell: ls hometmp ctrl alt \u005c e ls n colortty 0 homecramey 
p411
aVothers mentioned ctrlr great stepping back command history want go forward youve taken one steps many thats ctrls comes handy however normally mapped xoff interrupt data flow since thats useful using slow serial terminals turn mapping with: stty ixon bashrc file also makes ctrlq available normally duplicate ctrlv quotedinsert allows insert literal control character ctrlq mapped menucomplete steps completions pressed repeatedly like leave tab set regular complete set ctrlq menucomplete adding line inputrc file: \u005ccq: menucomplete 
p412
aVbash variable indirection: foobar bazfoo echo baz bar 
p413
aValias rfcs find useful limited cases run last command type r hit enter thats course useful arrow thing use r run previous command substitutions lets say last command long command compiling file: gcc c file_namec lots options o file_nameo want compile another file options corresponding o file: r file_namenew_file dont use arrow navigate right places replace manually repeated multiple times next: r new_fileother_file course thing makefiles hope shown alias useful havent needed use alias lot times glad alias 
p414
aVexport tmout1560 terminate bash 15 minutes idle time set 0 disable usually put bashrc root accounts handy administrating boxes may forget logout walking away terminal 
p415
aVreally feature rather direction: found many hidden features secrets various bash usefulness commandlinefucom answers answers learned site : 
p416
aVset o vi order vilike editing command history well currently typed command 
p417
aV undo cs control shift minus undoes typing actions kill yank delete operation cw delete previous word ck delete end line cu delete start line etc copies deleted text kill ring paste last kill with: cy cycle paste ring deleted items alty 
p418
aVignore certain files tab completing setting th fignore variable example subverion repo want navigate easily export fignoresvn cd without blocked svn directories 
p419
aVanother small one: alt comments current line moves history buffer youre assembling command line need issue interim command eg find file hit alt issue command go history uncomment proceed 
p420
aV_here strings_ bash manual gives description: word expanded supplied command standard input example: cat 1031 nice isnt 31 nice isnt 
p421
aVprocess substitution ltcmd cmd form cmd executed input output hooked fifo path fifo substituted command line: echo file read: cat file write to: cat file read: devfd63 file write to: devfd62 example compare two website without saving intermediate files: diff curl command takes file name input doesnt accept mean stdout trick it: do_thingee log error: cant open log file: do_thingee log cat do_thingee v02 initializing things processing 4 things done 
p422
aVspecial socket filenames: devtcphostport devudphostport read daytime server port 13: cat devtcputcnistcoloradoedu13 55786 110813 03:34:21 50 0 0 1723 utcnist quite useful conjunction tcpserver ucspitcptcpserverhtml advanced example socketprogrammingwithdevtcp2 dont access wget curl: exec 3devtcpwwwgooglecom80 hook file desc 3 echo e get http11\u005cn\u005cn 3 send http request cat 3 read http response 
p423
aVbrace expansion standard expansion xyz: echo foobarbazblam foobar foobaz fooblam cp programpybak useful cp mv sequence expansion xy: echo az b c d e f g h j k l m n o p q r u v w x y z echo af03 a0 a1 a2 a3 b0 b1 b2 b3 c0 c1 c2 c3 d0 d1 d2 d3 e0 e1 e2 e3 f0 f1 f2 f3 
p424
aVquick history search following gives tcsh like history search handy easier add following lines inputrc etcinputrc cat inputrc \u005cea: historysearchbackward \u005ceb: historysearchforward may want use less accidental key combination esc \u005c p thats case use \u005cep: historysearchbackward \u005cen: historysearchforward simply type first letters press uparrow key itll show recent command start given letters ex: type grep uparrow itll show something like grep ri mytext 
p425
aVget info key combinations bash manualhowtokeycombinationsinbashhtml 
p426
aVbraces lieu done loop loop body usually dodone example: f ls f done use c style using braces: f ls f think looks better dodoneand prefer one yet found bash documentation really hidden feature 
p427
asS'1746510'
p428
(lp429
Vunable open file fopen ive trying open file output text keep getting errors thought would start beginning try opening file code: include stdioh include stdlibh define correct_parameters 3 int mainvoid file file file fopentestfile1txt r file null printferror fclosefile run file error gets printed console thats testfile1txt location exe fix 
p430
aVexecutables working directory probably set something directory saved check ide settings 
p431
aVrunning file command line ide directory executable necessarily working directory try using full path name fopen see fixes problem described example: file fopenc:\u005c\u005cmydirectory\u005c\u005ctestfile1txt r file fopenfullpathtotestfile1txt r open command window navigate directory executable run manually aside insert simple windows linuxunixbsdetc respectively: system cd systempwd fopen show directory youre actually 
p432
aVoutput folder directory must configured directory ide either change replace filename entire file path hope helps 
p433
aVlittle error checking goes long way always test value errno call perror strerror get information fopen call failed otherwise suggestions checking path probably correct likely youre directory think ide dont permissions expect 
p434
aVinstead printferror try perrorerror may print actual reason failure like permission problem invalid argument etc 
p435
aVwell know problem next step figure exactly error happens compile run this: include stdioh include stdlibh int mainvoid file file file fopentestfile1txt r file null perrorerror else fclosefile 
p436
aVaddition might interested displaying current directory: int max_path_length 80 char pathmax_path_length getcwdpath max_path_length printfcurrent directory path work without issue gccglibc platform im familiar type platform question posted isoccompliant talked getcwd amp visual studio youre windows type platform 
p437
aVtry using absolute path filename using windows use getlasterror see actual error msg 
p438
asS'24966585'
p439
(lp440
Vc header file format trying get grip proper format setting header files external functions im school h file place ifndef token define token endif pre processor calls around prototypes additional defines use within function go inside c file h adding whole package main program need add top main program include name_of_function_pkgh need reference c file within header file edit added code requested whole things works fine want write standard everyone else main file: include stdioh include utilsh defined values define false 1 define true 0 main code int main local variables int success true float fvaluefconvert float fsrcfactorfdstfactor char csourcecurrency char cdestcurrency char cnewline user input printfenter source currency: scanfcccsourcecurrencycnewline printfenter destination currency: scanfcccdestcurrencycnewline printfenter value: scanfffvalue fconvert convert csourcecurrency cdestcurrency fvalue output iffconvert 1 printfthere error input else printfc2f c2fcsourcecurrencyfvaluecdestcurrencyfconvert exit return 0 utilsh file: ifndef utils define utils float convert char csourcecurrency char cdestcurrency float fvalue endif utilsc file truncated defines h file define cdn 1 define yen 9504 define eur 069 define e2y 13769 define false 1 define true 0 float convert char csourcecurrency char cdestcurrency float fvalue function variables int success true float fconvert float fsrcfactorfdstfactor error checking csourcecurrencyy csourcecurrency csourcecurrencye success false return 1 cdestcurrencyy cdestcurrency cdestcurrencye success false return 1 
p441
aVneed understand c preprocessor working handling include directive read wikipage c preprocessor documentation gnu cpp gcc purely textual thing preprocessor replace include included file expands defined macros occur later might even avoid include copy paste code would bad habit practice put headers declarations shared single file also needed define show us code also look existing practice eg look source code free software coded c 
p442
aVnever need reference c file link files together need include header files however make sure files need folder whether want use define header file c file dependent scope youre going use defined values main define main used c files function definitions put header wary already defined 
p443
asS'41778001'
p444
(lp445
Vglobal variable argument function call c passing global variable function parameter passed reference value 
p446
aVfirst need pass global variable function directly access program dont know include stdioh int x 10 global variable void fun printfdx direct access int mainvoid fun argument required return 0 output 10 demo 
p447
aVlocal global variables passed functions value c need pass reference need use pointers 
p448
aVpassed value following code shows case: include stdioh int global 5 void fooint bar bar 6 printfbar d\u005cnglobal d bar global int main fooglobal return 0 output is: bar 6 global 5 code global passed parameter foo called parameter bar beginning global bar two different variables value 5 bar assigned value 6 since argument referenced value global stays 5 pass variable reference use pointers: include stdioh int global 5 void fooint bar bar 6 printfbar d\u005cnglobal d bar global int main fooglobal return 0 output is: bar 6 global 6 
p449
aVvariable ismust passed depends function variable: int gmyvar void fooint says call value void barint b says call reference foo requires int passed must call foogmyvar bar requires pointer int must call bargmyvar answers indicated c always passes value however value value variable call value pointer variable call reference 
p450
asS'26647152'
p451
(lp452
Vpassing vectors function value vs reference c im coding c function void foovectorint test call program vector passed value reference im unsure know vectors arrays similar function like void barint test would pass test reference pointer instead value guess would need pass vector pointerreference explicitly wanted avoid passing value im sure 
p453
aVvoid foovectorint test vector would passed value ways pass vectors depending context: 1 pass reference: let function foo change contents vector efficient pass value copying vector avoided 2 pass constreference: efficient well reliable dont want function change contents vector 
p454
aVvector functionally array language vector type int also type function argument array type including vector treated pointer vectorint int compiler vectorint nonarray nonreference non pointer passed value hence call copy constructor must use vectorint preferably const function isnt modifying pass reference 
p455
aVguess id say youre java background c things passed value unless specify otherwise using operator note operator also used addressof operator different context well documented ill reiterate anyway: void foovectorint bar value void foovectorint bar reference nonconst modifyable inside foo void foovectorint const bar constreference also choose pass pointer vector void foovectorint bar unless know youre feel really way go dont also vectors _not_ arrays internally vector keeps track array handles memory management many stl containers cant pass vector function expecting pointer array vice versa get access pointer underlying array use though vectors classes offering lot functionality memberfunctions whereas pointers arrays builtin types also vectors dynamically allocated means size may determined changed runtime whereas cstyle arrays statically allocated size constant must known compiletime limiting use suggest read c general specifically array decay look following program illustrates difference arrays pointers: void foo1int arr cout sizeofarr \u005cn void foo2int arr cout sizeofarr \u005cn void foo3int arr10 cout sizeofarr \u005cn void foo4int arr10 cout sizeofarr \u005cn int main int arr10 1 2 3 4 5 6 7 8 9 10 foo1arr foo2arr foo3arr foo4arr 
p456
asS'199661'
p457
(lp458
Vlinux shell use ive used bash csh tcsh asked question jonathan informed csh isnt trusted linux shell good development 
p459
aVusually stick bash friendly straightup sh default every distro ive used semiregularly suse rhel ubuntu slackware youre planning write portable shell scripts however make sure run _real_ sh 
p460
aVcommon shell far linux bash unless good reason use alternative id suggest sticking bash commonly used shell project team bulk shell scripts work uses common contender dash becoming widely used ubuntu project really personal preference well except csh 
p461
aVbash standard 
p462
aVdont use korn shell ksh unless perfect typing never need use backspace key 
p463
aVlike ksh actually bit consistent bash try support csh constructs tcsh experience least compatible shells avoid try write scripts sh ksh nice features like exporting setting variable one line try preserve compatibility bash well since fullfeatured common write portable shell scripts important selecting best shell might consult book portable shell programming: extensive collection bourne shell examples hp professional series bruce blinn paperback oct 29 1995 amazoncom 
p464
aVprefer zsh tabcompletion alone worth it: expands wildcards wanthandy want delete one file directory give list switches specifying program gives tab completion options line youre working pretty handy 
p465
aVuse pdksh time without anything close perfect typing perhaps need fix termcap ksh standard csh standard bash standard linux better target ksh 
p466
aVsince believe im person suggested use something c shell perhaps qualify remarks slightly support said bash linux korn shell platforms unless bash installed rather like editors prefer vim emacs choice shell partly question familiarity partly question preference many like c shell though believe less easily programmable bourne shell derivatives cshrc indeed equivalent exec binksh isnt identically want execute login shell one reads profile wouldnt condemn anyone using c shell derivative informed decision decide want use something c shell basically bourne shell camp posix standard less specifies expected behaviour different shells bourne korn born shells add case classic bourne shell subtract features code might ever need move linux hpux solaris aix surviving trio classic atamptderived unix variants consider ensuring write shell scripts classic bourne shell though korn shell also pretty safe note though linux write binsh get bash platforms get bourne shell switch korn shell bash without major problems seldom minor problems tend stay clear corners either language well defined tends mean defined another problem using linux gnu tools options classic unix versions lose portability shell programming constructs use command options use experience ready access manual pages systems helps enormously 
p467
aVinteractivity use zsh maintainer freebsd port bash tabcompletion scripts abandoned soon tried zsh first time everything bash easily elegantly also nice property extremely bashlike keystrokes youre system without zsh youll able make even wouldnt feel nice scripting use bourne shell sh posix standard scripting language scripts pretty much guaranteed work everywhere bash zsh shells nice extensions youll miss tie specific setup ignore advice personaluseonly scripts youre certain youll never run elsewhere remember real tradeoff need consider summary zsh dont know anyone whos tried didnt immediately permanently switch really good 
p468
aVproblem csh crap scripting explained real reason shouldnt use interactive shell people find confusing learn two different shells able try bits scripts command line easiest use everything obvious candidates interactive shell bash dash zsh pdksh implement posix shell standard minor extensions pick whichever like interactive use id tend go bash standard linux merits zsh particular seems popular youre writing script intend portable use binsh make sure use standard posix shell syntax works bash ksh probably standard old versions unix nonstandard binsh wouldnt bother unless know problem portability command line tools call script 
p469
aVim big ruby user 
p470
aVfish alternative shells consistent syntax nice tab completion syntax highlighting easy pickup use especially dont habits shells excellent runtime help downside erratically developed small helpful user base different shells backwards compatibility shell idioms priority many cases good lot standard shells really stupid ways things always done way dodone caseesac iffi insanity fish away worth look 
p471
aVprobably best stick bash simply widely used shell tutorials help may receive someone likely use bash however started using zsh scripts found far superior bash terms scripting 
p472
aVwriting actual scripts prefer ksh several extensions useful programming fixes one pet annoyances redirectionoddities bash preference interactive sessions matter personal preference anything else sure bournetype shell 
p473
aVcame also csh tcsh bash different time least nice cshells scripting would recommand ksh available unixes solaris hpux osf1 best unix ever time good features korn programm scripts sporadicaly would like get number return value function data put simple array need something better capabilities case regegs ever would propose perl 
p474
aVscripting try using dash get good feel portable ever use bash write shell script please explicitly declare bash scripts shebang personal console use experiment find something youre comfortable eccentric annoy sysadmin picking shell compiled source every machine care use 
p475
aVnobody mentioned debian based standard sh debian almquist shell dash fully posix compliant fast startup debianubuntu use binsh use bash interactive shell dash scripting way know scripts least posix compliant run posix shell know portability shell draw line 
p476
aVselect one: tcsh b ksh c zsh d login e bash would use login sayin 
p477
aVthink fish best syntax highlightingfor commands dont exists autofill easy learn 
p478
asS'17250480'
p479
(lp480
Vc declaring int array inside struct c ive defined struct seen would like initialize inline neither fields inside struct array _foos_ change initialization code first block works fine struct foo int bar int some_array typedef struct foo foo int tmp 11 22 33 struct foo foos 123 tmp however dont really need tmp field fact clutter code example somewhat simplified instead id like declare values _somearray_ inside declaration _foos_ cannot get right syntax though maybe field _somearray_ defined differently int tmp 11 22 33 struct foo foos 123 tmp works 222 11 22 33 doesnt compile 222 new int11 22 33 doesnt compile 222 int11 22 33 doesnt compile 222 int11 22 33 compiles wrong values array 
p481
aV int some_array some_array actually pointer array define like this: struct foo int bar int some_array3 one thing whole point typedef struct foo foo use foo instead struct foo use typedef like this: typedef struct foo int bar int some_array3 foo 
p482
aVfirst 2 ways: know arrays size dont know size first case static programming problem complicated: define array_size 3 struct foo int bar int some_arrayarray_size use syntax fill array: struct foo foo foosome_array0 12 foosome_array1 23 foosome_array2 46 dont know arrays size dynamic programming issue ask size struct foo int bar int array_size int some_array struct foo foo printfwhats arrays size scanfd fooarray_size allocate memory using stdlibh foosome_array intmallocsizeofint fooarray_size fill array syntax longer need use array free allocated memory block free foosome_array foosome_array 0 optional second typedef useful write this: typedef struct foo foo means replace struct foo words this: foo syntax this: foo foo instead struct foo foo cheers 
p483
aVanswer following code section: int tmp 11 22 33 struct foo foos 123 tmp works 222 11 22 33 doesnt compile 222 new int11 22 33 doesnt compile 222 int11 22 33 doesnt compile 222 int11 22 33 compiles wrong values array compilation issues due compatible ansi standards aggregate foos subaggregates bracketed others remove internal brackets represent array tmp would compile without fail eg struct foo foos 123 tmp works 222 112233 would compile perfectly 
p484
asS'10747810'
p485
(lp486
Vdifference typedef using c11 know c11 use using write type alias like typedefs: typedef int myint understand equivalent to: using myint int new syntax emerged effort way express template typedef: template class using mytype anothertype myallocatortype first two nontemplate examples subtle differences standard example typedefs aliasing weak way create new type new name conversions implicit names using generate new type differences 
p487
aVequivalent standard emphasis mine 7132: typedefname also introduced aliasdeclaration identifier following using keyword becomes typedefname optional attributespecifierseq following identifier appertains typedef name semantics introduced typedef specifier particular define new type shall appear typeid 
p488
aVusing syntax advantage used within templates need type abstraction also need keep template parameter possible specified future write something like template typename struct whatever template typename struct rebind typedef whatevert type make possible substitue whatever future rebindint::type variable template typename u struct bar typename rebindu::type _var_member using syntax simplifies use case template typename using my_type whatevert my_typeint variable template typename u struct baz my_typeu _var_member 
p489
aVlargely except alias declaration compatible templates whereas c style typedef 
p490
asS'1514553'
p491
(lp492
Vdeclare array python declare array python cant find reference arrays documentation 
p493
aV variable variable refers empty list course assignment declaration theres way say python variable never refer anything list since python dynamically typed default builtin python type called _list_ array ordered container arbitrary length hold heterogenous collection objects types matter freely mixed confused array module 
p494
aVhow: my_array 1 rebecca allard 15 
p495
aVdont declare anything python use recommend start something like 
p496
aVwould normally 123 actually list arrays look formal definition 
p497
aVdont actually declare things create array python: array import array intarray arrayi info see array module: possible dont want array list others answered already : 
p498
aVfollowing lennart theres also numpy implements homogeneous multidimensional arrays 
p499
aVthink meantwant list first 30 cells already filled f range30: fappend0 example could used fibonacci sequence see problem 2 project euler 
p500
aVcalculations use numpy import numpy np npones32 2d array 3 rows 2 columns filled ones b nparray123 1d array initialised using list 123 c nplinspace23100 array 100 points beteen including 2 3 printa15 elements times 15 printatb b added transpose numpy arrays saved loaded disk even compressed complex calculations large amounts elements clike fast much used scientific environments see 
p501
aVrange12 0 1 2 3 4 5 6 7 8 9 10 11 a7 6 
p502
aVpython calls lists write list literal square brackets commas: 6284968128 6 28 496 8128 
p503
aVarray strings needed array length booleans initiated true strs hibye bools true strs 
p504
aVsurprisingly complex topic python practical answer arrays represented class list see reference mix generators check usage examples: empty array arr init values contain mixed types arr 1 eels get item index negative access end array arr 1 2 3 4 5 6 arr0 1 arr1 6 get length length lenarr supports append insert arrappend8 arrinsert6 7 theoretical answer hood pythons list wrapper real array contains references items also underlying array created extra space consequences are: random access really cheap arr6653 arr0 append operation free extra space insert operation expensive check awesome table operations complexity also please see picture ive tried show important differences array array references linked list: arrays arrays everywhere 
p505
aVadd lennarts answer array may created like this: array import array float_array arrayfvalues _values_ take form tuple list nparray array: values 123 values 123 values nparray123f work array values int wrong_values arrayf123 typeerror: arrayarray object callable output still same: printfloat_array printfloat_array1 printisinstancefloat_array1float arrayf 10 20 30 20 true methods list work array well common ones pop extend append judging answers comments appears array data structure isnt popular like though way one might prefer tuple list array structure stricter rules list nparray reduce errors make debugging easier especially working numerical data attempts insertappend float int array throw typeerror: values 123 int_array arrayivalues int_arrayappendfloat1 int_arrayextendfloat1 typeerror: integer argument expected got float keeping values meant integers eg list indices array form may therefore prevent typeerror: list indices must integers float since arrays iterated similar nparray lists: int_array arrayi123 data 1122334455 sample int_array: sampleappenddatai annoyingly appending int float array cause int become float without throwing exception nparray retain data type entries instead giving error change data type fit new entries usually double str: import numpy np numpy_int_array nparray123i numpy_int_array: printtypei class numpyint32 numpy_int_array_2 npappendnumpy_int_arrayint1 still class numpyint32 numpy_float_array npappendnumpy_int_arrayfloat1 class numpyfloat64 values numpy_str_array npappendnumpy_int_array1 class numpystr_ values data 1122334455 sample numpy_int_array_2: sampleappenddatai problem typeerror two true assignment well data type specified nparray wherever possible transform entries data type: int_numpy_array nparray12float3i 3 becomes int int_numpy_array_2 nparray1239i 39 gets truncated 3 int39 invalid_array nparray12stringi valueerror: invalid literal int base 10: string error intstring str_numpy_array nparray123str printstr_numpy_array printtypei str_numpy_array 1 2 3 class numpystr_ essence: data 123456 list_1 nparraydataitolist list_2 inti data printlist_1 list_2 true array simply give: invalid_array array1239i typeerror: integer argument expected got float good idea use nparray typespecific commands array structure useful list preserves data type values something find rather pesky: data type specified first argument array usually second nparray : relation c referred here: python list vs array use use fun exploring note: typed rather strict nature array leans towards c rather python design python many typespecific constraints functions unpopularity also creates positive feedback collaborative work replacing mostly involves additional intx x file therefore entirely viable reasonable ignore existence array shouldnt hinder us way :d 
p506
aVcouple contributions suggested arrays python represented lists perhaps theoreticallyunder hood correct however major distinction two fact lists accept mixed data types mixed numeric types hand array requires typecode restricting elements determined type: list_01 4 62 72j flo cro list_01 out85: 4 62 72j flo cro possible using array 
p507
asS'10059142'
p508
(lp509
Vreading \u005cr carriage return vs \u005cn newline console getc im writing function basically waits user hit enter something ive found works testing below: include stdioh int main int x getcstdin x \u005cn printfcarriage return printf\u005cn else printfmissed printf\u005cn question tried first do: x \u005cr testing program didnt catch hitting enter \u005cn seems correspond hitting enter console someone explain difference also verify writing \u005cn would mean character string literal ie user would literally enter \u005cn console correct 
p510
aV\u005cn newline character \u005cr carriage return differ uses windows uses \u005cr\u005cn signify enter key pressed linux unix use \u005cn signify enter key pressed thus id always use \u005cn used x \u005cn proper way test character equality 
p511
aV\u005cn line feed \u005cr carriage return different operating systems handle new lines different way windows expects newline combination two characters \u005cr\u005cn linux\u005cunix modern mac os uses single \u005cn new line classic mac os uses single \u005cr new line basically would use x \u005cn currently used modern operating systems 
p512
aValso remember type 25 characters enter first getc return 25 characters typed hit enter reading character time typed requires platformspecific code consequently might better reading entire line performing fgets string trimming newline processing input line whole 
p513
aVusing gets opens buffer overflow exploits consequently possibly shell code attacks use fgets pass buffer size 
p514
asS'4627330'
p515
(lp516
Vdifference fprintf printf sprintf anyone explain simple english differences printf fprintf sprintf examples stream im really confused three reading file handling c 
p517
aVprintf equivalent fprintfstdout fprintf used output stream sprintfbuffer used format string buffer note also vsprintf vfprintf vprintf 
p518
aVprintf outputs standard output stream stdout fprintf goes file handle file sprintf goes buffer allocated char 
p519
aValso useful things vsnprintf function: cat testcc include exception include stdargh include stdioh struct exception_fmt : std::exception exception_fmtchar const fmt __attribute__ formatprintf23 char const const throw return msg_ char msg_0x800 exception_fmt::exception_fmtchar const fmt va_list ap va_startap fmt vsnprintfmsg_ sizeof msg_ fmt ap va_endap int mainint ac char av throw exception_fmts: bad number arguments d av ac g wall o test testcc test terminate called throwing instance exception_fmt what: test: bad number arguments 1 aborted core dumped 
p520
aVc stream abstraction programs perspective simply producer input stream consumer output stream bytes correspond file disk pipe terminal device printer tty file type contains information stream normally dont mess file objects contents directly pass pointer various io routines three standard streams: stdin pointer standard input stream stdout pointer standard output stream stderr pointer standard error output stream interactive session three usually refer console although redirect point files devices: myprog inputfiledat outputtxt 2 errorstxt example stdin points inputfiledat stdout points outputtxt stderr points errorstxt fprintf writes formatted text output stream specify printf equivalent writing fprintfstdout writes formatted text wherever standard output stream currently pointing sprintf writes formatted text array char opposed stream 
p521
aVfprintf related streams printf statement similar fprintf related streams fprintf file related 
p522
aVsprintf: writes formatted data character string memory instead stdout syntax sprintf is: include stdioh int sprintf char string const char format item item\u2026 string refers pointer buffer memory data written format refers pointer character string defining format item variable expression specifying data write value returned sprintf greater equal zero operation successful words number characters written counting terminating null character returned returns value less zero error occurred printf: prints stdout syntax printf is: printf format argument\u2026 difference sprintf printf sprintf writes data character array printf writes data stdout standard output device 
p523
aVprintf 1 printf used perform output screen 2 syntax printfcontrol string argument 3 associated file inputoutput fprintf 1 fprintf used perform write operation file pointed file handle 2 syntax fprintf fp control string argument 3 associated file inputoutput 
p524
aVprintfformat args used print data onto standard output often computer monitor sprintfchar format args like printf instead displaying formated string standard output ie monitor stores formated data string pointed char pointer first parameter string location difference printf sprint syntax fprintffile fp format args like printf instead displaying data monitor saving string formated data saved file pointed file pointer used first parameter fprintf file pointer addition syntax printf _stdout_ file used first parameter fprintf working considered equivalent printf 
p525
asS'346536'
p526
(lp527
Vdifference structure union c good example give difference struct union basically know struct uses memory member union uses largest members memory space os level difference 
p528
aVstructure allocates total size elements union allocates much memory largest member requires 
p529
aVunion youre supposed use one elements theyre stored spot makes useful want store something could one several types struct hand separate memory location elements used give concrete example use working scheme interpreter little ago essentially overlaying scheme data types onto c data types involved storing struct enum indicating type value union store value union foo int cant use b char b foo struct bar int use b simultaneously char b bar union foo x xa 3 ok xb c affects value xa struct bar y ya 3 ok yb c ok edit: youre wondering setting xb c changes value xa technically speaking undefined modern machines char 1 byte int 4 bytes giving xb value c also gives first byte xa value: union foo x xa 3 xb c printfi i\u005cn xa xb prints 99 99 two values last 3 bytes int 3 zero also read 99 put larger number xa youll see always case: union foo x xa 387439 xb c printfi i\u005cn xa xb prints 387427 99 get closer look actual memory values lets set print values hex: union foo x xa 0xdeadbeef xb 0x22 printfx x\u005cn xa xb prints deadbe22 22 clearly see 0x22 overwrote 0xef c order bytes int defined program overwrote 0xef 0x22 mac platforms would overwrite 0xde instead order bytes make int reversed therefore writing program never rely behavior overwriting specific data union portable reading ordering bytes check endianness 
p530
aVunion struct _constructs_ c language talking os level difference inappropriate since _compiler_ produces different code use one another keyword 
p531
aValready state question main difference union struct union members overlay memory sizeof union one struct members laid one optional padding also union large enough contain members alignment fits members lets say int stored 2 byte addresses 2 bytes wide long stored 4 byte addresses 4 bytes long following union union test int long b could sizeof 4 alignment requirement 4 union struct padding end beginning writing struct changes value member written writing member union render value members invalid cannot access havent written otherwise behavior undefined gcc provides extension actually read members union even though havent written recently operation system doesnt matter whether user program writes union structure actually issue compiler another important property union struct allow _a pointer point types members_ following valid: struct test int double b some_test_pointer some_test_pointer point int bool cast address type test int point first member actually true union thus union always right alignment use union make pointing type valid: union int double b union actually able point int double: union v union asome_int_pointer some_int_pointer 5 va 10 return some_int_pointer actually valid stated c99 standard: object shall stored value accessed lvalue expression one following types: type compatible effective type object aggregate union type includes one aforementioned types among members compiler wont optimize va 10 could affect value some_int_pointer function return 10 instead 5 
p532
aVthats basically whats point unions put location content different types _know_ type stored union often put struct type tag important really space gains yes gain bits padding thats main point anymore type safety enables kind dynamic typing: compiler knows content may different meanings precise meaning interpret runtime pointer point different types must use union otherwise code may incorrect due aliasing problems compiler says oh pointer point type optimize accesses bad things happen 
p533
aVheres short answer: struct record structure: element struct allocates new space struct like struct foobarbazquux_t int foo long bar double baz long double quux allocates least sizeofintsizeoflongsizeofdoublesizeoflong double bytes memory instance least architecture alignment constraints may force compiler pad struct hand union foobarbazquux_u int foo long bar double baz long double quux allocates one chunk memory gives four aliases sizeofunion foobarbazquux_u \u2265 maxsizeofintsizeoflongsizeofdoublesizeoflong double possibility addition alignments 
p534
aV_is good example give difference struct union_ imaginary communications protocol struct packetheader int sourceaddress int destaddress int messagetype union request char fourcc4 int requestnumber imaginary protocol sepecified based message type following location header either request number four character code short unions allow storage location represent one data type guaranteed want store one types data one time unions largely lowlevel detail based cs heritage system programming language overlapping storage locations sometimes used way sometimes use unions save memory data structure one several types saved one time general os doesnt care know structs unions simply blocks memory struct block memory stores several data objects objects dont overlap union block memory stores several data objects storage largest thus store one data objects one time 
p535
aVyes main difference struct union stated struct uses memory member union uses largest members memory space difference lies usage need memory best usage union seen processes unix make use signals like process act upon one signal time general declaration be: union sigselect signal_1 signal1 signal_2 signal2 case process make use highest memory signals use struct case memory usage sum signals makes lot difference summarize union selected know access one member time 
p536
aVunion useful couple scenarios union tool low level manipulation like writing device drivers kernel example dissecting float number using union struct bitfields float save number float later access particular parts float struct example shows union used different angles look data include stdioh union foo struct float_guts unsigned int fraction : 23 unsigned int exponent : 8 unsigned int sign : 1 fg float f void print_floatfloat f union foo ff fff f printff: d 0xx 0xx\u005cn f fffgsign fffgexponent fffgfraction int main print_float015625 return 0 take look single precision single_precision_floatingpoint_format description wikipedia used example magic number 015625 union also used implement algebraic data type multiple alternatives found example real world haskell book osullivan stewart goerzen check discriminated union functionshtml section cheers 
p537
aVunions come handy writing byte ordering function given possible structs int mainint argc char argv union short char csizeofshort un uns 0x0102 sizeofshort 2 unc0 1 unc1 2 printfbigendian\u005cn else unc0 2 unc1 1 printflittleendian\u005cn else printfunknown\u005cn else printfsizeofshort d\u005cn sizeofshort exit0 program unix network programming vol 1 stevens 
p538
aVstructure collection different data type different type data reside every one get block memory usually used union sure one variable used want fully utilization present memory get one block memory equal biggest type struct emp char x1 byte float y 4 byte e total memory get 5 byte union emp char x1 byte float y 4 byte e total memory get 4 byte 
p539
aVuses union unions used frequently specialized type conversations needed get idea usefulness union cc standard library defines function specifically designed write short integers file using fwrite incurs encurs excessive overhead simple operation however using union easily create function writes binary short integer file one byte time assume short integers 2 byte long example: includestdioh union pw short int char ch2 int putwshort int num file fp int main void file fp fp fopentesttmp wb putw1000 fp write value 1000 integer fclosefp return 0 int putwshort int num file fp pw word wordi num putcwordc0 fp return putcwordc1 fp although putw called short integer possble use putc fwrite wanted show example dominstrate union used 
p540
aVnon technically speaking means : assumption: chair memory block people variable structure : 3 people sit chair size correspondingly union : 3 people one chair sit need use chair want sit technically speaking means : mentioned program gives deep dive structure union together struct main_struct uint64 bufferaddr union uint32 data struct inner_struct uint16 length uint8 cso uint8 cmd flags data1 total main_struct size sizeofuint64 bufferaddr sizeofunit32 union 32 bit paddingdepends processor architecture 128 bits structure members get memory block contiguously union gets one memory block max size memberhere 32 bit inside union one structure liesinner_struct members get memory block total size 32 bits1688 union either inner_struct32 bit member data32 bit accessed 
p541
asS'6751749'
p542
(lp543
Vsize pointer curiosity size pointer size type pointing pointers always fixed size example int x 10 int myptr x char y char myptr2 y std::cout sizeofx \u005cn std::cout sizeofmyptr \u005cn std::cout sizeofy \u005cn std::cout sizeofmyptr2 \u005cn would output would myptr return 4 myptr return 1 would 2 pointers actually return size reason ask pointers storing memory address values respective stored addresses 
p544
aVpointers generally fixed size ex 32bit executable theyre usually 32bit exceptions like old 16bit windows distinguish 32bit pointers 16bit usually pretty safe assume theyre going uniform within given executable modern desktop oss edit: even would strongly caution making assumption _in code_ youre going write something absolutely pointers certain size youd better check function pointers different story see jens answer 
p545
aV32bit machine sizeof pointer 32 bits 4 bytes 64 bit machine 8 byte regardless data type pointing fixed size 
p546
aVsize pointer size required system hold unique memory address since pointer holds address points 
p547
aVfunction pointers different sizes 4 20 bytes x86 machine depending compiler answer sizes vary another example: take 8051 program three memory ranges thus three different pointer sizes 8 bit 16bit 24bit depending target located even though targets size always eg char 
p548
aVanswer question size pointer size points related good analogy consider like postal addresses size address house relationship size house 
p549
aVpointers always size architecture read concept near far huge pointers example case pointer sizes differ 
p550
aVdifferent wordaddressable machines eg cray pvp systems computers today byteaddressable machines address refers byte memory data pointers usually size namely size machine address wordadressable machines machine address refers instead word larger byte char void pointer byte memory contain word address plus byte offset within addresed word 
p551
asS'15151377'
p552
(lp553
Vexactly c pointer memory address reputable source c following information given discussing operator: bit unfortunate terminology _address of_ remains confuses dont know addresses misleads do: thinking pointers addresses usually leads grief materials read equally reputable sources would say always unabashedly referred pointers operator giving memory addresses would love keep searching actuality matter kind difficult reputable sources kind disagree slightly confusedwhat _exactly_ pointer memory address ps author later says: _i continue use term address though invent different one_ term _would even worse_ 
p554
aVpointer variable type natively available cc contains memory address like variable address takes memory amount platform specific one problem see result confusion trying change referent within function simply passing pointer value make copy pointer function scope changes new pointer points change referent pointer scope invoked function order modify actual pointer within function one would normally pass pointer pointer 
p555
aVpointer another variable used hold address memory location usually memory address another variable 
p556
aVpointer variable holds memory address address however dereference pointer get access memory location example: int q 10 say q address 0x10203040 int p q means let p contain address q 0x10203040 p 20 set whatever address pointed p 20 thats simple enter image description program demonstrate saying output here: program: include stdioh int mainint argc char argv pointer address int q 10 int p q printfaddress q p\u005cn void q printfp contains p\u005cn void p p null printfnull p contains p\u005cn void p return 0 
p557
aVright sane normally pointer address cast integer arithmetics sometimes pointers part address architectures pointer converted address addition base another cpu days pc arm architecture flat memory model c language natively compiled ok think pointer integer address place one dimensional addressable ram 
p558
aVim sure source type language youre describing comes c standard: 6532 address indirection operators 3\u005c unary amp operator yields address operand yeah pointers point memory addresses least thats c standard suggests mean say bit clearly pointer variable holding _value_ _address_ address object may stored pointer returned unary operator store address 42 wallaby way sydney variable variable would pointer sorts since thats memory address something wed properly call pointer computer addresses buckets memory pointers store value address ie pointer stores value 42 wallaby way sydney address edit: want expand alexey frunzes comment _what exactly pointer_ lets look c standard: 625 types 20\u005c _pointer type_ may derived function type object type called _referenced type_ pointer type describes object whose value provides reference entity referenced type pointer type derived referenced type sometimes called \u2018\u2018pointer t\u2019\u2019 construction pointer type referenced type called \u2018\u2018pointer type derivation\u2019\u2019 pointer type complete object type essentially pointers store value provides reference object function kind pointers intended store value provides reference object function thats _always_ case: 6323 pointers 5\u005c integer may converted pointer type except previously specified result implementationdefined might correctly aligned might point entity referenced type might trap representation quote says turn integer pointer stuff integer value pointer instead specific reference object function pointer might point entity reference type ie may provide reference object function might provide us something else one place might stick kind handle id pointer ie pointer isnt pointing object storing value represents something value may address yes alexey frunze says possible pointer isnt storing address object function possible pointer instead storing kind handle id assigning arbitrary integer value pointer handle id represents depends systemenvironmentcontext long systemimplementation make sense value youre good shape depends specific value specific systemimplemenation _normally_ pointer stores address object function isnt storing actual address object function result implementation defined meaning exactly happens pointer represents depends system implementation might handle id particular system using codevalue another system might crash program ended longer thought would 
p559
aVc standard define pointer internally works internally intentional limit number platforms c implemented compiled interpreted language pointer value kind id handle combination several ids say x86 segments offsets necessarily real memory address id could anything even fixedsize text string nonaddress representations may especially useful c interpreter 
p560
aVsee way pointer value represents address addressable memory space 
p561
aVpointer another variable contain memory address usually another variable pointer variable memory address 
p562
aVdifficult tell exactly authors books mean exactly whether pointer contains address depends define address define pointer judging answers written people assume 1 address must integer 2 pointer doesnt need virtual said specification assumptions clearly pointers necessarily contain addresses however see 2 probably true 1 probably doesnt true make fact amp called _address of_ operator per @cornstalkss answer mean authors specification intend pointer contain address say pointer contains address address doesnt integer maybe think jibberish pedantic semantic talk totally worthless practically speaking think compiler generates code way value pointer address thats thought think author book first excerpt claims pointers necessarily addresses probably referring fact pointer comes inherent type information example int x int y x char z x y z pointers y1 z1 different memory addresses wouldnt expressions give value lies thinking pointers addresses usually leads grief bugs written people think _about pointers addresses_ _usually leads grief_ 55555 probably pointer although may address int55555 pointer 555551 55556 int555551 55559 difference terms sizeofint 
p563
aVpointer vs variable picture pointer_p pointer located 0x12345 pointing variable variable_v 0x34567 
p564
aVsays confuses dont know addresses also true: learn addresses youll confused theoretically pointer variable points another practically holds address address variable points dont know _hide_ fact rocket science understand pointers youll one step closer understand computers work go ahead 
p565
aVthink pointer address approximation like approximations good enough useful sometimes also exact means relying causes trouble pointer like address indicates find object one immediate limitation analogy pointers actually contain address null pointer address content pointer variable fact one three kinds: address object dereferenced p contains address x expression p value x null pointer null example invalid content doesnt point object p doesnt hold valid value p could anything \u201cundefined behavior\u201d crashing program fairly common possibility furthermore would accurate say pointer valid nonnull _contains_ address: pointer indicates find object information tied particular pointer type platforms type pointer influence runtime influence goes beyond type compile time p pointer int int p p 1 points integer sizeofint bytes p assuming p 1 still valid pointer q pointer char points address p char q p q 1 address p 1 think pointer addresses intuitive \u201cnext address\u201d different different pointers location possible environments multiple pointer values different representations different bit patterns memory point location memory think different pointers holding address different addresses location \u2014 metaphor isnt clear case operator always tells whether two operands pointing location environments p q even though p q different bit patterns even environments pointers carry information beyond address type permission information easily go life programmer without encountering environments different kinds pointers different representations think different kinds addresses different representations example architectures byte pointers word pointers object pointers function pointers thinking pointers addresses isnt bad long keep mind valid nonnull pointers addresses multiple addresses location cant arithmetic addresses theres order pointer also carries type information going way round far troublesome everything looks like address pointer somewhere deep pointer represented bit pattern read integer say integer address going way every integer pointer first wellknown limitations example integer designates location outside programs address space cant valid pointer misaligned address doesnt make valid pointer data type requires alignment example platform int requires 4byte alignment 0x7654321 cannot valid int value however goes well beyond make pointer integer youre world trouble big part trouble optimizing compilers far better microoptimization programmers expect mental model program works deeply wrong pointers address doesnt mean equivalent example consider following snippet: unsigned int x 0 unsigned short p unsigned shortx p0 1 printfu u\u005cn x p might expect runofthemill machine sizeofint4 sizeofshort2 either prints 1 1 littleendian 65536 1 bigendian 64bit linux pc gcc 44: c99 o2 wall ac aout ac: function \u2018main\u2019: ac:6: warning: dereferencing pointer \u2018p\u2019 break strictaliasing rules ac:5: note: initialized 0 1 gcc kind enough warn us whats going wrong simple example \u2014 complex examples compiler might notice since p different type x changing p points cannot affect x points outside welldefined exceptions therefore compiler liberty keep value x register update register p changes program dereferences two pointers address obtains two different values moral example thinking nonnull valid pointer address fine long stay within precise rules c language flip side coin rules c language intricate difficult get intuitive feeling unless know happens hood happens hood tie pointers addresses somewhat loose support \u201cexotic\u201d processor architectures support optimizing compilers think pointers addresses first step understanding dont follow intuition far 
p566
aVwell pointer abstraction representing memory location note quote doesnt say thinking pointers memory addresses wrong says usually leads grief words leads incorrect expectations likely source grief certainly pointer arithmetic actually one cs strengths pointer address youd expect pointer arithmetic address arithmetic example adding 10 address give address larger 10 addressing units adding 10 pointer increments 10 times size kind object points even actual size rounded alignment boundary int ordinary architecture 32bit integers adding 10 would increment 40 addressing units bytes experienced c programmers aware live author evidently fan sloppy metaphors theres additional question contents pointer _represent_ memory location: many answers explained address always int long architectures address segment plus offset pointer might even contain offset current segment near pointer unique memory address pointer contents might indirect relationship memory address hardware understands author quote cited doesnt even mention representation think conceptual equivalence rather representation mind 
p567
aVunderstanding pointers need understand objects objects entities exist location specifier called address pointer variable like variables c type called pointer whose content interpreted address object supports following operation : variable type integer usually called offset added yield new pointer : variable type integer usually called offset subtracted yield new pointer : variable type pointer subtracted yield integer usually called offset : dereferencing retrieve value variable called address map object address refers : 1 : 1 pointer classified based type object currently referring part information matters size object object supports operation address retrieves location specifier address object pointer object type abate confusion surrounding nomenclature would make sense call operation object rather pointer whose resultant type pointer object type note throughout explanation left concept memory 
p568
aVcome think think matter semantics dont think author right since c standard refers pointer holding address referenced object others already mentioned however addressmemory address address really anything per c standard although eventually lead memory address pointer id offset selector x86 really anything long describe mapping _any_ memory address addressable space 
p569
aVc pointer similar memory address machinedependent details abstracted away well features found lower level instruction set example c pointer relatively richly typed increment pointer array structures nicely jumps one structure pointers subject conversion rules provide compile time type checking special null pointer value portable source code level whose representation may differ assign integer constant whose value zero pointer pointer takes null pointer value ditto initialize pointer way pointer used boolean variable: tests true null false null machine language null pointer funny address like 0xffffffff may explicit tests value c hides even null pointer 0xffffffff test using ptr 0 null uses pointers subvert type system lead undefined behavior whereas similar code machine language might well defined assemblers assemble instructions written c compilers optimize based assumption havent done anything wrong float p pointer points long n variable p 00 executed compiler required handle subsequent use n necessary read bit pattern float value perhaps optimized access based strict aliasing assumption n touched assumption program well behaved p pointing n c pointers code pointers data different many architectures addresses c compilers developed fat pointers even though target architecture fat pointers means pointers machine addresses contain info information size object pointed bounds checking portably written programs easily port compilers see many semantic differences machine addresses c pointers 
p570
aVheres ive explained confused people past: pointer two attributes affect behavior _value_ typical environments memory address _type_ tells type size object points example given: union int char c u three different pointers pointing object: void v u int ui char c uc compare values pointers theyre equal: vi ic however increment pointer youll see _type_ point becomes relevant c cant perform arithmetic void pointer v c variables c different values point causes contain address nextaccessible integer c causes c point nextaddressable character typically integers take memory characters end larger value c incremented 
p571
aVpointer like variable c fundamentally collection bits may represented one concatenated unsigned char values type cariable sizeofsome_variable indicate number unsigned char values makes pointer different variables c compiler interpret bits pointer identifying somehow place variable may stored c unlike languages possible request space multiple variables convert pointer value set pointer variable within set many compilers implement pointers using bits store actual machine addresses possible implementation implementation could keep one arraynot accessible user codelisting hardware address allocated size memory objects sets variables program using pointer contain index array along offset index design would allow system restrict code operating upon memory owned also ensure pointer one memory item could accidentally converted pointer another memory item system uses hardware addresses foo bar arrays 10 items stored consecutively memory pointer eleventh item foo might instead point first item bar system pointer object id offset system could trap code tried index pointer foo beyond allocated range would also possible system eliminate memoryfragmentation problems since physical addresses associated pointers could moved around note pointers somewhat abstract theyre quite abstract enough allow fullystandardscompliant c compiler implement garbage collector c compiler specifies every variable including pointers represented sequence unsigned char values given variable one decompose sequence numbers later convert sequence numbers back variable original type consequently would possible program calloc storage receiving pointer store something decompose pointer series bytes display screen erase reference program accepted numbers keyboard reconstituted pointer tried read data pointer user entered numbers program earlier displayed program would required output data stored calloced memory since conceivable way computer could know whether user made copy numbers displayed would conceivable may computer could know whether aforementioned memory might ever accessed future 
p572
aVmark bessey already said needs reemphasised understood pointer much variable literal 3 pointer _is_ tuple value address type additional properties read type additional parameters define restrict context eg __far ptr __near ptr : context address: stack heap linear address offset somewhere physical memory property _type_ makes pointer arithmetic bit different integer arithmetic counter examples pointer variable many ignore fopen returning file pointer wheres variable stack pointer frame pointer typically unaddressable registers int 0x1231330 13 \u005c casting arbitrary integer value pointer_of_integer type writingreading integer without ever introducing variable lifetime cprogram many instances temporary pointers addresses therefore variables expressionsvalues compile time associated type 
p573
aVbrief summary also put top: 0 thinking pointers addresses often good learning tool often actual implementation pointers ordinary data types 1 many perhaps compilers pointers functions addresses bigger address typically 2x sometimes actually pointers struct memory contains addresses function stuff like constant pool 2 pointers data members pointers methods often even stranger 3 legacy x86 code far near pointer issues 4 several examples notably ibm as400 secure fat pointers sure find detail: ummpphhh many answers far fairly typical programmer weenie answers compiler weenie hardware weenie since pretend hardware weenie often work compiler weenies let throw two cents: many probably c compilers pointer data type fact address fine even many compilers certain pointers addresses tell looking sizeofthepointer example pointers functions sometimes quite lot bigger ordinary addresses may involve level indirection article functionshtml provides one description involving intel itanium processor seen others typically call function must know address function code also address functions constant pool region memory constants loaded single load instruction rather compiler generate 64 bit constant several load immediate shift instructions rather single 64 bit address need 2 64 bit addresses abis application binary interfaces move around 128 bits whereas others use level indirection function pointer actually address function descriptor contains 2 actual addresses mentioned better depends point view: performance code size compatibility issues often code assumes pointer cast long long long may also assume long long exactly 64 bits code may standards compliant nevertheless customers may want work many us painful memories old intel x86 segmented architecture near pointers far pointers thankfully nearly extinct quick summary: 16 bit real mode actual linear address linearaddress segmentregistersegnumbase 4 offset whereas protected mode might linearaddress segmentregistersegnumbase offset resulting address checked limit set segment programs used really standard cc far near pointer declarations many said \u005c compiler linker switches example code pointers might near pointers 32 bit offset whatever cs code segment register data pointers might far pointers specifying 16 bit segment number 32 bit offset 48 bit value quantities certainly related address since arent size address moreover segments also carried permissions readonly readwrite executable addition stuff related actual address interesting example imho perhaps ibm as400 family computer one first implement os c pointers machime typically 2x actual address size eg presentation says 128 bit pointers actual addresses 4864 bits extra info called capability provided permissions read write well limit prevent buffer overflow yes: compatibly cc ubiquitous chinese pla slavic mafia would hacking many western computer systems historically cc programming neglected security performance interestingly as400 family allowed operating system create secure pointers could given unprivileged code unprivileged code could forge tamper security standards compliant much sloppy nonstandards compliant cc code work secure system official standards defacto standards ill get security soapbox mention ways pointers various types often really addresses: pointers data members pointers member functions methods static versions thereof bigger ordinary address post many ways solving problems related single versus multiple inheitance virtual inheritance heres visual studio compiler decides handle it: pointer member function multiply inherited class really structure go say casting function pointer change size probably guess pontificating insecurity ive involved cc hardwaresoftware projects pointer treated like capability raw address could go hope get idea brief summary also put top: 0 thinking pointers addresses often good learning tool often actual implementation pointers ordinary data types 1 many perhaps compilers pointers functions addresses bigger address typically 2x sometimes actually pointers struct memory contains addresses function stuff like constant pool 2 pointers data members pointers methods often even stranger 3 legacy x86 code far near pointer issues 4 several examples notably ibm as400 secure fat pointers sure find 
p574
aVone way c c pointer differs simple memory address due different pointer types havent seen answers altrhough given total size may overlooked probably important one even experienced cc programmers trip it: compiler may assume pointers incompatible types point address even clearly may give behaviour would possible simple pointeraddress model consider following code assuming sizeofint 2sizeofshort: unsigned int 0 unsigned short p unsigned shorti p0p11 2 unsigned short1 youd expect execute need 0 youd expect execute actually may note theres exception char manipulating values using char possible although portable 
p575
aVquick summary: c address value typically represented machine level memory address specific type unqualified word pointer ambiguous c pointer _objects_ variables pointer _types_ pointer _expressions_ pointer _values_ common use word pointer mean pointer object lead confusion try use pointer adjective rather noun c standard least cases uses word pointer mean pointer value example description malloc says returns either null pointer pointer allocated space whats address c pointer value ie value particular pointer type except null pointer value necessarily referred address since isnt address anything standards description unary operator says yields address operand outside c standard word address commonly used refer physical virtual memory address typically one word size whatever word given system c address typically implemented machine address c int value typically implemented machine word c address pointer value machine address value typically _represented_ machine address value specific _type_ 
p576
aVpointer value _is_ address pointer variable _is_ object store address true thats standard defines pointer important tell c novices c novices often unclear difference pointer thing points say dont know difference envelope building notion address every object address thats pointer stores important sorts however standard talks particular level abstraction people author talks know addresses new c must necessarily learned addresses different level abstraction perhaps programming assembly language guarantee c implementation uses representation addresses cpus opcodes use referred store address passage people already know goes talk perfectly reasonable address manipulation far c standard concerned theres basically thing perfectly reasonable address manipulation addition defined pointers basically sure convert pointer integer bitwise arithmetic ops convert back guaranteed work standard writing code youd better know particular c implementation represents pointers performs conversion _probably_ uses address representation expect doesnt thats fault didnt read manual thats confusion incorrect programming procedure short c uses abstract concept address author authors concept address course also lowestlevel word matter virtual memory maps physical ram addressing across multiple chips number tell cpu store address want access basically nothing data want actually located hardware layers indirection representation author chosen one privilege youre going talking c _choose c level privilege_ personally dont think authors remarks helpful except context introducing c assembly programmers certainly helpful coming higher level languages say pointer values arent addresses would far better acknowledge complexity say cpu monopoly saying address thus c pointer values addresses addresses may written different language addresses means distinguishing two things context c address store address would adequate think 
p577
aVaddress used identify piece fixedsize storage usually bytes integer precisely called _byte address_ also used iso c methods construct address eg bit however byte address often used usually omit byte technically address never value c definition term value iso c is: precise meaning contents object interpreted specific type emphasized however address type c pointer pointer kind _type_ c language several distinct pointer types necessarily obey identical set rules language eg effect value type int vs char value c pointer type called _pointer value_ clear pointer value pointer c language accustomed mix together c likely ambiguous: call expression p pointer merely pointer value type since named type c expressed _expression_ _typename_ _typedefname_ things subtle c user firstly one know object means: region data storage execution environment contents represent values object entity represent values specific type pointer _object type_ declare int p p means object pointer type pointer object note variable normatively defined standard fact never used noun iso c normative text however informally call object variable language still exactly eg c variable _reference_ type normatively object phrases pointer object pointer variable sometimes treated like pointer value probable slight difference one set examples array since pointer type address effectively typeless c pointer value roughly contains address expression pointer type _yield_ address eg iso c11 6523 3 unary operator yields address operand note wording introduced wg14n1256 ie iso c99:tc3 c99 3 unary operator returns address operand reflects committees opinion: address pointer value returned unary operator despite wording still mess even standards iso c11 66 9 _address constant_ null pointer pointer lvalue designating object static storage duration pointer function designator iso c11 519 3 _address constant expression_ prvalue core constant expression pointer type evaluates address object static storage duration address function null pointer value prvalue core constant expression type std::nullptr_t recent c standard draft uses another wording problem actually address constant c address constant expression c constant expression pointer types least pointerlike types since c11 builtin unary operator called addressof c c similarily std::addressof introduced c11 naming may bring misconception resulted expression pointer type theyd interpreted as: result containsyields address rather _is_ address 
p578
aVsimply say pointers actually offset part segmentation mechanism translate linear address segmentation physical address paging physical addresses actually addressed ram selector segmentation paging offset mechanism mechanism virtual linear physical 
p579
asS'3137671'
p580
(lp581
Vdeclaring initializing arrays c way declare first initialize array c far initializing array like this: int myarraysize 1234 need something like int myarraysize myarray 1234 
p582
aVcant initialize declare c compiler using support c99 support c99 declare variable need initialize declare excuse think would need declare early exit using initializer would wasted however suspect code cleanly organized could written problem 
p583
aVc99 using compound literal combination memcpy memcpymyarray int 1 2 3 4 sizeof myarray assuming size source size target c8990 emulate declaring additional source array const int sourcesize 1 2 3 4 maybe static int myarraysize memcpymyarray source sizeof myarray 
p584
aV way declare first initialize array c using method described cant initialize comma separated list allowed declaration however initialize myarray0 1 myarray1 2 forint 1 size myarrayi1 
p585
aVcant set arbitrary values one statement unless done part declaration either code something like: myarray0 1 myarray1 2 myarray2 27 : myarray99 7 theres formula: int 0 100 myarrayi 1 possibility keep around templates _are_ set declaration time use initialise array something like: static const int oncearr 0 1 2 3 4 99 static const int twicearr 0 2 4 6 8198 : int myarray7 : memcpy myarray twicearr sizeof myarray advantage likely faster allows create smaller arrays templates ive used method situations reinitialise array fast specific state state zeros would use memset even localise initialisation function: void initmyarray int arr size_t sz static const int template 2 3 5 7 11 13 17 19 21 9973 memcpy arr template sz : int myarray100 initmyarray myarray sizeofmyarray static array almost certainly created compile time runtime cost memcpy blindingly fast likely faster 1229 assignment statements definitely less typing part : 
p586
aVparticular way initialize array declaring three options only: 1 initialize different lines : int arraysize array0 1 array1 2 array2 3 array3 4 thats want guess 2 initialize using loop: 0 max arrayi best way way achieve goal 3 case requirement initialize array one line define atleast array initialization copy destination array think benefit case define initialize array one line ask specifically want 
p587
aVaddendum accepted answer andreyt nyans comment mismatched array sizes disagree automatic setting fifth element zero likely _5_ \u005cthe number 1234 would suggest wrapper memcpy produce _compiletime_ error try copy arrays different sizes: define memcpyab copy arrays \u005c assertsizeofa sizeofb static assert \u005c sizeofa sizeofa 0 pointers \u005c memcpya b sizeof b unnecesary \u005c 0 return value macro generate compiletime error array length 1 perhaps feature using macro c99 compound literal seems need extra pair parentheses: memcpymyarray int 1 2 3 4 assert static assert dont already use following number platforms: define concat_tokensa b b define expand_then_concatab concat_tokensa b define asserte enum expand_then_concatassert_line___line__ 1e define assertmem version assert message \u005c enumexpand_then_concatm_assert_line___line__1e 
p588
aVinitialization braceenclosed lists array initialized braceenclosed list initializers first initializer list initializes array element index zero unless designator specified since c99 subsequent initializers without designator since c99initializes array element index one greater one initialized previous initializer int x 123 x type int3 holds 123 int y5 123 y type int5 holds 12300 int z3 0 z type int3 holds zeroes error provide initializers elements initializing array known size except initializing character arrays string literals designator causes following initializer initialize array element described designator initialization continues forward order beginning next element one described designator int n5 4501234 holds 12345 int amax starts initializing a0 1 a1 3 1 3 5 7 9 max5 8 6 4 2 0 max6 array holds 186420 max13 array holds 1357900086420 sparse array since c99 initializing array unknown size largest subscript initializer specified determines size array declared nested arrays elements array arrays structs unions corresponding initializers braceenclosed list initializers initializers valid members except braces may omitted follows: nested initializer begins opening brace entire nested initializer closing brace initializes corresponding array element: int y43 array 4 arrays 3 ints 4x3 matrix 1 row 0 initialized 1 0 0 0 1 row 1 initialized 0 1 0 21 row 2 initialized 0 0 1 row 3 initialized 0 0 0 nested initializer begin opening brace enough initializers list taken account elements members subarray struct union remaining initializers left initialize next array element: int y43 array 4 arrays 3 ints 4x2 matrix 1 3 5 2 4 6 3 5 7 row 0 initialized 1 3 5 row 1 initialized 2 4 6 row 2 initialized 3 5 7 row 3 initialized 0 0 0 struct int a3 b w 1 2 array structs 1 taken fullybraced initializer element 0 array element initialized 1 0 0 0 2 taken first initialized element 1 array element initialized 2 0 0 0 array designators may nested bracketed constant expression nested arrays follows bracketed constant expression outer array: int y43 001 111 201 row 0 initialized 1 0 0 row 1 initialized 0 1 0 row 2 initialized 1 0 0 row 3 initialized 0 0 0 
p589
aVop left crucial information question put comment answer need initialize declaring different depending condition mean something like int myarraysize ifcondition1 myarrayx1 x2 x3 else ifcondition2 myarrayy1 y2 y3 mind possible arrays need stored data somewhere anyhow memcpy needed desired pointer 2d array required static global since compilers build arrays instruction data notably const though later modified needed define size 8 static int myarrays2size 0123456776543210 static inline int init_myarray_bool conditional return myarraysconditional use: int myarray init_myarray1 htons1 boolean expression notinlined version gives resulting assembly x86_64: init_myarraybool: movzx eax dil sal rax 5 add rax offset flat:myarrays ret myarrays: long 0 long 1 long 2 long 3 long 4 long 5 long 6 long 7 long 7 long 6 long 5 long 4 long 3 long 2 long 1 long 0 additional conditionalsarrays change 2 myarrays desired number use similar logic get pointer right array 
p590
asS'1073358'
p591
(lp592
Vfunction pointers java may something common trivial seem trouble finding concrete answer c concept delegates relates strongly idea function pointers c similar functionality java given pointers somewhat absent best way clear talking first class 
p593
aVfunctions first class objects java thing implementing handler class callbacks implemented swing etc however proposals closures official name youre talking future versions java javaworld interesting article 
p594
aVsubstitue function pointer interface lets say want run collection something element public interface ifunction public void executeobject o interface could pass say collectionutils2dofunccollection c ifunction f public static void dofunccollection c ifunction f object o : c fexecuteo example say collection numbers would like add 1 every element collectionutils2dofunclist numbers new ifunction public void executeobject o integer anint integer o anint 
p595
aVjava idiom functionpointerlike functionality anonymous class implementing interface eg collectionssortlist new comparatormyclass public int comparemyclass myclass b compare objects update: necessary java versions prior java 8 much nicer alternatives namely lambdas: listsorta b aisgreaterthanb method references: listsortmyclass::isgreaterthan 
p596
aVthing java need wrap function object pass reference object order pass reference method object syntactically eased certain extent using anonymous classes defined inplace anonymous classes defined member variables class example: class mycomponent extends jpanel private jbutton button public mycomponent button new jbuttonclick buttonaddactionlistenerbuttonaction addbutton private actionlistener buttonaction new actionlistener public void actionperformedactionevent e handle event note handler instance access members surrounding class buttonsettextyou clicked 
p597
aVachieve similar functionality could use anonymous inner classes define interface foo: interface foo object myfuncobject arg create method bar receive function pointer argument: public void barfoo foo object object foomyfuncargvalue finally call method follows: barnew foo public object myfuncobject arg function code 
p598
aVbrings mind steve yegges execution kingdom nounshttp :steveyeggeblogspotcom200603executioninkingdomofnounshtml basically states java needs object every action therefore verbonly entities like function pointers 
p599
aVcheck closures implemented lambdaj library actually behavior similar c delegates: 
p600
aVimplemented callbackdelegate support java using reflection details working source available website works principle class named callback nested class named withparms api needs callback take callback object parameter neccessary create callbackwithparms method variable since great many applications object recursive works cleanly performance still high priority didnt want required create throwaway object array hold parameters every invocation large data structure could thousands elements message processing scenario could end processing thousands data structures second order threadsafe parameter array needs exist uniquely invocation api method efficiency one used every invocation callback needed second object would cheap create order bind callback parameter array invocation scenarios invoker would already parameter array reasons two reasons parameter array belong callback object also choice invocation passing parameters array individual objects belongs hands api using callback enabling use whichever invocation best suited inner workings withparms nested class optional serves two purposes contains parameter object array needed callback invocations provides 10 overloaded invoke methods 1 10 parameters load parameter array invoke callback target 
p601
aVuse reflection pass parameter object method name string invoke method example: object methodcallerobject theobject string methodname return theobjectgetclassgetmethodmethodnameinvoketheobject catch exceptions use in: string thedescription methodcallerobject1 tostring class theclass methodcallerobject2 getclass course check exceptions add needed casts sorry bad english bye 
p602
aVrelative people new java since havent seen similar suggestion another alternative suggest im sure good practice even suggested didnt get like since think self descriptive merge functions common name public class customfunction public customfunction actual functions public class function1 extends customfunction public function1 public void executesomething public class function2 extends customfunction public function2 public void executesomething main class customfunction functionpointer null depending application assign functionpointer new function1 functionpointer new function2 etc call functionpointerexecute 
p603
aVjava8 introduced lambdas method references function matches functional interface create use method reference case java provides set common functional interfaces packagesummaryhtml whereas could following: public class test public void test1integer public void test2integer public void consumerconsumerinteger aaccept10 public void provideconsumer consumerthis::test1 method reference consumerx test2x lambda 
p604
asS'17397677'
p605
(lp606
Vextern multiple files possible double definition running following codes compiled together as: gcc ac bc o combined program a: includestdioh int a1 int b int main extern int ab fun printfd d\u005cnab program b: int int b2 int fun printfd d\u005cnab return 0 running combined program output was: 1 2 1 2 ive doubts one: 1 isnt output: 0 2 1 0 2 arent b defined twice please explain clearly ive lot problems understanding extern doubts keep coming time time thanks advance 
p607
aVfar know: output 1 2 1 2 defining b external variables main functionso try take value files also far 2nd question think compiler taking initialized values variable merging b defined global variable file case different defined inside function suggestion inputs 
p608
aVvariables arent defined twice declared twice though functions take values definition variables declaration variables declaration introduces identifier describes typethrough declaration assure complier variable function defined somewhere else program provided time linking example declaration is: extern int definition actually instantiatesimplements identifier definition : int a5 int read link reference wonderful thedifferencebetweenadefinitionandadeclaration post stackoverflow extern tells compiler variable defined outside looks outside function finds: int a1 program int b2 program b auto variables : int aboth definition declaration knowledge storage classes follow link int outside main function declaration ie global inside function called definition 
p609
aVvariable may declared many times long declarations consistent definition may declared many modules including module defined even many times module external variable may also declared inside function case extern keyword must used otherwise compiler consider definition local variable different scope lifetime initial value declaration visible inside function instead throughout functions module let repeat definition extern says external variable variable defined outside function blockplease read carefully word given bold programe definition b declaration extern look definition b given programe bso print programe 1 2now lets talk programe b declaration definition b priting value programe value b current file 
p610
aVanswering question long time although statement: int b decalaration int b 2 definition correct reason everyone giving clear int b 2 int b definition difference difference lies way linker handles multiple symbol definitions concept weak strong symbols assembler encodes information implicitly symbol table relocatable object file functions initialized global variables get strong symbols uninitialized global variables get weak symbols program int 1 strong symbol int b weak symbol similarly program b int b 2 strong symbol int weak given notion strong weak symbols unix linkers use following rules dealing multiply defined symbols: 1 multiple strong symbols allowed 2 given strong symbol multiple weak symbols choose strong symbol 3 given multiple weak symbols choose weak symbols argue happening case 1 among int b 2 int b former strong symbol latter weak b defined value 2 2 among int 1 int defined 1 reasoning hence output 1 2 
p611
asS'218174'
p612
(lp613
Vshow host name linux commandline prompt several vms right commandline prompt looks like bash32 identical every vm doesnt contain host name need always see vm im using hostname operation add host name shell prompt env: centosssh 
p614
aVchange value ps1 environment variable: ps1\u005ch \u005ch replaced hostname add etcbashbashrc set permanent 
p615
aVlook bashrc profile may commented prompt setup want like one infra: export ps1\u005ch:\u005cw\u005c looks like: coolservername: plan logging nonroot use: export ps1\u005cu@\u005ch:\u005cw\u005c add username hostname fun adding colours multiline whatever info want prompt quick search bash prompts give plenty hints 
p616
aVwell changing prompt option configuration konsole gnome terminal emulator change title bar tab title 
p617
aVlike shell prompt shows username hostname name working directory addition like shown colors usually put export ps1\u005c\u005c033032m\u005c\u005cu@\u005ch:\u005c\u005c03336m\u005c\u005cw\u005c\u005c0330m\u005c \u005c bashrc order apply changes immediately call bahsrc also switch root using su good see bash prompt different color exercise extra caution add line export ps1\u005c\u005c033031m\u005c\u005cu@\u005ch:\u005c\u005c03336m\u005c\u005cw\u005c\u005c0330m\u005c \u005c rootbashrc call rootbahsrc apply changes looks like enter image description often vps server admins provide dumb hostnames order change open etcsysconfignetwork change line hostnameput_what_you_want_to_see_in_bash_prompt_here want different colors username@host part change 032m part first example 031m part second example list available colors found howtox329html since bashrc executed nonlogin shells forget check f bashrc bashrc fi present bash_profile since bash_profile executed login also add piece rootbash_profile 
p618
asS'32315533'
p619
(lp620
Vfirst c program know happening program build easily problem start without debugging blank command prompt appears cursor nothing happens kindly help regard program include bitset include iostream using namespace std int main int number_of_words 0 string previous string current cin current number_of_words previous current cout word numbernumber_of_words repeated word: current n previous current return 0 
p621
aVwaiting enter value current 
p622
aVfirst start printing command line enter string 2 times row btw: want print new line use backslash \u005cn 
p623
aVper program logic wait enter current value better way add cout enter current endl loop 
p624
asS'6372751'
p625
(lp626
Vdifference various shell profiles whats difference bashrc bash_login bash_logout bash_profile profile etcprofile etcbashbashrc etcsshssh_config sshd_config loaded purposes 
p627
aVman page bash says following initialization files bash shells: etcprofile systemwide initialization file executed login shells etcbashbashrc systemwide perinteractiveshell startup file etcbashbashlogout systemwide login shell cleanup file executed login shell exits bash_profile personal initialization file executed login shells bashrc individual perinteractiveshell startup file bash_logout individual login shell cleanup file executed login shell exits inputrc individual readline initialization file apparently seem different configuration files different shells bash zsh csh others seem many shells different linux unix versions: csh ksh bash zsh bash bashrc zsh zshrc etc one also distinguish login shells nonlogin shells systemwide defaults userspecific defaults makes sense distinguish login nonlogin shells commands processed login commands run everytime open new terminal window difference bash_profile bashrc bash bashrc reloaded every time start new copy bash ie start new bash login bash_profile profile loaded login abbtreviation rc bashrc stands run commands run control convention adopted older unix systems systemwide defaults etcprofile login shells interactive shells login etcbashrc nonlogin bash shells userspecific defaults home directory profile login shells called login bashrc nonlogin shells already logged bash_profile login shells called login lower priority userspecific defaults home directory login logout bash_login login shells called upon login bash_logout login shells called upon logout following links helpful: bashrc vs bashprofile bash_profile vs bashrc bash manual page zshbash startup files loading order bashrc zshrc etc loadingorderbashrczshrcetc 
p628
aVhappen curious files experiment turns little different documents know differences interactive noninteractive login nonlogin tried two computers macbook pro os 109 server ubuntu server 1310 add following command etcprofile: echo loading etcprofile similar commands etcbashbashrc etcbashrc etcbashbashrc profile bash_profile bashrc bash_login make sure files source inside os 109 gnu bash version 32511release x86_64appledarwin13 mac interactive login bash have: loading etcprofile loading bash_profile means files loaded directly etcprofile bash_profile interactive nonlogin bash have: loading bashrc means file loaded directly bashrc ubuntu server 1310 gnu bash version 42451release x86_64pclinux gnu ubuntu interactive login bash have: loading etcprofile loading bash_profile means files loaded directly etcprofile bash_profile interactive nonlogin bash have: loading etcbashbashrc loading bashrc means files loaded directly etcbashbashrc bashrc know 
p629
asS'1452721'
p630
(lp631
Vusing namespace std considered bad practice ive told others numerous occasions teachers advice exercising using namespace std code wrong hence use std::cout std::cin using namespace std considered bad practice really inefficient risk declaring ambiguous variables variables share name function std namespace impact performance 
p632
aVanother reason surprise see cout blah instead std::cout blah think cout normal cout something special 
p633
aVrelated performance consider this: using two libraries called foo bar: using namespace foo using namespace bar everything works fine call blah foo quux bar without problems one day upgrade new version foo 20 offers function called quux youve got conflict: foo 20 bar import quux global namespace going take effort fix especially function parameters happen match used foo::blah bar::quux introduction foo::quux would nonevent 
p634
aVmanaging complexity using namespace pull things dont want thus possibly make harder debug say possibly using std:: place harder read text horses courses manage complexity best feel able 
p635
aVdepends located common header diminishing value namespace merging global namespace keep mind could neat way making module globals 
p636
aVconsider myheaderh include sstream using namespace std someoneelsescpph include myheaderh class stringstream uh oh note simple example files 20 includes imports youll ton dependencies go figure problem worse thing get unrelated errors modules depending definitions conflict horrible youll save headaches using header files global namespace probably alright limited scopes ive never problem typing extra 5 characters clarify functions coming 
p637
aVthink bad put header files classes: would forcing anyone wants use classes including header files also using ie seeing everything namespaces however may feel free put using statement private cpp files beware people disagree saying feel free like although using statement cpp file _better_ header doesnt affect people include header file think still _good_ depending code could make implementation class difficult maintain faq topic usingdirective exists legacy c code ease transition namespaces probably shouldn\u2019t use regular basis least new c code suggests two alternatives: using declaration: using std::cout usingdeclaration lets use cout without qualification cout values: get type std:: std::cout values: 
p638
aVimport right header files suddenly names like hex left plus count scope might surprising aware std:: contains names also try use names locally lead quite confusion standard stuff namespace dont worry name collisions code libraries 
p639
aVthink necessarily bad practice conditions need careful use youre writing library probably use scope resolution operators namespace keep library butting heads libraries application level code dont see anything wrong 
p640
aV 1 need able read code written people different style best practices opinions 2 youre using cout nobody gets confused lots namespaces flying around see class arent exactly sure namespace explicit acts comment sorts see first glance oh filesystem operation thats network stuff 
p641
aVagree everything greg wrote like add: _it even get worse greg said_ library foo 20 could _introduce function_ quux _an unambiguously better match_ calls quux bar::quux code called years _code still compiles_ _it silently calls wrong function_ godknowswhat thats bad things get keep mind std namespace tons identifiers many _very_ common ones think list sort string iterator etc likely appear code consider unlikely: _there question asked pretty much exactly happened wrong function called due omitted std:: prefix half year gave answer _here recent _example_ question _this real problem_ heres one data point: many many years ago also used find annoying prefix everything standard library std:: worked project decided start using directives declarations banned except function scopes guess took us weeks get used write prefix weeks us even agreed actually made code _more readable_ theres reason that: _whether like shorter longer prose subjective prefixes objectively add clarity code_ compiler find easier see identifier referred decade project grew several million lines code since discussions come curious often allowed functionscope using actually used project grepd sources found one two dozen places used indicates _once tried developers didnt find std:: painful enough_ employ using directives even every 100 kloc _even allowed used_ bottom line: explicitly prefixing everything doesnt harm takes little getting used objective advantages particular makes code easier interpret compiler human readers \u2014 probably main goal writing code 
p642
aValso consider bad practice one day thought function namespace divide stuff shouldnt spoil throwing everything one global bag however often use cout cin write: using std::cout using std::cin cpp file never header file propagates include think noone sane ever name stream cout cin 
p643
aVone shouldnt use using directive global scope especially headers however situations appropriate even header file: template typename floattype inline floattype compute_somethingfloattype x using namespace std problem since scope limited return expx sinx cosx 2 sinx 3 cosx 4 better explicit qualification std::sin std::cos shorter ability work user defined floating point types via argument dependent lookup 
p644
aVrecently ran complaint visual studio 2010 turned pretty much source files two lines: using namespace std using namespace boost lot boost features going c0x standard visual studio 2010 lot c0x features suddenly programs compiling therefore avoiding using namespace x form futureproofing way making sure change libraries andor header files use going break program 
p645
aVexperienced programmers use whatever solves problems avoid whatever creates new problems thus avoid headerfilelevel usingdirectives obvious reason try avoid full qualification names inside source files minor point elegant write code less code suffice _without good reason_ major point turning adl _good reasons_ sometimes explicitly want turning adl sometimes want disambiguate following ok: 1 functionlevel usingdirectives usingdeclarations inside functions implementations 2 sourcefilelevel usingdeclarations inside source files 3 sometimes sourcefilelevel usingdirectives 
p646
aV use globally considered bad used globally clutter namespace programming readers difficulty seeing particular identifier comes use many using namespace xyz whatever true _other_ readers source code even true frequent reader it: come back year two take look talk using namespace std might aware stuff grab add another include move new crevision might get name conflicts aware may use locally go ahead use locally almost freely course prevents repetition std:: \u005c repetition also bad idiom using locally c03 idiom boilerplate code implementing swap function classes suggested actually use local using namespace std \u005c least using std::swap: class thing int value_ child child_ public: friend void swapthing thing b void swapthing thing b using namespace std make std::swap available swap members swapavalue_ bvalue_ std::stwapint int swapachild_ bchild_ swapchildchild std::swap following magic compiler choose std::swap value_ ie void std::swapint int overload void swapchild child implemented compiler choose _not_ overload compiler use void std::swapchildchild try best swapping c11 reason use pattern anymore implementation std::swap changed find potential overload choose 
p647
aVyes namespace important project needed import one var declaration source code compiling conflicted another thirdparty library end work around around means make code less clear 
p648
aVunqualified imported identifiers need external search tools like _grep_ find identifiers declared makes reasoning program correctness harder 
p649
aVusing namespace std considered bad practice c put way around: typing 5 extra chars considered cumbersome consider eg writing piece numerical software would even consider polluting global namespace cutting general std::vector vector vector one problem domains important concepts 
p650
aVanswer question look way practically: lot programmers invoke namespace std therefore one habit using things impinge use names namespace std great deal granted much compared number possible coherent words pseudonyms come strictly speaking mean really saying dont rely present setting rely present constantly going issues borrowing code snippets constantly repairing keep user defined borrowed stuff limited scope sparing globals honestly globals almost always last resort purposes compile sanity later truly think bad advice teacher using std work cout std::cout using std work std::cout always fortunate enough write code note: dont focus much efficiency issues actually learn little compilers work little experience coding dont learn much realize much able generalize good code something something simple every bit simple wrote whole thing c good code complex needs 
p651
aVagree used globally evil use locally like namespace heres example _the c programming language_ : namespace my_lib using namespace his_lib everything his_lib using namespace her_lib everything her_lib using his_lib::string resolve potential clash favor his_lib using her_lib::vector resolve potential clash favor her_lib example resolved potential name clashes ambiguities arising composition names explicitly declared including names declared using declarations like his_lib::string take priority names made accessible another scope usingdirective using namespace her_lib 
p652
aVthink using locally globally depend application use library locally sometimes code going real mess readability going low use libraries locally possibility conflicts experiences person let know wrong 
p653
aVusing many namespaces time obviously recipe disaster using namespace std namespace std big deal opinion redefinition occur code consider functions reserved names like int class people stop anal teacher right along use one namespace whole point using namespaces first place supposed use one time unless redefinition happen 
p654
aVnice see code know see std::cout know: thats cout stream std library see cout dont know _could_ cout stream std library could int cout 0 ten lines higher function static variable named cout file could anything take million line code base isnt particularly big youre searching bug means know one line one million lines doesnt supposed cout ltlt 1 could read static int named cout shift left one bit throw away result looking bug id check see really really prefer see std::cout one things seem really good idea teacher never write maintain code living love seeing code 1 know 2 im confident person writing knew 
p655
aVagree others asking name clashes ambiguities fact less explicit see use using personal preference limit would also strongly consider others pointed out: want find function name might fairly common name want find std namespace reverse: want change calls namespace std namespace x propose could write program wouldnt better spend time working project rather writing program maintain project personally actually dont mind std:: prefix like look dont know explicit says isnt code using standard library something else think looks nicer might odd given recently got c used still c languages much longer c favourite language time right assembly one thing although somewhat related others point might bad practise sometimes reserve std::name standard library version name programspecific implementation yes indeed could bite bite hard comes started project scratch im programmer example: overload std::string call string helpful additions part c unix linux tendency towards lowercase names besides namespace aliases example useful might referred didnt read responses im rush moment use c11 standard specifically libstdc well check doesnt complete std::regex support sure compiles throws exception along lines error programmers end lack implementation heres solved install boosts regex link boosts regex following libstdc implemented entirely need remove block code remains same: namespace std using boost::regex using boost::regex_error using boost::regex_replace using boost::regex_search using boost::regex_match using boost::smatch namespace regex_constants boost::regex_constants wont argue whether bad idea however argue keeps clean project time makes specific: true use boost im using like libstdc eventually yes starting project starting standard beginning goes long way helping maintenance development everything involved project edit: time clarify something dont actually think good idea use name classwhatever stl deliberately specifically place string exception ignore first second pun must didnt like idea string still biased towards c biased c sparing details much work fits c good exercise good way make learn another language b try less biased objectclassesetc maybe better stated as: less closedminded less arrogant accepting useful already suggested: indeed use list fairly generic sort thing name two would cause name clash using namespace std end prefer specific control knowing intend standard use specify put simply: assuming allowed making boosts regex part std future integration admit fully bias dont think ugly boost::regex:: indeed another thing theres many things c still yet come fully accept looks methods another example: variadic templates versus var args though admit variadic templates useful even accept difficult still issues 
p656
aVshort version: dont use global using declarations directives header files feel free use implementation files heres herb sutter andrei alexandrescu say issue c coding standards emphasis mine: summary namespace usings convenience inflict others: never write using declaration using directive include directive corollary: header files don\u2019t write namespacelevel using directives using declarations instead explicitly namespacequalify names second rule follows first headers never know header includes might appear discussion short: use namespace using declarations directives liberally implementation files include directives feel good despite repeated assertions contrary namespace using declarations directives evil defeat purpose namespaces rather make namespaces usable 
p657
aVexample using namespace std throws complilation error ambiguity count also function algorithm library include iostream using namespace std int count 1 int main coutcountendl 
p658
aVagree others would like address concerns regarding readability avoid simply using typedefs top file function class declaration usually use class declaration methods class tend deal similar data types members typedef opportunity assign name meaningful context class actually aids readability definitions class methods header class file typedef std::vectorstd::string lines lines readlines implementation: cpp lines file::readlines lines lines get return lines opposed to: cpp vectorstring file::readlines vectorstring lines get return lines or: cpp std::vectorstd::string file::readlines std::vectorstd::string lines get return lines 
p659
aVnamespace named scope namespaces used group related declarations keep separate items separate example two separately developed libraries may use name refer different items user still use both: namespace mylib templateclass class stack namespace yourlib class stack void fint max mylib: :stackint s1max use stack yourlib: :stack s2max use stack repeating namespace name distraction readers writers consequently possible state names particular namespace available without explicit qualification example: void fint max using namespace mylib make names mylib accessible stackint s1max use stack yourlib: :stack s2max use stack namespaces provide powerful tool management different libraries different versions code particular offer programmer alternatives explicit make reference nonlocal name source : overview c programming language bjarne stroustrup 
p660
aVexample showing using namespace std lead name clash problems: unable define global variable c variableinc example generic algorithm name std::count name clashes reasonable variable name count 
p661
aVexperiences multiple libraries uses say cout different purpose may use wrong cout example type using namespace std using namespace otherlib type cout happens rather std::cout otherlib::cout might use wrong one get errors much effective efficient use std::cout 
p662
aVconcrete example clarify concern imagine situation 2 libraries foo bar namespace: namespace foo void afloat something namespace bar lets say use foo bar together program follows: using namespace foo using namespace bar void main a42 point everything fine run program something later update bar lets say changed like: namespace bar void afloat something completely different point youll get compiler error: using namespace foo using namespace bar void main a42 error: call ambiguous foo::a42 youll need maintenance clarify meant ie foo::a thats probably undesirable fortunately pretty easy add foo:: front calls compiler marks ambiguous imagine alternative scenario bar changed instead look like instead: namespace bar void aint something completely different point call a42 suddenly binds bar::a instead foo::a instead something something completely different compiler warning anything program silently starts something complete different use namespace youre risking scenario like people uncomfortable using namespaces things namespace greater risk conflict people might even uncomfortable using namespace std due number things namespace namespaces ultimately tradeoff writability vs reliabilitymaintainability readability may factor also could see arguments going either way normally would say reliability maintainability important case youll constantly pay writability cost fairly rare reliabilitymaintainability impact best tradeoff determine project priorities 
p663
asS'41157760'
p664
(lp665
Vc explicit template instantiation storage class allowed ignored noticed storage class specifier placed template instantiation create compiler error know storage class used template design cannot used specialization wondering rejected compiler instantiation tried different combiniations seemed effect linking missing something please template typename my_func arg1 return 1 template static gcc allows line without errorwarning effect int my_func int arg1 edit: note im placing template instantion different cpp used test liniking although clear snippet 
p666
asS'22186626'
p667
(lp668
Vfile pointer chow works write main file p pfopenfilenameanymode question thing memory pointer p pointing 
p669
aVp pointer stored file object fopen really pointer stream file operations performed however actual inner workings object abstracted away fopen file fopen const char filename const char mode opens file whose name specified parameter filename associates stream identified future operations file pointer returned 
p670
aVp points memory location holding file structure thats really need know contents structure entirely implementationspecific implemented _correctly_ terms encapsulation ie opaque structure shouldnt even able find contains unless youre implementer standard library receive fopen pass functions requiring file fwrite fread fclose 
p671
aVfile pointer p pointing structure handled c library manages io functionality named file given open mode cant tell priori whether points statically allocated memory dynamically allocated memory dont need know treat opaque pointer note standard says: isoiec 9899:2011 7213 files address file object used control stream may significant copy file object need serve place original says roughly: dont futz around pointer pass functions need otherwise leave well alone 
p672
asS'16503983'
p673
(lp674
Vusing gcc compile c program following example cuny never done anything c probably dont know consider program 1 need shebang line c code written emacs 2 go compile using line gcc g o forwardadding forwardaddingc hit message: forwardaddingc:9:17: error: expected expression \u2018\u2019 token 3 get code compiles use gdb debug run code corrrect code: include stdioh include mathh main float sum term int sum 00 1 10000000 term float term term term term 1 term sum term printfthe sum 12f\u005cn sum 
p675
aVneed put variable loop complete expression probably line 9 1 10000000 change 1 10000000 
p676
aV 1 shebang needed could add emacs mode line comment 2 loop be: 1 10000000 code missing second 3 yes use gdb youve got code compiling youd get better answer mathematics counted 10000000 counting 10000000 10000 extra values add nothing result please get habit writing c99 code means write: int mainvoid return type int required void recommended 
p677
aVmissing correct jonathan leffler suggested save file open terminal use compile code gcc your_file_namec code compiles next run code compiled type aout program runs shows output 
p678
asS'37096836'
p679
(lp680
Vmutable specifier classified storage class specifier qualifier mutable specifier used declaration nonstatic data member data mutable matter whether rest object treated const fact may easily impression mutable specifier kind thing const qualifier turns true fact language classifies mutable specifier storage class specifier quite counterintuitive mutable specifies storage duration rationales behind design decision would make less logical would seemed mutable qualifier advantages making storage class specifier 
p681
aV_cvqualifier_s modifyrestrict objects semantics mutable part type would superfluous practically scenarios necessitating paragraphs pointer conversions etc thus decided make _declspecifier_ isnt _type specifier_ since const cause object put writeprotected memory mutable cause object put storage suggesting _storageclassspecifier_ 
p682
asS'14481469'
p683
(lp684
Vuse union class struct classes structs one difference far know struct defaults public class defaults private came know similar kind data type also used similar manner union union used base class inheritance dont know means still accept wanted know whether particular instances struct union class used interchangeably except cases enlisted please tell wrong somewhere regards 
p685
aVunion class structure completely different union several things time say character array integer class structure one one thing encapsulates logically connected information well optionally logic manipulating use cases unions two quite different usually use structure store data also need logic associated itie need add methods use class 
p686
aVnever use union end looking better try boost variant acceptable situation use really need deep control content like custom serialization would run many cases also structure used storing data need add functionmethod convert class 
p687
aVuse class struct union following: class objects behaviour struct passive data union special cases different data requires accessed different types ive read except union point google c style guidehttp :google styleguidegooglecodecomsvntrunkcppguidexmlstructs_vs_classes long time ago following since using structs carry passive data objects without behaviour attached object advantage default publicness members accessed without getters setters member data needs checkedmodified assign member data needs computedmodified getted imho need settergetter pair object class instead struct union type find useful kind data structures requires _weird_ access members needs members treated another type contexts example 3d vector ip address: union 3dvector double x y z double vector3 v acess members name vx 60 vy 70 vz 80 acess members vector normalizevvector union ipaddress int binary char octet4 ip acess binary address std::cout std::hex ipbinary \u005cn print humanreadable form std::cout static_castintipoctet0 static_castintipoctet1 static_castintipoctet2 static_castintipoctet3 \u005cn functionality could achieved overloading operators conversion operators union approach looks neat unions also templated constructordestructor could useful serialization purposes kind objects: template typename union serializer serializerconst o : objecto object char binarysizeoft somepodobject obj pod objects please serializer sobj sendbuffersbinary 
p688
aVareas may use struct class: want define _interface_ type contains pure virtual methods aligns notion struct defaults public pure dataonly types behavior attached type policy trait types matter personal preference union neither class struct used c create discriminated variant types time memory premium c dont see much advantage typical applications may still used embedded lowmemory applications 
p689
aVtypically structs unions used together c one accessing registers struct define bit allow bit register set individually union allow bits changed accessed time even c one needs way setup hardware write registers chip 
p690
asS'19971886'
p691
(lp692
Vunderscore used anywhere identifier c simple question: use underscore anywhere identifier yes please give example please explain 
p693
aVunderscore seen normal lettercharacter msdn desciption identifiers uslibrarye7f8y25b28vvs11029aspx besides often coding guidelines restrict use underscore eg constructor parameters named _name name class variable name 
p694
aVrules writing identifier 1 identifier composed letters uppercase lowercase letters digits underscore _ 2 first letter identifier either letter underscore discouraged start identifier name underscore though legal identifier starts underscore conflict system names cases compiler complain system names start underscore _fileno _iob _wfopen etc 3 rule length identifier however first 31 characters identifier discriminated compiler first 31 letters two identifiers program different ex: int identifier int _identifier int new_identifier 
p695
aVyes underscores may appear everywhere identifier _a _0_ even _ valid identifiers rules may use code reserved implementation compiler os identifiers starting _ capital letter reserved everywhere supposed use used freely compiler may used future language extensions eg official boolean type c named _bool identifiers starting _ lower case letter reserved file scope allowed name function global variable _toto something alike could conflict names library functions eg identifiers one _ row reserved c name mangling ever think writing code c callable c shouldnt use identifiers ending _t reserved posix types want avoid future portability issues new systems avoid lot rules reserved names listed remembered concerning _ 
p696
aVyes underscores used identifiers heres example: ioccc winner 1988 define _ f00foo int f00oo00mainf_ooprintf13f\u005cn4foooof_oo ____ _________ ____________ ______________ _______________ _______________ ________________ ________________ ________________ ________________ _______________ _______________ ______________ ____________ ________ ____ _why_ underscore allowed anywhere identifier answer is: standard describes syntax identifier comprised least one _nondigit_ followed zero _digit nondigit_ chars also defines _nondigits_ either one following chars: _ b c d e f g h j k l m n o p q r u v w x y z b c d e f g h j k l m n o p q r u v w x y z digits are: 0 1 2 3 4 5 6 7 8 9 following rule _____ valid identifier my_identifier _000000aaff___ aware thing reserved identifiers described standard answer _why_ question again: standard said p 
p697
asS'34680929'
p698
(lp699
Vcant static register storage classes used together defining variable following manner: static register int a1 0 get error: error: multiple storage classes declaration specifiers fundamental reason error cant variable stored register also initialized start upfirst call _it possible attach register storage class global variable_ lt\u005c edit: true 
p700
aVcompiler implemented wanted faithfully would tie cpu register length program thats hardly practical remember register advisory 
p701
aVstandard allow use one storageclass specifier declaration c99 standard: 671 storageclass specifiers 1 _storageclassspecifier:_ typedef extern static auto register 2 one storageclass specifier may given declaration specifiers declaration 
p702
aVmain reason register qualifier implies variable automatic storage duration basically auto variable telling compiler would good place general purpose cpu register static qualifier implies static thread storage duration obviously two incompatible applied variable would like asking variable die survive time activation record belongs removed 
p703
asS'37538'
p704
(lp705
Vdetermine size array c determine size array c number elements array hold 
p706
aVexecutive summary: int a17 n sizeofasizeofa0 determine size array bytes use sizeof operator: int a17 int n sizeofa computer ints 4 bytes long n 68 determine number elements array divide total size array size array element could type like this: int a17 int n sizeofa sizeofint get proper answer 68 4 17 type changed would nasty bug forgot change sizeofint well preferred divisor sizeofa0 size zeroeth element array int a17 int n sizeofa sizeofa0 another advantage easily parameterize array name macro get: define nelemsx sizeofx sizeofx0 int a17 int n nelemsa 
p707
aV sizeofarray sizeofarray0 
p708
aVworth noting sizeof doesnt help dealing array value decayed pointer: even though points start array compiler pointer single element array pointer remember anything else array used initialize int a10 int p assertsizeofa sizeofa0 10 assertsizeofp sizeofint assertsizeofp sizeofint 
p709
aV@ magnus: standard defines sizeof yielding number bytes object sizeof char always one number bits byte implementation specific edit: ansi c standard section 533 sizeof: sizeof operator yields number bytes object representation operand sizeof char sizeof signed char sizeof unsigned char 1 result sizeof applied fundamental type implementationdefined section 16 c memory model: fundamental storage unit c memory model byte byte least large enough contain member basic execution character set composed contiguous sequence bits number implementationdefined 
p710
aV @skizz: pretty sure right although best source give moment wikipedia article sizeof: wikipedia wrong skizz right sizeofchar 1 definition mean _just read wikipedia entry really closely_ see wrong multiples char sizeofchar never anything _other_ 1 say 2 would mean sizeofchar twice size char 
p711
aVsizeof trick best way know one small major pet peeve important change use parenthesis wikipedia entry makes clear cs sizeof function operator thus require parenthesis around argument unless argument type name easy remember since makes argument look like cast expression also uses parenthesis so: following: int myarray10 find number elements code like this: size_t n sizeof myarray sizeof myarray reads lot easier alternative parenthesis also favor use asterisk righthand part division since concise indexing course compiletime theres need worry division affecting performance program use form wherever always best use sizeof actual object one rather type since dont need worry making error stating wrong type instance say function outputs data stream bytes instance across network lets call function send make take arguments pointer object send number bytes object prototype becomes: void sendconst void object size_t size need send integer code like this: int foo 4711 sendfoo sizeof int youve introduced subtle way shooting foot specifying type foo two places one changes doesnt code breaks thus always like this: sendfoo sizeof foo youre protected sure duplicate name variable high probability breaking way compiler detect change 
p712
aVmultidimensional arrays tad complicated oftenly people define explicit macro constants ie define g_rgdialogrows 2 define g_rgdialogcols 7 static char const g_rgdialogg_rgdialogrowsg_rgdialogcols 494 210 generic sample dialog 1 330 174 88 ok constants evaluated compiletime _sizeof_: define rows_of_arrayname \u005c sizeofname sizeofname00 columns_of_arrayname define columns_of_arrayname \u005c sizeofname0 sizeofname00 static char g_rgdialog7 assert rows_of_arrayg_rgdialog 2 assertcolumns_of_arrayg_rgdialog 7 note code works c c arrays two dimensions use sizeofname000 sizeofname0000 etc ad infinitum 
p713
aVyouve introduced subtle way shooting foot c native arrays store size therefore recommended save length array separate variableconst pass whenever pass array is: define my_array_length 15 int myarraymy_array_length always avoid native arrays unless cant case mind foot writing c use stl container compared arrays provide almost performance far useful vector template int means vector ints vectorint numbers push_back puts new value end back vector int 0 10 numberspush_backi determine size array cout numberssize see: 
p714
aVsizeof way right way _iff_ arrays received parameters array sent parameter function treated pointer sizeof return pointers size instead arrays thus inside functions method work instead always pass additional parameter size_t size indicating number elements array test: include stdioh include stdlibh void printsizeofint intarray void printlengthint intarray int mainint argc char argv int array 0 1 2 3 4 5 6 printfsizeof array: d\u005cn int sizeofarray printsizeofarray printflength array: d\u005cn int sizeofarray sizeofarray0 printlengtharray void printsizeofint intarray printfsizeof parameter: d\u005cn int sizeofintarray void printlengthint intarray printflength parameter: d\u005cn int sizeofintarray sizeofintarray0 output 64bit linux os: sizeof array: 28 sizeof parameter: 8 length array: 7 length parameter: 2 output 32bit windows os: sizeof array: 28 sizeof parameter: 4 length array: 7 length parameter: 1 
p715
aVuse operator source code: includestdioh includestdlibh int main int a10 int p printfp\u005cn void printfp\u005cn void a1 printf diff\u005cn printfzu\u005cn sizeofa0 printfthe size array zu\u005cn char a1char asizeofa0 return 0 sample output 1549216672 1549216712 diff 4 size array 10 
p716
aVreally want pass around array suggest implementing structure store pointer type want array integer representing size array pass around functions assign array variable value pointer first element pointer go arrayarri get ith element use arraysize get number elements array included code useful could extend features honest though things want stop using c use another language features built absolutely one use time youre done implementing youll wish passed around array size functions static implementation get dynamic implementation cut array main using stdlib memory allocation methods work much slower since store array heap include stdioh include stringh include mytypearrayh mytypearrayh ifndef mytype_array define mytype_array typedef struct mytype int age char name20 mytype typedef struct mytypearray int size mytype arr mytypearray mytype new_mytypeint age char name mytypearray newmytypearrayint size mytype first endif end mytypearrayh mytypearrayc mytype new_mytypeint age char name mytype d dage age strcpydname name return d mytypearray new_mytypearrayint size mytype first mytypearray d dsize size darr first return d end mytypearrayc void print_mytype_namesmytypearray d int 0 dsize printfname: age: d\u005cn darriname darriage int main first create array stack store elements note could create empty array size instead set elements later mytype arr new_mytype10 sam new_mytype3 baxter create mytypearray use array created internally really store value pointer arr manually setting size use sizeof trick instead youre sure work compiler mytypearray array new_mytypearray2 arr mytypearray array new_mytypearraysizeofarrsizeofarr0 arr print_mytype_namesarray return 0 
p717
aV int size arr1 arr check link differencebetweenarrandarrhowtofindsize link explanation 
p718
aVknow data type array use something like: int arr 23 12 423 43 21 43 65 76 22 int noofele sizeofarrsizeofint dont know data type array use something like: noofele sizeofarrsizeofarr0 note: thing works array defined run time like malloc array passed function cases arr array name pointer 
p719
aVapologise commenting old thread wanted clear something messed explaining edited mark harrisons answer ofmyarrayinc3753937539 tired managed fall old arrays actually pointers trap would left comment apparently im allowed point macro arrayelementcountx everyone making use evaluates incorrectly realistically sensitive matter cant expressions result array type compile as: cl p macroc define arrayelementcountx sizeof x sizeof x0 arrayelementcountp 1 _actually_ evaluates as: sizeof p 1 sizeof p 10 whereas compile as: cl p macroc define arrayelementcountx sizeof x sizeof x0 arrayelementcountp 1 correctly evaluates to: sizeof p 1 sizeof p 10 really doesnt lot size arrays explicitly ive noticed lot errors truly observing c preprocessor works always wrap macro parameter expression might involved @alexmelbourne reverted suggested edit produced incorrect results expression p1 correct example bad one thats actually exactly happen previously mentioned p 1 end pointer type invalidate entire macro like attempted use macro function pointer parameter end day _particular_ instance fault doesnt really matter im wasting everyones time huzzah dont expressions type array really point preprocessor evaluation subtles think important one 
p720
aV int a1012345 int nsizeofa printfdn output: 5 reason: calculates elements held array rather free spaces allocated 
p721
aVsize array c: int a10 size_t size_of_array sizeofa size array int n sizeof sizeof a0 elements array size_t size_of_element sizeofa0 size element array size element size type 
p722
aVbest way save information example structure: typedef struct int array int elements list_s implement necessary functions create destroy check equality everything else need easier pass parameter 
p723
aV define size_of_array_array sizeof_array sizeof_array0 
p724
asS'307692'
p725
(lp726
Vsimplest way open use socket c im starting basic network programming c found things sockets seem convoluted maybe opening sockets c convoluted would like know simplest effective way open write data socket c programming language thanks 
p727
aVreading writing basic sockets harder reading writing normal files use recv instead read send instead write things get little trickey need open socket reason many different ways communicate using sockets tcp udp etc 
p728
aVyoure right using sockets c difficult syntax later languages like java python make snap comparison best ive found socket programming c beejs guide network programming recommend start beginning get good overview need get code working _now_ skip ahead section titled clientserver background good luck 
p729
aVmight want try tcp4u free makes socket programming easy 
p730
aVdont mention platform copy unix network programming good addition bookshelf operating systems implement berkley sockets using socket bind connect etc 
p731
aVunless write network daemon networking c done higher level using directly sockets using appropriate libraries instance want retrieve file http use neon libcurl higher level gratis ssl ipv6 etc 
p732
aVmuch good advice far generally write c find use white paper wrote avoid top ten sockets programming errors ignore advice use ace toolkit since requires c take note socket errors paper theyre easy make hard find especially beginner 
p733
aVdefinitive guide linux network programming describe socket easy explain many things like server threading protocol design etc also tcpip sockets c second edition good 
p734
aVposix 7 client server tcp example usage get two computers lan run server one computer with: serverout get ip server computer ifconfig eg 192168010 computer run: clientout 192168010 type lines client server return incremented 1 rot1 cypher serverc define _xopen_source 700 include stdboolh include stdioh include stdlibh include stringh include arpaineth include netdbh getprotobyname include netinetinh include syssocketh include unistdh int mainint argc char argv char bufferbufsiz char protoname tcp struct protoent protoent int enable 1 int int newline_found 0 int server_sockfd client_sockfd socklen_t client_len ssize_t nbytes_read struct sockaddr_in client_address server_address unsigned short server_port 12345u argc 1 server_port strtolargv1 null 10 protoent getprotobynameprotoname protoent null perrorgetprotobyname exitexit_failure server_sockfd socket af_inet sock_stream protoentp_proto 0 server_sockfd 1 perrorsocket exitexit_failure setsockoptserver_sockfd sol_socket so_reuseaddr enable sizeofenable 0 perrorsetsockoptso_reuseaddr failed exitexit_failure server_addresssin_family af_inet server_addresssin_addrs_addr htonlinaddr_any server_addresssin_port htonsserver_port bind server_sockfd struct sockaddrserver_address sizeofserver_address 1 perrorbind exitexit_failure listenserver_sockfd 5 1 perrorlisten exitexit_failure fprintfstderr listening port d\u005cn server_port 1 client_len sizeofclient_address client_sockfd accept server_sockfd struct sockaddrclient_address client_len nbytes_read readclient_sockfd buffer bufsiz 0 printfreceived:\u005cn writestdout_fileno buffer nbytes_read buffernbytes_read 1 \u005cn newline_found 0 nbytes_read 1 bufferi writeclient_sockfd buffer nbytes_read newline_found break closeclient_sockfd return exit_success clientc define _xopen_source 700 include asserth include stdboolh include stdioh include stdlibh include stringh include arpaineth include netdbh getprotobyname include netinetinh include syssocketh include unistdh int mainint argc char argv char bufferbufsiz char protoname tcp struct protoent protoent char server_hostname 127001 char user_input null in_addr_t in_addr in_addr_t server_addr int sockfd size_t getline_buffer 0 ssize_t nbytes_read user_input_len struct hostent hostent struct used inet addresses struct sockaddr_in sockaddr_in unsigned short server_port 12345 argc 1 server_hostname argv1 argc 2 server_port strtolargv2 null 10 get socket protoent getprotobynameprotoname protoent null perrorgetprotobyname exitexit_failure sockfd socketaf_inet sock_stream protoentp_proto sockfd 1 perrorsocket exitexit_failure prepare sockaddr_in hostent gethostbynameserver_hostname hostent null fprintfstderr error: gethostbyname\u005cs\u005c\u005cn server_hostname exitexit_failure in_addr inet_addrinet_ntoastruct in_addrhostenth_addr_list in_addr in_addr_t1 fprintfstderr error: inet_addr\u005cs\u005c\u005cn hostenth_addr_list exitexit_failure sockaddr_insin_addrs_addr in_addr sockaddr_insin_family af_inet sockaddr_insin_port htonsserver_port actual connection connectsockfd struct sockaddrsockaddr_in sizeofsockaddr_in 1 perrorconnect return exit_failure 1 fprintfstderr enter string empty quit:\u005cn user_input_len getlineuser_input getline_buffer stdin user_input_len 1 perrorgetline exitexit_failure user_input_len 1 closesockfd break writesockfd user_input user_input_len 1 perrorwrite exitexit_failure nbytes_read readsockfd buffer bufsiz 0 writestdout_fileno buffer nbytes_read buffernbytes_read 1 \u005cn fflushstdout break freeuser_input exitexit_success github makefile cheattreef31150c42331407fd434a7e912ca64642710fea2posixsocketinet tested ubuntu 1510 message length read calls client server run inside loops like reading files os may split messages arbitrarily make things faster eg one packet may arrive much earlier protocol must specify convention messages stop common methods include: header length indicator eg http contentlength unique string terminates messages use \u005cn server closes connection: http allows next steps example limited because: server handle one client connection time communication synchronized simply eg: p2p chat app server person could send messages time solving problems requires threading possibly calls like poll 
p735
asS'9105394'
p736
(lp737
Vappend unix command date echo statement basically want terminal output message followed date time like hi today dateandtime echo accomplish first bit date accomplish last separately put together one command output together like echo new command date one line pipelining answer 
p738
aVit: echo hi today date 
p739
aV echo today date also format output date using modifiers like: echo today date d see man date complete list modifiers 
p740
aVdate time take arbitrary format string date hi today b e h:m:s z y hi today thu feb 2 03:28: cet 2012 
p741
aVbacktick trick: echo hi today date 
p742
aVparticular problem mimisbrunnrs solution right way go general question append data echo common techniques are: echo hi today tr d \u005c012 date hi today wed feb 1 18:11:40 mst 2012 echo n hi today date hi today wed feb 1 18:11:43 mst 2012 printf hi today date hi today wed feb 1 18:11:48 mst 2012 
p743
asS'21359239'
p744
(lp745
Vmean declare variable storage class specifier type specifier reading ansi c yacc grammar noticed following valid: register x auto y static z extern q seems strange understanding type would suggest none variables type mean type checked much memory allocated 
p746
aVc99 type specified defaulted int supposed removed c99 many compilers support even c99 mode example clang even using stdc99 receive following warnings opposed errors: warning: type specifier missing defaults int wimplicitint register x warning: type specifier missing defaults int wimplicitint auto y warning: type specifier missing defaults int wimplicitint static z warning: type specifier missing defaults int wimplicitint extern q gcc also provides warning case although using pedanticerrors flag cause gcc produce errors usually case extensions gcc usually clang case look draft c99 standard stdorgjtc1sc22wg14wwwdocsn1256pdf _forward_ section says: major changes previous edition include: includes following bullet: \u2014 remove implicit int update rationale international standard\u2014programming languages\u2014c section 672 _type specifiers_: new feature c99: c89 type specifiers could omitted declaration specifiers declaration case int implied committee decided inherent danger feature outweighed convenience removed effect guarantee production diagnostic catch additional category programming errors issuing diagnostic implementation may choose assume implicit int continue translate program order support existing source code exploits feature grammar using predate _c99_ far tell newer version reflect c11 differ much respect type specifiers declaration grammar situation sufficient enforce constraint would goto standard section 672 _type specifiers_ see says: least one type specifier shall given declaration specifiers declaration specifierqualifier list struct declaration type name 
p747
asS'28557680'
p748
(lp749
Vcharset putchar c trying figure character set putchar uses seemingly cannot print multibyte characters: putchar\u20ac gcc warning: multicharacter character constant codepage terminal windows set 1252 west european latin chcp 1252 following code able print euro sign: putchar128 still even though terminals charset set 1252 putchar\u20ac cannot print euro sign anybody please explain seeming discrepancy thank much 
p750
aVchar c practical purposes means byte character source file likely encoded utf8 euro symbol encoded following 3 bytes: 0xe2 0x82 0xac putchar name implies writes single bytes c language notion characters encodings gcc default uses exact bytes found source file case prints byte 0xac least significant byte \u20ac standard output doesnt matter looks like editor encoding file supposed gcc doesnt case copies bytes asis terminal displays given stream bytes program depends solely settings terminal want display utf8 encoded text windows terminal enter chcp 65001 change font lucida since editor displays bytes according specified encoding terminal displays bytes using encoding long use gcc clang default settings editor terminal use encoding see characters programs edit: remarks gcc handles encodings: two options: finputcharset fexeccharset gcc treats bytes narrow string char literals literally two options identical gcc converts input encoding exec encoding bit testing conclude reason gcc runs windows1250 input encoding utf8 exec encoding want make really really sure using right encoding add finputcharsetcp1250 fexeccharsetcp1250 compiler options also way make program run default encoding console desire 
p751
asS'2477650'
p752
(lp753
Vunix get environment variable ridiculous question due ridiculous problem normally want get contents environment variable unix shell echo var lets assume due ridiculous situation isnt possible get contents environment variable stdout without someone looking command output see value environment variable picture solution something like echo envname_of_var although cant seem find solution work sh ps cant write script must built unix command know ridiculous problem thanks sorry absurdity 
p754
aVthis: myvariableenv grep variable_name grep oe 
p755
aVmean something like this: env printf echo s\u005cn 1 sh works plain old bourne shell 
p756
aVprintenv variable_name 
p757
aVsolution really depends restrictions cant use simple var maybe could call shell doesnt restrictions let subshell evaluate variable: bash c echo var 
p758
aVtype following command terminal display list environment variables printenv print wanted variable like this: echo variablename 
p759
asS'2507082'
p760
(lp761
Vgetc vs getchar vs scanf reading character stdin three functions: getc getchar amp scanf best one reading character stdin known disadvantages limitations functions makes one better 
p762
aVsimply want read single character stdin getchar appropriate choice complicated requirements getchar wont sufficient getc allows read different stream say one opened fopen scanf allows read single character time common error using getchar try use char variable store result need use int variable since range values getchar returns value range unsigned char plus single negative value eof char variable doesnt sufficient range mean confuse completely valid character return eof applies getc 
p763
aVbeejs guide c programming functions one way another read single character console file differences fairly minor descriptions: getc returns character specified file usage standpoint equivalent fgetc call fgetc little common see implementation two functions differs fgetc returns character specified file usage standpoint equivalent getc call except fgetc little common see implementation two functions differs yes cheated used cutnpaste last paragraph getchar returns character stdin fact calling getcstdin 
p764
asS'2018730'
p765
(lp766
Vfprintf string argument order create formatted file want utilize fprintf must get char parameters several string variables use fprintf 
p767
aVbasic usage fprintf strings looks like this: char str1 str2 str3 file f f fopenabctxt w fprintff s\u005cn str1 str2 fprintff more: s\u005cn str3 fclosef add several strings using several format specifiers use repeated calls fprintf write file incrementally c std::string objects use c_str method get const char suitable use fprintf: std::string strabc fprintff s\u005cn strc_str 
p768
aVfprintf multiple strings pretty simple eg const char charstring1 const char charstring2 const char charstring3 test fprintffilehandle charstring1 charstring2 charstring3 
p769
aVfprintf works analogous printf format specifier mention many want give corresponding number string arguments want detailed answer please post code 
p770
asS'943267'
p771
(lp772
Vgood practice use unions c need define class like this: class color private: union data unsigned int intvalue unsigned char argbbytes4 private: data m_data another way course define data integer cast char array whenever necessary im wondering one preferred way contradiction remote memory someones remind use union anymore however seems cleaner solution case 
p773
aVusing unions still acceptable practice change rgbbytes array : c unions used different purposes sometimes used variant type ie hold values different type memory location usage would questionable c youd use inheritancepolymorphism however use unions provide different interface data kind usage still valid c 
p774
aVunions fine long use carefully used two ways: 1 allow single type data accessed several ways example accessing colour int probably intended four chars 2 make polymorphic type single value could hold int float example case 1 fine youre changing meaning type read write members union without breaking anything makes convenient efficient way accessing data slightly different forms case 2 useful extremely dangerous need always access right type data within union write int try read back float youll get meaningless value unless memory usage primary consideration might better use simple struct two members unions used vital c c usually much nicer ways achieve ends eg class used wrap value allow accessed different ways however need raw performance critical memory situation unions may still useful approach 
p775
aVgood practice yes caveats back days memory scarce unions popular reuse memory days long gone using unions purpose adds needless complexity dont union genuinely describes data example give perfectly reasonable thing however warned building platform dependencies different platform different integer sizes different byte ordering might get expecting 
p776
aVsince using c id say good practice limited pure c sure biggest problem imo size union always size largest member want store byte shitloadofdata size sizeofshitloadofdata byte polymorphism far better option unions 
p777
aVc use unions constrained fact members must pods plain old data example union member cannot constructor destructor among restrictions 
p778
aVhypothetical c coding standards unions would banned since tend violate correctness simplicity clarity come first rule however widespread recommendation sutter alexandrescu didnt rule c coding standards fortunately everybody know finds hard get right dont produce found void apis hard get right : 
p779
aVyes definitely good practice use unions way telling compiler piece memory used store different types using union maintains static type safety since reinterpret_castlt need used makes intent code easier read also necessary use unions compiling strict aliasing case compiler assume pointers different types never point memory strict aliasing topic short readingwriting memory different pointer types strict aliasing enabled often behave expected 
p780
aVusing gcc going dereference pointers referring location better stick unions consider following code: int main char rgba4 0xcc 0xcc 0xcc 0 int value intrgba compiling code wstrictaliasing2 raise warning saying strict aliasing rules violated accessing value undefined behavior hand using union access part another variable isnt violation strict aliasing rules 
p781
aVthing dont like unions undiscriminating give info underlying type currently easy violate type safety accessing wrong side union boost::variant solves lot problems documentation points union nearly useless objectoriented environment boost::variant gives object oriented approach solving practical union problems interface designed allow access variant unless using proper type visitor pattern example provide gives compile time errors union extended include type didnt expect useful think ive used simply large interfaces class some_xml_class public: void set_propertyconst string const string void set_propertyconst string const vectorstring void set_propertyconst string const setstring void set_propertyconst string int void set_super_propertyconst string const string void set_super_propertyconst string const vectorstring void set_super_propertyconst string const setstring void set_super_propertyconst string int verses class some_xml_class public: typedef boost::variantstring vectorstring setstring int property_type void set_propertyconst string const property_type void set_super_propertyconst string const property_type templates could also useful lets say impl long enough didnt want inline 
p782
aVabsolutely valid use unions c depending want change class union dont nesting unions methods use inheritance possible data members might want use anonymous union like this: class color private: union unsigned int intvalue unsigned char argbbytes4 public: unsigned int getintvalue return intvalue 
p783
aVcode would undefined behaviour used way describe c lastwritten member union _active_ one time accessing members like accessing uninitailized variables indepth discussion see thread memberundefined unions maybe used saving space eg implementing variant may used type punning 
p784
asS'217053'
p785
(lp786
Vcannot unset env variables script trying unset environment variables within script script runs fine run env still shows variables set run command cli works variables unset unset env awk f \u005cw print 1 xargs idea run script also idea source etcprofile script doesnt work either need set variables names different paths depending instances users need later edit: ok ended rather elegant whatever solution: script contains: unset env awk f \u005cw print 1egrep v hostnametermshellhistsizessh_clientssh_ttyuserls_colorskdedirmailpathinputrcpwdlanghistignoressh_askpasstestshlvlhomeld_assume_kernellognamessh_connectionlessopenhisttimeformatg_broken_filenames_xargs source env_variable_file thanks 
p787
aVstandard answer basically cant script runs new child process process gets environment cant change parent either set variables unset run script current environment using command source etcprofile way: etcprofile 
p788
aVtried run script work google bit found this: unset usrbinenv egrep \u005cw \u005c egrep vw pwduserlang usrbincut d f1 one actually works sourcing files source etcprofile right way said modify script like unset env awk f print 1 xargs also works think difference running command interactively vs script 
p789
aVuse v unset command rip items environment note end test script may get errors weve unset path cant find programs like id binsh listenv awk f \u005cw print 1 xargs item list echo item item done unset v list item list echo item item done histsize5555 echo histsize source etcprofile echo histsize 
p790
asS'31019176'
p791
(lp792
Vextern storage class variable inside main function get confused static extern storage classes understand wrong code snippet expect printf print value zero build failing error undefined reference expect statement extern int valid c statement includestdioh void main extern int printfd 
p793
aVfunction main extern int declaration definition must defined somewhere includestdioh int definition int main extern int declaration printfd example declaration valid omitted 
p794
aVdeclare variable extern inside function compiler thinks variable defined translation unit defined anywhere else get linker error saying linker cant find variable 
p795
aVsee using extern storage class main compiler use search declaration variable perticular location extern stands compiler variable declared location program local outside scope dont found declaration gives linking error becoz unable found variable declaration 
p796
asS'95890'
p797
(lp798
Vvariables linkage storage specifier someone talks variables storage class specifier talking also often talk variable linkage context 
p799
aVstorage class specifier controls _storage_ _linkage_ variables two concepts different c specifies following specifiers variables: auto extern register static storage storage duration determines long variable live ram three types storage duration: static automatic dynamic _static_ variable declared file scope extern static specifier static storage variable exist long program executing execution time spent create variables _automatic_ variable declared function without extern static specifier automatic storage variable exist executing function return variable longer exist automatic storage typically done stack fast operation create variables simply increment stack pointer size _dynamic_ use malloc new c using dynamic storage storage exist call free delete expensive way create storage system must manage allocation deallocation dynamically linkage linkage specifies see reference variable three types linkage: internal linkage external linkage linkage _no linkage_ variable visible declared typically applies variables declared function _internal linkage_ variable visible functions within file called translation unit inaheaderfilevsasingleheaderfileperclass files know exists _external linkage_ variable visible translation units often thought global variables table describing storage linkage characteristics based specifiers storage class function file specifier scope scope none automatic static linkage external linkage extern static static external linkage external linkage static static static linkage internal linkage auto automatic invalid linkage register automatic invalid linkage 
p800
aVvariable storage classes type specifiers like volatile auto static define howwhere variables saved program execution example variables defined functions usually saved stack means lost function returns using static keyword force compiler put variable data segment memory making variables content persistent calls function register keyword cause compiler try hard possible put variable cpu register useful counters loops etc however guaranteed actually register read type specifiers 
p801
asS'740577'
p802
(lp803
Vsizeof union cc sizeof union cc sizeof largest datatype inside compiler calculate move stack pointer one smaller datatype union active 
p804
aVunion always takes much space largest member doesnt matter currently use union short x int y long long z instance union always take least long long storage _side note_: noted stefano incc740653740653 actual space type union struct class take depend issues alignment compiler didnt go simplicity wanted tell union takes biggest item account important know actual size _does_ depend alignment 
p805
aVnotion active datatype union free read write member union: interpret get therefore sizeof union always sizeof largest datatype 
p806
aVsize least largest composing type concept active type 
p807
aVreally look union container largest datatype inside combined shortcut cast use one smaller members unused space still simply stays unused often see used combination ioctl calls unix ioctl calls pass struct contains union possible responses eg example comes usrincludelinuxifh struct used ioctls configuringquerying state ethernet interface request parameters defines part union actually use: struct ifreq define ifhwaddrlen 6 union char ifrn_nameifnamsiz name eg en0 ifr_ifrn union struct sockaddr ifru_addr struct sockaddr ifru_dstaddr struct sockaddr ifru_broadaddr struct sockaddr ifru_netmask struct sockaddr ifru_hwaddr short ifru_flags int ifru_ivalue int ifru_mtu struct ifmap ifru_map char ifru_slaveifnamsiz fits size char ifru_newnameifnamsiz void ifru_data struct if_settings ifru_settings ifr_ifru 
p808
aV 1 size largest member 2 unions usually make sense inside struct flag indicates active member example: struct one_of_many enum flag flag_short flag_int flag_long_long flag union short x int y long long z 
p809
aVdepends compiler options int main union char all13 int foo record printfd\u005cnsizeofrecordall printfd\u005cnsizeofrecordfoo printfd\u005cnsizeofrecord outputs: 13 4 16 remember correctly depends alignment compiler puts allocated space unless use special option compiler put padding union space edit: gcc need use pragma directive int main pragma packpush 1 union char all13 int foo record pragma packpop printfd\u005cnsizeofrecordall printfd\u005cnsizeofrecordfoo printfd\u005cnsizeofrecord outputs 13 4 13 also see disassemble removed printf clarity 0x00001fd2 main0: push ebp 0x00001fd2 main0: push ebp 0x00001fd3 main1: mov espebp 0x00001fd3 main1: mov espebp 0x00001fd5 main3: push ebx 0x00001fd5 main3: push ebx 0x00001fd6 main4: sub 0x24esp 0x00001fd6 main4: sub 0x24esp 0x00001fd9 main7: call 0x1fde main12 0x00001fd9 main7: call 0x1fde main12 0x00001fde main12: pop ebx 0x00001fde main12: pop ebx 0x00001fdf main13: movl 0xd0x4esp 0x00001fdf main13: movl 0x100x4esp 0x00001fe7 main21: lea 0x1debxeax 0x00001fe7 main21: lea 0x1debxeax 0x00001fed main27: mov eaxesp 0x00001fed main27: mov eaxesp 0x00001ff0 main30: call 0x3005 printf 0x00001ff0 main30: call 0x3005 printf 0x00001ff5 main35: add 0x24esp 0x00001ff5 main35: add 0x24esp 0x00001ff8 main38: pop ebx 0x00001ff8 main38: pop ebx 0x00001ff9 main39: leave 0x00001ff9 main39: leave 0x00001ffa main40: ret 0x00001ffa main40: ret difference main13 compiler allocates stack 0xd instead 0x10 
p810
aVstandard answers questions section 95 c standard section 6523 paragraph 5 c99 standard paragraph 6 c11 standard: union one data members active time value one data members stored union time note: one special guarantee made order simplify use unions: podunion contains several podstructs share common initial sequence 92 object podunion type contains one podstructs permitted inspect common initial sequence podstruct members see 92 size union sufficient contain largest data members data member allocated sole member struct means member share memory region _is_ one member active cant find one store information currently active member somewhere else storing flag addition union example struct integer typeflag union datastore give called discriminated union: union knows type currently active one one common use lexers different tokens depending token different informations store putting line struct show common initial sequence is: struct tokeni int token type tag union struct int line noval struct int line int val intval struct int line struct string val stringval data standard allows access line member thats common initial sequence one exist compiler extensions allow accessing members disregarding one currently value stored allows efficient reinterpretation stored bits different types among members example following may used dissect float variable 2 unsigned shorts: union float_cast unsigned short s2 float f come quite handy writing lowlevel code compiler support extension anyway write code whose results defined certain compiler support use trick 
p811
aV sizeof union cc sizeof largest datatype inside yes size union size biggest member example : includestdioh union un char c int float f double d int main union un u1 printfsizeof union u1 : ld\u005cnsizeofu1 return 0 output : sizeof union u1 : 8 sizeof double d : 8 biggest member double size 8 sizeof correctly told size union indeed 8 compiler calculate move stack pointer one smaller datatype union active internally handles compiler suppose accessing one data member union cannot access data member since access single data member union data member shares memory using union save lot valuable space 
p812
asS'10750098'
p813
(lp814
Vconfused whether java uses call value call reference object reference passed  public class program1 public static void mainstring args javautilvector vcnew javautilvector vcadd111 vcadd222 functioncallvc vcadd333 systemoutprintlnvc public static void functioncalljavautilvector vc vcnull output program 111222333 run following program output 333 confused pass reference works whether call value call reference public class program1 public static void mainstring args javautilvector vcnew javautilvector vcadd111 vcadd222 functioncallvc vcadd333 systemoutprintlnvc public static void functioncalljavautilvector vc vcremoveallelements 
p815
aVjava uses object references argument reference value call value value reference objects 
p816
aVvc new variable contains reference vector used call method changing null affect original vector reference copy original vector reference since reference original vector modification vector actually changes original vector java always uses call value value happens reference 
p817
aVpasses _value_ reference shamelessly steal analogy saw posted ago imagine identifier use piece paper address written address points house change house example adding objects vector clearing youre still holding piece paper address still takes house set vector null youre rubbing address article much detail 
p818
aVpass vc reference copy always vc null vc new vector modify reference vc local attribute normal main one didnt change 
p819
aVjava pass reference reference passed value cannot change reference change object pointed reference removeall call acts vector see results however change reference like : vc null vc new vector changes point new null object changes reflected object main 
p820
aVcall value cases put _value_ reference reference methods argument _local_ reference method 
p821
aVjava works withs call value concept stack heap visualized java tries find values variable local workspace found local tries find object heap example class foo int x public void callint x x public static void mainstring args foo foo new foo foox 5 systemoutprintlnfoox foocallfoox systemoutprintlnfoox output program would : 5 5 desciption : main method value x assigned 5 reference foo: call method local variable named xpassed argument workspace value would changed workspace control function returns main method mains workspace value x still 5 example class foo int x public void callint y x public static void mainstring args foo foo new foo foox 5 systemoutprintlnfoox foocallfoox systemoutprintlnfoox output program would : 5 6 desciption : main method value x assigned 5 reference foo: call method local variable named xpassed argument workspace java finds reference call function called value x 5 call method increments value 6 value would changed reference ie foo control function returns main method mains workspace value x 6 printed x foo reference hope would help clear concepts regards sushil jain 
p822
aVjava programming language always uses call value java parameters methods call value pass value cay horstmann garry cornell mentioned famous book core java volume fundamentals java programming language always uses call value means method gets copy parameter values method cannot modify contents parameter variables passed java uses two kinds method parameters: java primitive types java object references looks straight forward simple experiment passing primitive types method becomes obscure comes passing objects method interestingly object reference passed method method gets copy object reference original formal copy refer object therefore within method state object parameter changed following article explains well call value call referencehttp :csfundamentalscomjavaprogrammingjavacallbyvaluecallby referencephp 
p823
aVpassbyvalue actual parameter argument expression fully evaluated resulting value copied location used hold formal parameters value methodfunction execution location typically chunk memory runtime stack application java handles languages could choose parameter storage differently passbyreference formal parameter merely acts alias actual parameter anytime methodfunction uses formal parameter reading writing actually using actual parameter _java strictly passbyvalue_ 
p824
aVjava c always call value term call reference strictly applies c use amp operator formal argument case object references references copied actual formal argument 
p825
aVpass value java means passing copy value passed pass reference java means passing address java arguments always passed value java supports pass value java objects object reference passed value original reference parameter copy refer java object java primitives passed value 
p826
asS'21113919'
p827
(lp828
Vdifference r w fopen fopenmyfile r difference r w open mode read this: r open text file reading w open text file writing truncating existing file zero length creating file exist r open text file update reading writing w open text file update reading writing first truncating file zero length exists creating file exist mean difference open file w file erased first 
p829
aV2 differences unlike r w will: create file already exist first truncate ie delete contents 
p830
aV r read mode r readwrite mode w write mode w readwrite mode file already exists override empty yes file already exists w erase file give empty file 
p831
aVtry codes understand: include stdioh int main file fp fp fopentesttxt w fprintffp testing fprintf\u005cn fputsthis testing fputs\u005cn fp fclosefp include stdioh int main file fp fp fopentesttxt w fclosefp open file testtxt see effect get data written first program erased repeat r see result hope understand 
p832
aVr w read write file however r doesnt delete content file doesnt create new file file doesnt exist whereas w deletes content file creates doesnt exist 
p833
asS'9090098'
p834
(lp835
Vdefine struct c im try make payroll program c beginning program define struct called employeet store information employee together one unit take information put array employeet structures called employees far typedef struct char name char title double gross double tax double net employeet miss wrong thanks guys 
p836
aVfine except want flexible array member char name needs last field structure probably really want pointer char name real array char namesome_size though 
p837
aVchange char name char name initializing use: name new namesizeofarray dont need anymore dont forget delete it: delete name 
p838
aVdeclare char name need give length array going static otherwise declare pointer dynamically create array later struct needs know exactly large cant array unknown size inside 
p839
aVexample struct stu int num char name20 char sex float score 
p840
asS'23345554'
p841
(lp842
Vdifferences initialize define declare variable reading question isthedifferencebetweenadefinitionandadeclaration know differences declaration definition mean definition equals declaration plus initialization 
p843
aV declaration declaration generally refers introduction new name program example _declare_ new function describing signature: void xyz declare incomplete type: class klass struct ztruct last least declare object: int x described c standard §311 as: declaration clause 7 may introduce one names translation unit redeclare names introduced previous declarations definition definition definition previously declared name definition declaration example: int x void xyz class klass struct ztruct enum x y z specifically c standard defines §311 as: declaration definition unless declares function without specifying function\u2019s body 84 contains extern specifier 711 linkagespecification25 75 neither initializer function body declares static data member class definition 92 94 class name declaration 91 opaqueenumdeclaration 72 templateparameter 141 parameterdeclaration 835 function declarator declarator functiondefinition typedef declaration 713 aliasdeclaration 713 using declaration 733 static_assertdeclaration clause 7 attribute declaration clause 7 emptydeclaration clause 7 usingdirective 734 initialization initialization refers assignment value construction time generic object type often form: x c be: xi even: x c11 conclusion mean definition equals declaration plus initialization depends talking talking object example: int x definition without initialization following instead definition initialization: int x 0 certain context doesnt make sense talk initialization definition declaration talking function example _initialization_ mean much answer no: definition automatically mean declaration plus initialization 
p844
aVc least per c11 675: declaration specifies interpretation attributes set identifiers _definition_ identifier declaration identifier that: object causes storage reserved object function includes function body enumeration constant declaration identifier typedef name first declaration identifier per c11 679810: initializer specifies initial value stored object object automatic storage initialized explicitly value indeterminate broadly speaking declaration introduces identifier provides information variable definition declaration allocates storage variable initialization specification initial value stored object necessarily first time explicitly _assign_ value variable value define whether explicitly give value dont explicitly give value variable automatic storage initial value value indeterminate static storage initialized implicitly depending type eg pointer types get initialized null pointers arithmetic types get initialized zero define automatic variable without specifying initial value as: int myfuncvoid int myvar defining therefore also declaring since definitions declarations initializing therefore definition equal declaration plus initialization 
p845
aVmean definition equals declaration plus initialization necessarily declaration might without variable initialized like: void helloworld declaration prototype void helloworld std::cout world\u005cn 
p846
aVdeclaration says thing exists somewhere: int foo function extern int bar variable struct static int baz static member variable definition says thing exists make memory it: int foo function int bar variable int t::baz static member variable initialisation optional point definition objects says initial value thing: int bar 0 variable int t::baz 42 static member variable sometimes possible point declaration instead: struct static int baz 42 \u2026but thats getting complex features 
p847
asS'3993966'
p848
(lp849
Vextern storage class specifier section 71 c standard mentions extern storage class specifier n3126 extern specifier applied names variables functions extern specifier cannot used declaration class members function parameters linkage name declared extern specifier see 35 note: extern keyword also used explicitinstantiations linkagespecifications storage classspecifier contexts \u2014end note understand keyword use context linkage specification unable get grasp use extern storage specifier 1 dont extern names static storage duration 2 answer 1 yes redundancy c compatibility 
p850
aV_really_ storage specifier per se comes variable name much _other_ storage specifiers shut compiler tell linker work 
p851
aVextern _storage class specifier_ fact language grammar extern number effects semantics program depending used doesnt single effect everywhere influences storage duration linkage objects also helps determine whether declarations also definitions eg: int ex1 extern int b ex2 example ex1 ex2 global scope would refer objects static storage duration external linkage c though first would definition tentative definition c second would example extern changed storage duration linkage declared object ex1 ex2 occurred function body would refer object automatic storage duration linkage b would refer object external linkage static storage duration example extern affected meaning declaration linkage storage duration whether definition finally c example effect extern changing linkage internal external const int c 5 static storage duration internal linkage extern const int d 10 static storage duration external linkage 
p852
asS'25128640'
p853
(lp854
Vputchar printing formatted output ive wanted learn c standard library decided implement printf using putchar function id barely started something odd happened id done write loop print verbatim copy format string realized escape sequences \u005cn \u005ct etc already parsed properly output heres minimal code: int my_printfconst char size_t char c 0 c \u005c0 putcharc return 0 int mainvoid my_printfhere\u005ct1\u005cn0\u005cn return 0 expecting literal here\u005ct1\u005cn0\u005cn output instead got: 1 0 idea happening first thought compiler im using gcc trying help preanalyzing format string seems odd since would cause _lot_ problems since would break char array anyone know happening behavior defined standard thank help edit: mafso stated answer replacements done compile time _is_ standard section 511215 standard actual text 
p855
aVescape sequences replaced compile time runtime printf \u005cn string starting _literal_ newline character it\u2019s way put literal newline character string part string printf interprets conversion specification always start sign 0terminator course every character printed literally don\u2019t need anything 
p856
asS'19795505'
p857
(lp858
Vchar data type c c book says char data type memorise numbers ascii characters computer knows refer character number example want print screen value char variable computer knows refer ascii character number refer number thanks advance 
p859
aVcompiler doesnt necessarily handle automatically c handled console output via format specifiers printfthis char:c\u005cn c printfthis int:d\u005cn 3 provide wrong data type argument corresponding format specifier format string get compiler warnings: printfthis char:c\u005cn 1 warning: implicit conversion int char due implicit downcast may get compiler warning depending verbosity level provide argument smaller expected ie: printfthis int:d\u005cn b implicit upcast short format specifier lets compiler know represent data comes printing console also type checking format specifiers corresponding arguments mismatch finally compiler c99 compliant printf convert integer characterliteral equivalent typemismatch: printfthis char:c\u005cn 99 prints c character literal find characternumber mappings here: 
p860
aVgive format printf use: char c c printfc \u005cn c result character c printfd \u005cn c result 99 ascii value character c note never use format d char scanf may destroy stack scanfd \u005cn c never 
p861
aVaccording c programming language _section a42_ meaning identifiers : basic types page 195 objects declared characters char large enough store member execution character set genuine character set stored char object value equivalent integer code character nonnegative therefore following works character set ascii ascii int n 65 equal ascii char c equal 65 ascii printfc d n c print 65 despite wrong order according page 244 standard library formatted output printf functions c format specifier printf following: convert int unsigned char int single character conversion unsigned char 
p862
asS'38111073'
p863
(lp864
Vregister vs auto storage class right im learning storage classes plfvsf4bjg79cz5khtiqhcml2q8j06ofd seems explain thing auto storage class register storage class thing diffrenciated two register storage class stored cpu register diffrences storage classes uses register storage class register keyword thier default c compilers register int x 5 auto int y 3 
p865
aVregister storage class imply object stored register standard says: declaration identifier object storageclass specifier register suggests access object fast possible extent suggestions effective implementationdefined quotation n1570 stdorgjtc1sc22wg14wwwdocsn1570pdf draft iso c standard section 671 paragraph 6 storing object cpu register rather memory one way accomplish one modern compilers least according common wisdom probably better deciding variables stored registers speed using register keyword probably wont anything interfere compilers optimization register also makes illegal take address object even stored memory basically holdover early compilers 1970s didnt perform sophisticated optimizations modern compilers compiler register could significantly improve performance modern compilers believe start assuming variables allocated registers spill memory necessary either variables address needed arent enough registers available 
p866
asS'7025785'
p867
(lp868
Vc file operations: check opened file pointer access mode simple question: check access mode already opened file pointer say function passed already opened file pointer: pseudo code bool pseudofunctionfile ptr insert check readonly access rights read access mode return true file pointer readonly thus write operations permitted return false would use statement check file pointer opened readonly case may without writing file without relying user passing possibly contradicting arguments system windows code::blocks compiler interests code portability crosscompatibility preferred note isnt asking file rights access mode used file pointer selfanswer cannot append separate answer due user rights limitations: better answer another poster includes proper defines earlier suggested appears file pointers _flag defined _iobuf key knowing whether file read mileage may vary though basic concept easily adaptable example code: define read_only_flag 1 bool printflagptrconst char filename const char accessmode file ptr null ptr fopenfilenameaccessmode printfs: d accessmodeptr_flag int isreadonly ptr_flag fcloseptr ptr null isreadonlyread_only_flag read_only_flag printffile read only\u005cn return true printf\u005cn return false different access mode combinations used function produces output of: output: w: 2 r: 1 file read a: 2 wb: 2 rb: 1 file read ab: 2 w: 128 r: 128 a: 128 wb: 128 rb: 128 ab: 128 curious never suggested never used given crosscompatible frontend function simply function name declarations depending platform passing const int sourced given file pointer _flag would quite simple easy solution problem 
p869
aVstandard way achieve 
p870
aVlinux possibly unix systems could use fcntl get access mode file: int get_file_statusfile f int fd filenof return fcntlfd f_getfl note returned value integer combination flags like o_rdonly o_rdwr r w strings see flags sure windows see windowsmingw equivalent fcntlfd f_getfl o_accmode onwindowsmingwwhatistheequivalentoffcntlfdfgetfloaccmode 
p871
aVwarning: answer specific visual studio 2010 stdioh file comes visual studio 2010 defines file type like this: struct _iobuf char _ptr int _cnt char _base int _flag int _file int _charbuf int _bufsiz char _tmpfname typedef struct _iobuf file fopening file rb mode gets value 0x00000001 fopen function flags youre interesed mapped this: r _ioread w _iowrt _iowrt _iorw constants defined stdioh: define _ioread 0x0001 define _iowrt 0x0002 define _iorw 0x0080 underlying file descriptor contains info havent dug yet 
p872
asS'6087729'
p873
(lp874
Vconst c vs const c given code compiles c fails c int main const int x uninitialized const compiles c fails c rationale reason behind change c c 
p875
aVconst keyword introduced c c89 1989 c since creation 1983 backported c c initialization semantics generally different c c although time thing expect cases differences become quite important c really isnt superset c example c cant: goto x int 3 x: putshello world perfectly legal c 
p876
aVsee spec compatibility appendix c16: 716 see also 35 change: const objects must initialized c left uninitialized c rationale: const object cannot assigned must initialized hold useful value effect original feature: deletion semantically welldefined feature difficulty converting: semantic transformation widely used: seldom 
p877
aViso standard says 85 dclinit paragraph 9 initializer specified object object possibly cvqualified nonpod class type array thereof object shall defaultinitialized object constqualified type underlying class type shall userdeclared default constructor try example modifying this: int main unless explicitly declared extern const object external linkage must initialized extern const int x return 0 get compiled self explains need enforcing error c declaring const vars without initializing extern linkage use coder must added mistake 
p878
aVnote legitimate use uninitialized constqualified object automatic storage duration: address taken used unique key labeling recursion levels recursive function somewhat obscure worth noting c makes use efficient c requires waste time code size initializing theory compiler could perhaps determine value never used optimize initialization since youre passing around pointer would rather difficult prove 
p879
asS'2278700'
p880
(lp881
Vdifference call reference call value  possible duplicate: difference value parameter reference parameter parameterandreferenceparameter difference call reference call value 
p882
aVarguments passed function two types namely 1\u005c values passed 2\u005c address passed first type refers call value second type refers call reference instance consider program1 main int x50 y70 interchangexy printf\u201cxd yd\u201dxy interchangex1y1 int x1y1 int z1 z1x1 x1y1 y1z1 printf\u201cx1d y1d\u201dx1y1 value function interchange passed value consider program2 main int x50 y70 interchangexy printf\u201cxd yd\u201dxy interchangex1y1 int x1y1 int z1 z1x1 x1y1 y1z1 printf\u201cxd yd\u201dx1y1 function called reference words address passed using symbol amp value accessed using symbol main difference seen analyzing output program1 program2 output program1 call value x170 y150 x50 y70 output program2 call reference x70 y50 x70 y50 case call value value passed function named interchange value got interchanged got printed x170 y150 since values returned back therefore original values x y main function namely x50 y70 got printed 
p883
aV call value: 1 2 3 4 5 6 7 void foo int x cout x endl x 4 int somevar 5 foo somevar value 5 pushed onto stack foo called inside foo 5 popped stack output x 4 modifies stack copy thrown away function returns 1 2 3 4 5 6 7 void foo int x cout x endl x 4 int somevar 5 foo somevar address somevar pushed onto stack foo called inside foo address popped stack integer stored address output x 4 modifies memory referred address means foo returns somevar value 4 contrast code 1 2 3 4 5 6 7 void foo int x cout x endl x 4 int somevar 5 foo somevar code exact thing reference example syntax bit different: note somevar foo called note x foo refer integer value 
p884
aVc call reference closest get taking address passing copy address value see c call reference passes reference object alias original object generally implemented objects address though thats guaranteed call value means taking value sort passing copy value function basic difference pass parameter value function receives _copy_ original object cant anything affect original object pass reference gets reference original object access original object copy unless const reference modify original object one example 
p885
aVbriefly _call reference_ function modify arguments: def fx: x : x 1 printx x : 1 fx x 2 printx call reference print 2 twice _call value_ function receives copy argument passed modifications dont get seen caller fx defined call value would be: x : 1 fx x 1 caller printx inside fx print call would print 2 modifies copy x f got caller x still one second print prints 1 
p886
aVcall reference get instance variable changing parameters function case variable change call method call value get copy instance case changes parameter variable influence variable call method 
p887
asS'32535793'
p888
(lp889
Vextern storage class works differently functions following snippet works fine extern int int int main return 0 got declared defined since one definition thats perfectly fine int main extern int int return 0 one gives following error newcpp: function \u2018int main\u2019: newcpp:5:6: error: redeclaration \u2018int i\u2019 int newcpp:4:13: note: previous declaration \u2018int i\u2019 extern int whats problem also single definition 
p890
aVsecond case two declarations one scope one says variable defined outside function says variable defined inside function without new scope isnt allowed rules different inside outside functions note could use: include stdioh int 21 int mainvoid extern int 37 int 57 printfd\u005cn printfd\u005cn return 0 compiles ok unless include wshadow compilation options using gcc clang produces 57 37 output pointed coffeeandcode comment classworksdifferentlyin functions32535916noredirect1comment52929867_32535916 see also use extern share variables source files sharevariablesbetweensourcefilesinc14333871433387 
p891
aVunderstand difference need get familiar concept called _tentative definition_ c quote c standard: c11 draft §692 external object definitions declaration identifier object file scope without initializer without storageclass specifier storageclass specifier static constitutes tentative definition translation unit contains one tentative definitions identifier translation unit contains external definition identifier behavior exactly translation unit contains file scope declaration identifier composite type end translation unit initializer equal 0 first snippet tentative definition many tentative definitions object want one definition allowed: int tentative definition int tentative definition int tentative definition int mainvoid return 0 valid external linkage tentatively defined defined somewhere translation unit thatll actual definition theres definition found translation unit becomes full definition defined like: int 0 int mainvoid return 0 second snippet int _not_ tentative definition objects external linkage defined tentatively second snippet declaration extern int says defined elsewhere external linkage next line int says defined linkage local automatic variables linkage _not_ tentative definition theres conflict definition hence first one snippet fine second isnt 
p892
asS'35152305'
p893
(lp894
Vassign string argc argv writing user validation program sucessful login providing shell like prompt: int main int argc char argv char username malloc50 char passwd malloc32 char command200 printfenter username: scanfs username printf\u005cn printfenter password: get_passwdpasswd user defined function taking password without echoing authentication module called int success authenticate_userusername passwd successful authentication user print like: printftest @ username look user working programs terminal user input command string getscommand main problem tried using strtok g_shell_parse_argv getting desired result return 0 team members written program action based command string parsing conveyed parse argc argv variable like mainint argc int argv function signatures formal variable c library best practice hint sample proceed finally parse string argc argv help highly appreciated thanks 
p895
aV command line argument use int mainint argc char argv code like int mainint argc char argv remaining code int success authenticate_userargv1 argv2 example run program like demo username password demo abhijatya 1234 argv0 demo argv1 usernameabhijatya argv2 password1234 
p896
aVfirst things first 1how compile run program 2did even try understand argc argv mean 3why need argc argv ready use scanf answer questions say things: 1the argc arvg paramenters must used like int mainint argc char argvor argv arguments give program run cmdshell environmentlike use command shell like ls l main program ls argument l argument passed program moment run program runs 2you use argc argv kind program use 2 variables password account set uphere sampleint mainchar password20 account20 printfenter acc:scanf accountprintf\u005cnenter passwd:scanf spassword 
p897
asS'4810664'
p898
(lp899
Vuse arrays c c inherited arrays c used virtually everywhere c provides abstractions easier use less errorprone std::vectort since c98 std::arrayt n c11 arise quite often c however read legacy code interact library written c firm grasp arrays work faq split five parts: 1 arrays type level accessing elements 2 array creation initialization 3 assignment parameter passing 4 multidimensional arrays arrays pointers 5 common pitfalls using arrays feel something important missing faq write answer link additional part following text array means c array class template std::array basic knowledge c declarator syntax assumed note manual usage new delete demonstrated extremely dangerous face exceptions topic another faq _note: meant entry stack overflows c faq critique idea providing faq form posting meta started upafaqforthectag would place answers question monitored c chatroom started first place answer likely get read came idea_ 
p900
aV arrays type level array type denoted tn _element type_ n positive _size_ number elements array array type product type element type size one ingredients differ get distinct type: include type_traits static_assertstd::is_sameint8 float8::value distinct element type static_assertstd::is_sameint8 int9::value distinct size note size part type array types different size incompatible types absolutely nothing sizeoftn equivalent n sizeoft arraytopointer decay connection tn tm types implicitly _converted_ result conversion pointer first element array anywhere required provide tn compiler silently provide pointer: the_actual_array: int8 pointer_to_the_first_element int conversion known arraytopointer decay major source confusion size array lost process since longer part type pro: forgetting size array type level allows pointer point first element array _any_ size con: given pointer first element array way detect large array exactly pointer points relative bounds array pointers extremely stupid arrays pointers compiler silently generate pointer first element array whenever deemed useful whenever operation would fail array succeed pointer conversion array pointer trivial since resulting pointer _value_ simply address array note pointer _not_ stored part array anywhere else memory array pointer static_assertstd::is_sameint8 int::value array pointer one important context array _not_ decay pointer first element operator applied case operator yields pointer _entire_ array pointer first element although case _values_ addresses pointer first element array pointer entire array completely distinct types: static_assertstd::is_sameint int8::value distinct element type following ascii art explains distinction: int8 pointer_to_the_first_element int pointer_to_the_entire_array int8 note pointer first element points single integer depicted small box whereas pointer entire array points array 8 integers depicted large box situation arises classes maybe obvious pointer object pointer first data member _value_ address yet completely distinct types unfamiliar c declarator syntax parenthesis type int8 essential: int8 pointer array 8 integers int8 array 8 pointers element type int accessing elements c provides two syntactic variations access individual elements array neither superior familiarize pointer arithmetic given pointer p first element array expression pi yields pointer ith element array dereferencing pointer afterwards one access individual elements: std::cout x3 x7 std::endl x denotes _array_ arraytopointer decay kick adding array integer meaningless plus operation arrays adding pointer integer makes sense: x: int8 x0 x3 x7 int note implicitly generated pointer name wrote x0 order identify hand x denotes _pointer_ first element array arraytopointer decay necessary pointer going added already exists: int8 x: x3 x7 int note depicted case x pointer _variable_ discernible small box next x could well result function returning pointer expression type indexing operator since syntax xi bit clumsy c provides alternative syntax xi: std::cout x3 x7 std::endl due fact addition commutative following code exactly same: std::cout 3x 7x std::endl definition indexing operator leads following interesting equivalence: xi xi xi however x0 generally _not_ equivalent x former pointer latter array context triggers arraytopointer decay x x0 used interchangeably example: p array0 rewritten array0 decay happens due addition q array decay happens due assignment first line compiler detects assignment pointer pointer trivially succeeds second line detects assignment _array_ pointer since meaningless _pointer_ pointer assignment makes sense arraytopointer decay kicks usual ranges array type tn n elements indexed 0 n1 element n yet support halfopen ranges beginning _inclusive_ end _exclusive_ c allows computation pointer nonexistent nth element illegal dereference pointer: x: int8 x0 x8 int example want sort array following would work equally well: std::sortx 0 x n std::sortx0 x0 n note illegal provide xn second argument since equivalent xn subexpression xn technically invokes undefined behavior c c99 also note could simply provide x first argument little terse taste also makes template argument deduction bit harder compiler case first argument array second argument pointer arraytopointer decay kicks 
p901
aV assignment particular reason arrays cannot assigned one another use std::copy instead: include algorithm int a8 2 3 5 7 11 13 17 19 int b8 std::copya 0 8 b flexible true array assignment could provide possible copy slices larger arrays smaller arrays std::copy usually specialized primitive types give maximum performance unlikely std::memcpy performs better doubt measure although cannot assign arrays directly _can_ assign structs classes _contain_ array members array members copied memberwise assignment operator provided default compiler define assignment operator manually struct class types must fall back manual copying array members parameter passing arrays cannot passed value either pass pointer reference pass pointer since arrays cannot passed value usually pointer first element passed value instead often called pass pointer since size array retrievable via pointer pass second parameter indicating size array classic c solution second pointer pointing last element array c iterator solution: include numeric include cstddef int sumconst int p std::size_t n return std::accumulatep p n 0 int sumconst int p const int q return std::accumulatep q 0 syntactic alternative also declare parameters p means exact thing p context parameter lists only: int sumconst int p std::size_t n return std::accumulatep p n 0 think compiler rewriting p p context parameter lists special rule partly responsible whole confusion arrays pointers every context declaring something array pointer makes _huge_ difference unfortunately also provide size array parameter silently ignored compiler following three signatures exactly equivalent indicated compiler errors: int sumconst int p std::size_t n error: redefinition int sumconst int size_t int sumconst int p std::size_t n error: redefinition int sumconst int size_t int sumconst int p8 std::size_t n 8 meaning pass reference arrays also passed reference: int sumconst int a8 return std::accumulatea 0 8 0 case array size significant since writing function accepts arrays exactly 8 elements little use programmers usually write functions templates: template std::size_t n int sumconst int return std::accumulatea 0 n 0 note call function template actual array integers pointer integer size array automatically inferred every size n different function instantiated template also write quite useful abstract element type size 
p902
aVprogrammers often confuse multidimensional arrays arrays pointers multidimensional arrays programmers familiar named multidimensional arrays many unaware fact multidimensional array also created anonymously multidimensional arrays often referred arrays arrays _true_ multidimensional arrays named multidimensional arrays using named multidimensional arrays _all_ dimensions must known compile time: int h read_int int w read_int int connect_four67 okay int connect_fourh7 iso c forbids variable length array int connect_four6w iso c forbids variable length array int connect_fourhw iso c forbids variable length array named multidimensional array looks like memory: connect_four: note 2d grids merely helpful visualizations point view c memory flat sequence bytes elements multidimensional array stored rowmajor order connect_four06 connect_four10 neighbors memory fact connect_four07 connect_four10 denote element means take multidimensional arrays treat large onedimensional arrays: int p connect_four00 int q p 42 some_int_sequence_algorithmp q anonymous multidimensional arrays anonymous multidimensional arrays dimensions _except first_ must known compile time: int p7 new int67 okay int p7 new inth7 okay int pw new int6w iso c forbids variable length array int pw new inthw iso c forbids variable length array anonymous multidimensional array looks like memory: p: note array still allocated single block memory arrays pointers overcome restriction fixed width introducing another level indirection named arrays pointers named array five pointers initialized anonymous arrays different lengths: int triangle5 int 0 5 trianglei new int5 int 0 5 delete trianglei looks like memory: triangle: since line allocated individually viewing 2d arrays 1d arrays work anymore anonymous arrays pointers anonymous array 5 number pointers initialized anonymous arrays different lengths: int n calculate_five number int p new intn int 0 n pi new intn int 0 n delete pi delete p note extra delete looks like memory: p: conversions arraytopointer decay naturally extends arrays arrays arrays pointers: int array_of_arrays67 int pointer_to_array7 array_of_arrays int array_of_pointers6 int pointer_to_pointer array_of_pointers however implicit conversion thw implicit conversion exist result would pointer first element array h pointers pointing first element line original 2d array pointer array exist anywhere memory yet want conversion must create fill required pointer array manually: int connect_four67 int p new int6 int 0 6 pi connect_fouri delete p note generates view original multidimensional array need copy instead must create extra arrays copy data yourself: int connect_four67 int p new int6 int 0 6 pi new int7 std::copyconnect_fouri connect_fouri 1 pi int 0 6 delete pi delete p 
p903
aV array creation initialization kind c object arrays stored either directly named variables size must compiletime constant c support vlas stored anonymously heap accessed indirectly via pointers size computed runtime automatic arrays automatic arrays arrays living stack created time flow control passes definition nonstatic local array variable: void foo int automatic_array8 initialization performed ascending order note initial values depend element type t: pod otherwise defaultconstructor initializes elements provides accessible defaultconstructor program compile alternatively initial values explicitly specified _array initializer_ commaseparated list surrounded curly brackets: int primes8 2 3 5 7 11 13 17 19 since case number elements array initializer equal size array specifying size manually redundant automatically deduced compiler: int primes 2 3 5 7 11 13 17 19 size 8 deduced also possible specify size provide shorter array initializer: int fibonacci50 0 1 1 47 trailing zeros deduced case remaining elements zero initialized allows empty array initializer elements zeroinitialized whereas c89 least one value required also note array initializers used _initialize_ arrays cannot later used assignments static arrays static arrays arrays living data segment local array variables defined static keyword array variables namespace scope global variables: int global_static_array8 void foo static int local_static_array8 note variables namespace scope implicitly static adding static keyword definition completely different deprecated meaning static arrays behave differently automatic arrays: static arrays without array initializer zeroinitialized prior potential initialization static pod arrays initialized _exactly once_ initial values _typically_ baked executable case initialization cost runtime always spaceefficient solution however required standard static nonpod arrays initialized _first time_ flow control passes definition case local static arrays may never happen function never called none specific arrays rules apply equally well kinds static objects array data members array data members created owning object created unfortunately c03 provides means initialize arrays member initializer list initialization must faked assignments: class foo int primes8 public: foo primes0 2 primes1 3 primes2 5 alternatively define automatic array constructor body copy elements over: class foo int primes8 public: foo int local_array 2 3 5 7 11 13 17 19 std::copylocal_array 0 local_array 8 primes 0 c0x arrays _can_ initialized member initializer list thanks uniform initialization class foo int primes8 public: foo : primes 2 3 5 7 11 13 17 19 solution works element types default constructor dynamic arrays dynamic arrays names hence means accessing via pointers names refer anonymous arrays c anonymous arrays created via malloc c anonymous arrays created using new tsize syntax returns pointer first element anonymous array: std::size_t size compute_size_at_runtime int p new intsize following ascii art depicts memory layout size computed 8 runtime: anonymous p: int obviously anonymous arrays require memory named arrays due extra pointer must stored separately also additional overhead free store note _no_ arraytopointer decay going although evaluating new intsize fact create _array_ integers result expression new intsize _already_ pointer single integer first element _not_ array integers pointer array integers unknown size would impossible static type system requires array sizes compiletime constants hence annotate anonymous array static type information picture concerning default values elements anonymous arrays behave similar automatic arrays normally anonymous pod arrays initialized special syntax triggers valueinitialization: int p new intsome_computed_size note trailing pair parenthesis right semicolon c0x simplifies rules allows specifying initial values anonymous arrays thanks uniform initialization: int p new int8 2 3 5 7 11 13 17 19 done using anonymous array release back system: delete p must release anonymous array exactly never touch afterwards releasing results memory leak generally depending element type resource leak trying release multiple times results undefined behavior using nonarray form delete free instead delete release array also undefined behavior 
p904
aV 5\u005c common pitfalls using arrays 51 pitfall: trusting typeunsafe linking ok youve told found globals namespace scope variables accessed outside translation unit evil\u2122 know truly evil\u2122 consider program consisting two files maincpp numberscpp: maincpp include iostream extern int numbers int main using namespace std int 0 42 cout 0 : numbersi cout endl numberscpp int numbers42 1 2 3 4 5 6 7 8 9 windows 7 compiles links fine mingw g 441 visual c 100 since types dont match program crashes run windows 7 crash dialog intheformal explanation: program undefined behavior ub instead crashing therefore hang perhaps nothing send threating emails presidents usa russia india china switzerland make nasal daemons fly nose inpractice explanation: maincpp array treated pointer placed address array 32bit executable means first int value array treated pointer ie maincpp numbers variable contains appears contain int1 causes program access memory bottom address space conventionally reserved trapcausing result: get crash compilers fully within rights diagnose error c11 §3510 says requirement compatible types declarations n3290 §3510 violation rule type identity require diagnostic paragraph details variation allowed: \u2026 declarations array object specify array types differ presence absence major array bound 834 allowed variation include declaring name array one translation unit pointer another translation unit 52 pitfall: premature optimization memset amp _not written yet_ 53 pitfall: using c idiom get number elements deep c experience natural write \u2026 define n_items array sizeof array sizeof array0 since array decays pointer first element needed expression sizeofasizeofa0 also written sizeofasizeofa means matter written c idiom finding number elements array main pitfall: c idiom typesafe example code \u2026 include stdioh define n_items array sizeof array sizeof array void display int const a7 int const n n_items oops printf d elements\u005cn n int main int const moohaha 1 2 3 4 5 6 7 printf d elements calling display\u005cn n_items moohaha display moohaha passes pointer n_items therefore likely produces wrong result compiled 32bit executable windows 7 produces \u2026 7 elements calling display 1 elements 1 compiler rewrites int const a7 int const 2 compiler rewrites int const int const 3 n_items therefore invoked pointer 4 32bit executable sizeofarray size pointer 4 5 sizeofarray equivalent sizeofint 32bit executable also 4 order detect error run time \u2026 include asserth include typeinfo define n_items array \u005c assert \u005c n_items requires actual array argument \u005c typeid array typeid array \u005c \u005c sizeof array sizeof array \u005c 7 elements calling display assertion failed: n_items requires actual array argument typeid typeid ampa file runtime_detect ioncpp line 16 application requested runtime terminate unusual way please contact applications support team information runtime error detection better detection wastes little processor time perhaps much programmer time better detection compile time youre happy support arrays local types c98 that: include stddefh typedef ptrdiff_t size template class type size n size n_items type n return n define n_items array n_items array compiling definition substituted first complete program g got \u2026 m:\u005ccount g compile_time_detectioncpp compile_time_detectioncpp: function void displayconst int: compile_time_detectioncpp:14: error: matching function call n_itemsconst intamp m:\u005ccount _ works: array passed _by reference_ n_items decay pointer first element function return number elements specified type c11 use also arrays local type type safe c idiom finding number elements array 54 c11 amp c14 pitfall: using constexpr array size function c11 later natural youll see dangerous replace c03 function typedef ptrdiff_t size template class type size n size n_items type n return n using size ptrdiff_t template class type size n constexpr auto n_items type n size return n significant change use constexpr allows function produce compile time constant example contrast c03 function compile time constant used declare array size another: example 1 void foo int const x 3 1 4 1 5 9 2 6 5 4 constexpr size n n_items x int yn using y consider code using constexpr version: example 2 template class collection void foo collection const c constexpr int n n_items c c14 use c auto main int int x42 foo x pitfall: july 2015 compiles mingw64 510 pedanticerrors testing online compilers gccgodboltorg 32 clang 33 341 350 351 36 rc1 37 experimental important windows platform compile visual c 2015 reason c11c14 statement use references constexpr expressions: c11 c14 5192 nine_th_ dash _conditionalexpression_ e _core constant expression_ unless evaluation e following rules abstract machine 19 would evaluate one following expressions: \u22ee _idexpression_ refers variable data member reference type unless reference preceding initialization either initialized constant expression nonstatic data member object whose lifetime began within evaluation e one always write verbose example 3 limited using size ptrdiff_t template class collection void foo collection const c constexpr size n std::extent decltype c ::value use c \u2026 fails collection raw array deal collections nonarrays one needs overloadability n_items function also compile time use one needs compile time representation array size classic c03 solution works fine also c11 c14 let function report result value via function result _type_ example like this: example 4 ok ideal portable safe include array include stddefh using size ptrdiff_t template size n struct size_carrier char sizern template class type size n auto static_n_items type n size_carriern implementation used compile time template class type size_t n size_t g auto static_n_items std::arraytype n const size_carriern implementation used compile time define static_n_items c \u005c static_castsize sizeof static_n_items c sizer template class collection void foo collection const c constexpr size n static_n_items c use c void c auto main int int x42 std::arrayint 43 y foo x foo y choice return type static_n_items: code doesnt use std::integral_constant std::integral_constant result represented directly constexpr value reintroducing original problem instead size_carrier class one let function directly return reference array however everybody familiar syntax naming: part solution constexprinvaliddueto reference problem make choice compile time constant explicit hopefully oopstherewasareferenceinvolvedinyourconstexpr issue fixed c17 macro like static_n_items yields portability eg clang visual c compilers retaining type safety related: macros respect scopes avoid name collisions good idea use name prefix eg mylib_static_n_items 
p905
asS'38085872'
p906
(lp907
Vusing return value one function another c im trying figure issue cant find answer regarding c language issue try use return value another function value isnt coming coming 0 printed int getfinanceamtfloat cost float deposit float financing financing cost deposit printff\u005cn financing return financing goal utilize return value plug equation inside function: int getinterestfloat financing float interestrate float interest interest financing interestrate printff\u005cn interest return interest another function well interestrate came also another function right need sort pointer 
p908
aVsee dont _need_ pointer case theres mismatch _intention_ code financing interest type float function returning return type int may want change function return types float make compatible 
p909
aVreturn type mismatch change return types float run fine 
p910
aVfirst getfinanceamt looks like function declared return int later returning float first update getfinanceamt to: float getfinanceamtfloat cost float deposit float financing financing cost deposit printff\u005cn financing return financing thing going function importantly need actually call first function name give needed parameters declared would recommend taking three parameters getinterest using internally call getfinanceamt float getinterestfloat cost float deposit float interestrate float interest interest getfinanceamtcost deposit interestrate printff\u005cn interest return interest 
p911
aVfixing issue wrong return type two funtions could something like use value returned one argument other: float getfinanceamtfloat cost float deposit return cost deposit float getinterestfloat financing float interestrate return financing interestrate void foo float cost deposit rate code initializes variables printfinterest f\u005cn getinterestgetfinanceamtcost deposit rate 
p912
asS'516237'
p913
(lp914
Vuse typedef c years c mfc programming never felt need use typedef dont really know used use real situations use typedef preferred really cspecific keyword 
p915
aVrealworld uses typedef: providing friendly aliases longwinded templated types providing friendly aliases function pointer types providing local labels types eg: templateclass _t class typedef _t templateclass _t class b void dostuff _t::t _value 
p916
aV template metaprogramming typedef _necessary_ many template metaprogramming whenever class treated compiletime type function typedef used compiletime type value obtain resulting type eg consider simple metafunction converting pointer type base type: templatetypename struct strip_pointer_from templatetypename struct strip_pointer_fromt partial specialisation pointer types typedef type example: type expression strip_pointer_fromdouble::type evaluates double note template metaprogramming commonly used outside library development simplifying function pointer types typedef _helpful_ giving short sharp alias complicated function pointer types: typedef int my_callback_function_typeint double std::string void registercallbackmy_callback_function_type fn 
p917
aVwhenever makes source clearer better read use kind typedef c genericstemplates nodemapping better readuse understand lot dictionaryltstring xmlnodegt imho id recommend templates 
p918
aVuse function pointer hide function pointer declarations typedef void p10 void programmers tell p array 10 pointers function returning void taking pointer another function returns void takes arguments cumbersome syntax nearly indecipherable however simplify considerably using typedef declarations first declare typedef pointer function returning void taking arguments follows: typedef void pfv next declare another typedef pointer function returning void taking pfv based typedef previously declared: typedef void pf_taking_pfv pfv created pf_taking_pfv typedef synonym unwieldy pointer function returning void taking pfv declaring array 10 pointers breeze: pf_taking_pfv p10 
p919
aVbjarnes book states use typedef deal portability problems systems different integer sizes paraphrase machine sizeofint 4 typedef int int32 use int32 everywhere code move implementation c sizeofint 2 change typdef typedef long int32 program still work new implementation 
p920
aVtypedef useful lot situations basically allows create alias type whenif change type rest code could unchanged depends code course example lets say want iter c vector vectorint v forvectorint::const_iterator vbegin vend stuff future may think change vector list type operations without typedef change occurrences vector within code write something like this: typedef vectorint my_vect my_vect v formy_vect::const_iterator vbegin vend stuff change one row code ie typedef vectorint my_vect typedef listint my_vect everything works typedef also saves time complex data structures long write difficult read 
p921
aVone good reason use typedef type something may change example lets say 16bit ints fine indexing dataset foreseeable future youll less 65535 items space constraints significant need good cache performance however chance need use program dataset 65535 items want able easily switch wider integer use typedef change one place 
p922
aVprovide examples things said: stl containers typedef std::mapintfroboz tfrobozmap tfrobozmap frobozzes fortfrobozmap::iterator itfrobozzesbegin itmapend unusual even use typedefs like typedef tfrobozmap::iterator tfrobozmapiter typedef tfrobozmap::const_iterator tfrobozmapciter another example: using shared pointers: class froboz typedef boost::shared_ptrfroboz frobozptr update per comment put last example using shared_ptr \u005c easy: true header material least forward header need forward declaration shared_ptr anyway one declared advantages safe use forward decl put another way: shared_ptr probably use type shared_ptr separating declarations doesnt make much sense yes xyzfwdh pain id use hotspots knowing hotspots hard identify blame c compilelink model container typedefs usually use container variable declared eg locally local var class members actual container instance class member works well actual container type implementation detail causing additional dependency become part _particular_ interface declared together interface used eg frobozmanglerh include frobozh typedef std::mapint froboz tfrobozmap void mangletfrobozmap const frobozzes gets problematic type binding element different interfaces ie type needed multiple headers solutions: declare together contained type suitable containers frequently used type move separate header move separate header make data class actual container implementation detail agree two latter arent great id use get trouble proactively 
p923
aV dont need typedef enum struct typedef enum c1 c2 tmyenum typedef struct int double d tmystruct better written enum tmyenum c1 c2 struct tmystruct int double d correct c 
p924
aVtypedef allows alias complex types gives natural place document type sometimes use documentational purposes also times use array bytes array bytes could mean lot things typedef makes handy define byte array hash32 filecontent make code readable 
p925
aVone another use case use typedef want enable kind container independent code exactly let us say class: class customerlist public: function private: typedef listcustomer customercontainer typedef customercontainer::iterator cciterator code encapsulates internal container implementation using typedef even future list container needs changed vector deque still user customerlist class doesnt need worry exact container implementation hence typedef encapsulates somewhat help us write container independent code 
p926
aVtypedef allows flexibility class want change data type program need change multiple locations need change one occurrence typedef datatype example int double value_type give nay name instead value_type value_type normally standard name u use typedef like value_type i0 int double i0 
p927
asS'8300888'
p928
(lp929
Vcalculating sum integers array dont know im total fool likely long day isnt working want well dont see able 11 numbers entered new number line add array total yet working stopping exit loop even though incrementing ideas int mainvoid int array10 int int sum 0 0 11 scanfd arrayi 0 11 sum arrayi printfd sum return 0 
p930
aVcant add eleven entries tenelement array 
p931
aV10 elements array numbered 0 9 overflowing buffer bets undefined behaviour 
p932
aVguess buffer overrun since forloop reads 11 numbers 11th number gets stored outside array probably overwriting try changing 11 10 loop 
p933
aVyoure storing eleven numbers array size 10 thus youre storing last element bounds invokes undefined behavior reason undefined behavior manifests infinite loop case probably stored array memory system write number array10 bounds said youre overwriting entered number smaller 11 cause loop continue ask input 
p934
aVarray a10 every array starts index number 0 10 elements given positions start 0 9 counting gives 10 elements try this: main int a10 n sum0 printfenter elements scanfdn printfenter elements fori0ini scanfdai i0ini sumsumai fori0ini printf\u005cn ad d ai printf\u005cn sum dsum getch 
p935
aVproblems array declaration defining array size 10 array10 saying program calculate sum 11 elements resulting memory overflows correct program increase size array array11 also wish check recursive approach find sum array elements arrayusingrecursionhtml 
p936
aV int main int a10 int ij int x0 printfenter arrays: scanfdj printfenter nos: fori0iji scanfdai i0iji xxai printfsum arraydx return 0 
p937
aVtry this: void main int array10 int int sum 0 0 11 scanfd arrayi 0 11 sum sum arrayi printfd sum return 0 
p938
asS'15823903'
p939
(lp940
Vcall reference value name im trying understand conceptual difference call reference value name following pseudocode: fooa b c b b c b10 x1 y2 z3 foox y2 z whats x y z foo call b c call reference b c callbyvalueresult b c call byname another scenario: x1 y2 z3 foox y2 x im trying get head start studying upcoming final seemed like good review problem go passbyname definitely foreign 
p941
aVwont change value x y z passbyvalue use function foo basically copies variables x y z variables b c certain actions without changing originals x y z change value would return value something like this: fooa b c b b c b 10 return c x 1 y 2 z 3 z foox y2 x y would z would x1y110 case would 32 
p942
aVpass parameter value copies value within function parameter whatever done variable within function doesnt reflect original variable eg fooa b c b b c b10 x1 y2 z3 foox y2 z printing print unchanged values variables sent value changes made variables foo doesnt affect original print x prints 1 print y prints 2 print z prints 3 send parameters reference copies address variable means whatever variables within function actually done original memory location eg fooa b c b b c b10 x1 y2 z3 foox y2 z print x prints 2 print y prints 5 print z prints 52 pass name passbyname whatispassbynameandhowdoesitworkexactly 
p943
aVvalue changes function actions vanish function finished reference actions indeed changes variables name ive never heard passing x1 change tells function 3 instead 2 etc 
p944
aVjavascript : 1 primitive type variable like stringnumber always pass pass value 2 array object passed pass reference pass value based condition changing value object array new object array pass value object1 item: car array1123 assigning new object arrayyou changing value property old objectso pass value changing property value object array pass reference object1item car array109 changing property value old objectyou assigning new object array old oneso pass reference code function passvarobject1 object2 number1 object1key1 laptop object2 key2: computer number1 number1 1 var object1 key1: car var object2 key2: bike var number1 10 passvarobject1 object2 number1 consolelogobject1key1 consolelogobject2key2 consolelognumber1 output: laptop bike 10 
p945
aVcall value : normal way values actual parameters copied formal parameters call reference : instead parameters addresses passed formal parameters pointing actual parameters call name : like macros whole function definition replaces function call formal parameters another name actual parameters 
p946
asS'23185096'
p947
(lp948
Vsize pointer exactly depend searched online could find discussions find comprehensive description anyone could form answer covers everything size pointer would great help answer least cover following topics 1 size pointer depend 2 feature architecture affects size pointer detail 3 compiler affect size pointer 
p949
aVpointer abstraction provided highlevel language theory could width totally whim compiler practice typically related width memory addresses underlying hardware thats usually efficient thing compiler implement exceptions though example cs pointertomemberfunction direct mapping hardware addresses needs represent two entities function notion type however even leaving aside still complexities example: modern hardware program work _virtual_ memory addresses rather physical addresses may width unless youre writing kernelspace code architectures eg x86 underlying hardware exhibits _segmented_ address space really complicated mostly abstracted away os virtualmemory system youre writing kernelspace code code really old x86s youll deal though current x8664 virtual memory addresses actually 48bits wide x8664 supports 32bit 64bit executables may running inside virtual machine whatever wants relative underlying physical machine 
p950
aVquestion originally tagged c c language agnostic _as languageagnostic question closed broad_ im hoping op revert original versionl im voting close cc question eminently answerable closed broad scope enormously broadened unanswerable changing tagging languageagnostic reopened answerable im answering original question c bits c knowledge sprinkled think current languageagnostic question unanswerable spite one attempted languageagnostic answer 1\u005c size pointer depend minimum required size ordinary data pointer depends maximum number possible memory locations objects pointedto type different functions differentiate _n_ possible locations ceillg2_n_ bits needed hence minimum pointer size depends maximum possible memory size hence minimum pointer size also depends alignment pointedto type archaic machines possibly even extant machines mainframe hardware level addressable unit memory word eg 2 4 bytes word aligned data could addressed small pointers char hence also void needed larger consequently c11 standard §3924 requires object type _cv_ void shall representation alignment requirements _cv_ char member function pointers c akin offsets pointers often larger proper pointers 2\u005c feature architecture affects size pointer detail mainly adressable range memory seen c also worth recalling msdos programming one differentiated _near_ _far_ pointers _near_ pointer offset implied 64k segment memory _far_ pointer twice size combined segment selector offset still modern 32bit pc programming c c pointers rule akin _near_ pointers support _far_ pointers would 6 bytes use pointers necessary use languages assembly language 3\u005c compiler affect size pointer compiler compilation options used principle affect pointer size size prescribed standard eg principle add information aid debugging mentioned language extensions _near_ _far_ pointers since member pointers directly addresses hood much compiler represent large also depend options used 4\u005c different types pointers different eg: difference function pointers pointer pointing basic data type near pointer vs far pointer etc c03 function pointer could converted data pointer vice versa restriction supported machines harvard architecture supported possible different sizes function pointers data pointers eg former _far_ latter _near_ c11 conversion _conditionally_ supported §52108 resulting defect report 195 worth noting posix standard requires support conversion function pointer gt void back eg dlsym function effectively means object pointers functions pointers different eg latter dont support address arithmetic also member pointers different proper pointers akin offsets modern c support near versus far pointers 5\u005c language effect pointer c vs c c doesnt support member pointers degree considered pointers question main goal c able use c libraries directly c standard incorporated c11 §175151 c standard requires compatible pointer representations c supports restricted pointers qualifier restrict c doesnt support however affects knowledge compiler possible values pointer means c compiler might able emit better optimized code 
p951
asS'8257389'
p952
(lp953
Vlinux shell script hi community stackoverflow facing problem shell script designing binsh : clear echo echo main menu echo echo 1 backup word document echo 2 backup spreadsheet echo 3 backup picture echo 4 restore word documents echo 5 restore spreadsheet echo 6 restore picture echo 7 exit echo pause echo n enter menu choice 17: read yourch case yourch 1 echo tar cvf filesdoc wp read 1 echo today date ymdh:m 21 echo press key read 2 echo tar cvf filesxls excel read 2 echo today date ymdh:m 21 echo press key read 3 echo tar cvf filesjpg pics read 3 echo today date ymdh:m 21 echo press key read 4 echo tar xvzf wpdoc read 5 echo tar xvzf excelxls read 6 echo tar xvzf picsjpg read 7 exit 0 echo please press number 1 7 esac done error displays cript: line 21: syntax error near unexpected token cript: line 21: case yourch anyone know pass error basically im trying able back set files file name doc place backup folder restore files folder another folder 
p954
aVruns rhel 4 es using binsh interpreter however case statement execute first match two lines execute options 1 2 3 first one ever executed instead 1 echo tar cvf filesdoc wp read 1 echo today date ymdh:m 21 echo press key read may want something like this: 1 echo tar cvf filesdoc wp echo today date ymdh:m 21 read p press enter continue depending interpreter may also problem case end however first suggestions debugging different problem second long shot edited windows copied paste buffer may also incorrect lineend line 21 possibly fix run dos2unix command script ie dos2unix pathtoscriptsh 
p955
asS'3371886'
p956
(lp957
Vcommand line arguments c program execute values 102030 given command line int mainint argc char argv printf\u005cn printing arguments program \u005cn printf\u005cn total number arguments program dargc whileargc0 printfs argvargc argc return 0 outputs total number arguments program 4null 30 20 10 aout null come 
p958
aVargc total number elements argv array numbered 0 argc 1 printing five values last four valid 
p959
aVway taught count school work c c count 0 1 2 
p960
aVargv0 extent possible supposed something identifies program run argv1 argvargc1 arguments actually entered command line argvargc required null pointer §512212 
p961
aVyoure printing argv4 argv3 argv2 argv1 argv0 instead argv3 argv2 argv1 argv0 basically youve got one error 
p962
aVargc number elements accessed argv0 argvargc1 modify condition accordingly viz print argvargc1 arguments link many things may missed reading hence able understand reason output numbering indexes usually 0 many reasons please check question help understand zero based top 
p963
aVthink fact code whileargc 0 shows know arrays zero indexed problem start argc instead argc1 put another way appear understand argv0 name program argc includes argument says argc 4 means 3 arguments addition program name jerry coffin pointed c requires argvargc null sentinal case knowing arguments 1 argc1 isnt enough belt suspenders 
p964
asS'2229498'
p965
(lp966
Vpassing reference c c support passing variable reference work include stdioh void fint j j int main int 20 int p fp printfi d\u005cn return 0 output gcc stdc99 testc aexe 21 
p967
aV c passbyreference simulated passing address variable pointer dereferencing address within function read write actual variable referred c style passbyreference source: wwwcsstudentsstanfordedu studentsstanfordedusjacctocppinforeferences 
p968
aVexample works passing address variable function manipulates value dereference operator c support reference data types still simulate passingbyreference explicitly passing pointer values example c reference data type less powerful considered safer pointer type inherited c would example adapted use c references void fint j j int main int 20 fi printfi d\u005cn return 0 
p969
aVpassbyreference code using pointers void funcint p passbyaddress passbyreference c wont work c: void funcint ref ref 4 int funca 4 
p970
aVpass reference using pointers c beginning think 
p971
aVyoure passing value pointer method dereferencing get integer pointed 
p972
aVyoure passing pointermemory address variable p function f words passing pointer reference 
p973
aVyoure passing pointeraddress location value like saying heres place data want update 
p974
aVyoure passing int reference youre passing pointertoanint value different syntax meaning 
p975
aVc pass reference use addressof operator used variable case since used pointer variable p need prefix addressof operator would true used parameter: fi also add dereference p see value matches i: printfpd \u005cnp 
p976
aVp pointer variable value address call f pass value p address 
p977
aVpassbyreference c p refers pass p value 
p978
aVshort answer: yes c implement parameter passing reference using pointers implementing parameter passing designers programming languages use three different strategies semantic models: transfer data subprogram receive data subprogram models commonly known mode mode inout mode correspondingly several models devised language designers implement three elementary parameter passing strategies: passbyvalue mode semantics passbyresult mode semantics passby valueresult inout mode semantics passbyreference inout mode semantics passbyname inout mode semantics passbyreference second technique inoutmode parameter passing instead copying data back forth main routine subprogram runtime system sends direct access path data subprogram strategy subprogram direct access data effectively sharing data main routine main advantage technique absolutely efficient time space need duplicate space data copying operations parameter passing implementation c: c implements passbyvalue also passbyreference inout mode semantics using pointers parameters pointer send subprogram actual data copied however pointer access path data main routine subprogram may change data main routine c adopted method algol68 parameter passing implementation c: c also implements passbyreference inout mode semantics using pointers also using special kind pointer called reference type reference type pointers implicitly dereferenced inside subprogram semantics also passby reference key concept passbyreference implements access path data instead copying data subprogram data access paths explicitly dereferenced pointers auto dereferenced pointers reference type info please refer book concepts programming languages robert sebesta 10th ed chapter 9 
p979
aVpassbyreference passbyvalue others stated c language passbyvalue without exception passing pointer parameter mean passbyreference rule following: function able change actual parameters value lets try see differences scalar pointer parameters function scalar variables short program shows passbyvalue using scalar variable param called formal parameter variable function invocation called actual parameter note incrementing param function change variable include stdioh void function2int param printfive received value d\u005cn param param int mainvoid int variable 111 functionvariable printfvariable d\u005cm variable return 0 result ive received value 111 variable111 illusion passbyreference change piece code slightly param pointer include stdioh void function2int param printfive received value d\u005cn param param int mainvoid int variable 111 function2variable printfvariable d\u005cn variable return 0 result ive received value 111 variable112 makes believe parameter passed reference passed value param value address int type value incremented side effect make us think passbyreference function call pointers passedbyvalue showprove fact well maybe try first example scalar variables instead scalar use addresses pointers lets see help include stdioh void function2int param printfparams address d\u005cn param param null int mainvoid int variable 111 int ptr variable function2ptr printfptrs address d\u005cn ptr return 0 result two addresses equal dont worry exact value example result: params address 1846583468 ptrs address 1846583468 opinion proves clearly pointers passedbyvalue otherwise ptr would null function invocation 
p980
asS'7121752'
p981
(lp982
Vopening file c programming xcode trying write file open file read contents file c using xcode file pointer returns value null int mainint argc char argv file fp fpfopeninputtxtr fpnull printferror shows error output could someone help find right place put file inputtxt project 
p983
aVfile would need go current directory program launched configurable groups files pane expand executables pick executable press commandi open info window near bottom general tab select current directory application launched 
p984
aVfile working directory dont right read 
p985
aVgot answer needed store file debug folder xcode runs file debug folder 
p986
aVfile list left right click product executable click show finder paste file want open program 
p987
aVsomewhat related want open file ios get file path via following: nsstring filepath nsbundle mainbundle pathforresource:@jon oftype:@csv file file fopenfilepath cstringusingencoding:nsutf8stringencoding r 
p988
asS'23314975'
p989
(lp990
Vcomments c removed compiled comments c source file removed compiler example visual c gcc 
p991
aVcompiler uses different steps translate sourcecode machine readable code first step lexical analysis phase translates characters tokens token identifier literal value reserved word operator comments whitespace mostly ignored phase used separate different tokens next steps concept comment whitespace yes removed compiling 
p992
asS'15808049'
p993
(lp994
Vuse static local variable get global variable cost c use static storage class external variable serve purpose cost ie occupy storage space data segment executable much better scope external variableif want scope external variable specific file declare variable else wherei see lot flexibility global variable static local variable refer local static variable outside function address variablememory local static variable data segment stack frame functionso unique feature static storage class bring table want know whether static subtle purpose m aware 
p995
aVglobal variable well global accessed anywhere static local variable local scope static lifetime runs across lifetime application however accessed local scope whether scope function block file 
p996
aVdifference _local_ _global_ first foremost scope: access local variables within block theyre defined global variables accessed anywhere consequently one variable given name global scope multiple local static variables different functions static global variables versus extern variables: yes static global variables local translation unit ie c source file theyre defined main concern notion scope storage comes naturally 
p997
aVreason use local static variable scope therefore avoiding bug prone situations since using local static variable youll able refer outside function defined 
p998
aVbasic difference scope variable 1 global variable global entire project lets say project 10 different files 10 files access global variablesee use extern 2 static variablefunction used functionfile within defined cannot used file project yet modify static variabledefined func1 func2 passing reference variable please look example void func2int void func1 static int i1 printfd\u005cn func2i printfd\u005cn int main func1 return 0 see func1 static int cannot directly manipulated func2 pass reference variable still manipulate variable like ordinary variable hope helps 
p999
aVwrite global variable \u201cbetter\u201d scope incorrect bigger scope bigger better bigger may necessary need identifier visible places often case bigger scope means exposure errors global variables muddle semantics routines making harder see program state use change increases probability errors caused failing declare local identifier errors particular identifier external linkage collide identifiers libraries consider happens writing physics application external identifier named acceleration link physics library also external identifier named acceleration program fail external identifiers usually bad design significant limit ability develop maintain complex software human error much programming language semantics limits language prevent errors raw computer add two pointers trash stack pointer accidentally load bytes float integer register good programming languages make errors difficult mistake global variables larger source errors scoping rules helped control good programmers limit scopes identifiers 
p1000
asS'6723266'
p1001
(lp1002
Vinclude stdlibh c function malloc defined stdlibh give error dont include file code works fine little warning question malloc works without header file include please clear concepts include stdioh int main int b p p intmallocsizeofint5 fora0a5apaa9 forb0b5bprintfd pb 
p1003
aVappears thats compilers magic including necessary headers may work compiler suppose microsoft wont necessarily compile elsewherethat includes future versions compiler write standardconforming portable code 
p1004
aVread warning says invalid compiler simply kind clang works might compilers least include supress warning unnecessary warnings annoying program compile warnings treated errors always enable 
p1005
aVc unfortunately dont need predeclaration functions compiler encounters new function create implicit declaration mmmkay used assume type arguments rely feature general write code compiles warnings 
p1006
aVlike many things c reason error isnt generated prototype historical reasons early days people often didnt bother prototyping functions pointers integers usually size integral types smaller integer promoted integer passed parameter floating point rarely used systems programming point changed compiler give error function prototyped would broken many programs would gained widespread acceptance 64 bit addressing entering period integers pointers size programs likely break prototype functions like malloc return pointer gcc always set following options programs: werror wstrictprototypes 
p1007
aVstdlibh general purpose standard header includes functions dynamic memory allocation standard functions example want display message end execution program need go getch functionthis functions reads character keyboard thus giving user time read displayed information getch function requires stdlib header included 
p1008
asS'14533134'
p1009
(lp1010
Vlocal variable allocated heap stack  page says local variables parameters passed allocated stack tried: include stdioh include stdlibh define 2000000 define b 2 typedef struct int aaa st void funst void main st funs error reported compiled run deannotate funs sigsegv caught anyone tell 
p1011
aV local variable allocated heap stack page says local variables parameters passed allocated stack exactly deannotate funs sigsegv caught anyone tell memory stack much limited heap¹ youre allocating 2000000x2000000 array stack passing function likely exceed available stack space causing segmentation fault segmentation fault doesnt happen function call commented first jonathan leffer pointed compiler probably optimize away completely isnt used even didnt might get segfault allocating memory stack means incrementing stack pointer implementations never cause segmenetation fault segmentation fault happen try access allocated memory system realizes youre exceeding bounds stack case entire memory well ¹ though case doesnt make difference slugonamission pointed array takes 16tb thus would exceed available memory heap well 
p1012
aVaddition good example merely pass function argument value usually pass argument reference: include stdioh include stdlibh define 2000000 define b 2 typedef struct int aaa st void funst void main st funs dont think run since requires 4tb memory stack compiled run smoothly funs code since unused variable dumped compiler wasnt declared run time 
p1013
asS'5725296'
p1014
(lp1015
Vdifference sh bash writing shell programs often use binsh binbash usually use bash dont know whats difference whats main difference bash sh need aware programming bash sh 
p1016
aVsh: tldr: bash superset sh elegant syntax functionality safe use bash shebang line almost cases quite ubiquitous modern platforms nb: environments sh _is_ bash check sh version 
p1017
aV sh sh shell command language programming language described posix standard many implementations ksh88 dash bash also considered implementation sh see sh specification implementation binsh symlink hard link actual implementation posix systems bash bash started shcompatible implementation although predates posix standard years time passed acquired many extensions many extensions may change behavior valid posix shell scripts bash valid posix shell rather dialect posix shell language bash supports posix switch makes posixcompliant also tries mimic posix invoked sh sh bash long time binsh used point binbash gnulinux systems result almost become safe ignore difference two started change recently popular examples systems binsh point binbash binbash may even exist are: 1 modern debian ubuntu systems symlink sh dash default 2 busybox 3 bsds general nonlinux systems openbsd uses pdksh descendant korn shell freebsds sh descendant original unix bourne shell solaris sh long time posixcompliant free implementation available heirloom project shebang line ultimately decide one use writing «shebang» line eg binsh use sh whatever happens point binbash use binbash available fail error message course also specify another implementation eg bindash one use scripts prefer sh following reasons: standardized much simpler easier learn portable across posix systems \u2014 even happen bash required sh advantages using bash well features make programming convenient similar programming modern programming languages include things like scoped local variables arrays plain sh minimalistic programming language 
p1018
aVmay want see posix sh command language: _sh _shell command language 
p1019
aVshell interface user os access operating systems services either gui cli command line interface sh bourne shell shell commandline interpreter unixunixlike operating systems provides builtin commands one widely supported shells like bash freeopen kash free scripting language denote interpreter binsh bash bourne shell shell replacement bourne shell bash superset sh bash supports sh scripting language denote interpreter binbash analogy: shell like interface specifications api sh class implements shell interface bash subclass sh 
p1020
aVbinsh may may invoke program binbash sh supports _at least_ features required posix assuming correct implementation may support extensions well bash bourne shell implements features required sh plus bashspecific extensions full set extensions long describe varies new releases differences documented bash manual type info bash read bash features section section 6 current version read current documentation online featureshtml 
p1021
aVanswers generally pointed difference bash posix shell standard however writing portable shell scripts used bash syntax list typical bashisms corresponding pure posix solutions handy list compiled ubuntu switched bash dash default system shell found here: moreover great tool called checkbashisms checks bashisms script comes handy want make sure script portable 
p1022
aVpost unixcom shell features table lists features think would make choose one shell another intended definitive list include every single possible feature every single possible shell feature considered shell version comes operating system available compiled directly standard distribution particular c shell specified available sunos 4 considerable number vendors ship either tcsh enhanced c shell instead dont always make obvious shipping tcsh code: sh csh ksh bash tcsh zsh rc es job control n y y y y y n n aliases n y y y y y n n shell functions y1 n y y n y y y sensible inputoutput redirection y n y y n y y y directory stack n y y y y y f f command history n y y y y y l l command line editing n n y y y y l l vi command line editing n n y y y3 y l l emacs command line editing n n y y y y l l rebindable command line editing n n n y y y l l user name look n y y y y y l l loginlogout watching n n n n y y f f filename completion n y1 y y y y l l username completion n y2 y y y y l l hostname completion n y2 y y y y l l history completion n n n y y y l l fully programmable completion n n n n y y n n mh mailbox completion n n n n4 n6 n6 n n co processes n n y n n y n n builtin artithmetic evaluation n y y y y y n n follow symbolic links invisibly n n y y y y n n periodic command execution n n n n y y n n custom prompt easily n n y y y y y y sun keyboard hack n n n n n y n n spelling correction n n n n y y n n process substitution n n n y2 n y y y underlying syntax sh csh sh sh csh sh rc rc freely available n n n5 y y y y y checks mailbox n y y y y y f f tty sanity checking n n n n y y n n cope large argument lists y n y y y y y y noninteractive startup file n y y7 y7 y y n n nonlogin startup file n y y7 y y y n n avoid user startup files n y n y n y y y specify startup file n n y y n n n n low level command redefinition n n n n n n n y anonymous functions n n n n n n y y list variables n y y n y y y y full signal trap handling y n y y n y y y file clobber ability n y y y y y n f local variables n n y y n y y y lexically scoped variables n n n n n n n y exceptions n n n n n n n y key table y feature done using shell n feature present shell f feature done using shells function mechanism l readline library must linked shell enable feature notes table 1 feature original version since become almost standard 2 feature fairly new often found many versions shell gradually making way standard distribution 3 vi emulation shell thought many incomplete 4 feature standard unofficial patches exist perform 5 version called pdksh freely available full functionality att version 6 done via shells programmable completion mechanism 7 specifying file via env environment variable 
p1023
aVterminal programs put window xterm rxvt konsole kvt gnometerminal nxterm eterm shell program runs terminal shell command interpreter programming language shell simply macro processor executes commands macro processor means functionality text symbols expanded create larger expressions sh vs bash sh shell specific shell command interpreter programming language predecessor bash bash bourneagain shell specific shell command interpreter programming language sh functionality successor sh bash default shell reference material: shell gnuorg: base shell simply macro processor executes commands term macro processor means functionality text symbols expanded create larger expressions unix shell command interpreter programming language command interpreter shell provides user interface rich set gnu utilities programming language features allow utilities combined files containing commands created become commands new commands status system commands directories bin allowing users groups establish custom environments automate common tasks shells may used interactively noninteractively interactive mode accept input typed keyboard executing noninteractively shells execute commands read file shell allows execution gnu commands synchronously asynchronously shell waits synchronous commands complete accepting input asynchronous commands continue execute parallel shell reads executes additional commands redirection constructs permit finegrained control input output commands moreover shell allows control contents commands\u2019 environments shells also provide small set builtin commands builtins implementing functionality impossible inconvenient obtain via separate utilities example cd break continue exec cannot implemented outside shell directly manipulate shell history getopts kill pwd builtins among others could implemented separate utilities convenient use builtin commands shell builtins described subsequent sections executing commands essential power complexity shells due embedded programming languages like high level language shell provides variables flow control constructs quoting functions shells offer features geared specifically interactive use rather augment programming language interactive features include job control command line editing command history aliases features described manual bash gnuorg: bash shell command language interpreter gnu operating system name acronym \u2018bourneagain shell\u2019 pun stephen bourne author direct ancestor current unix shell sh appeared seventh edition bell labs research version unix bash largely compatible sh incorporates useful features korn shell ksh c shell csh intended conformant implementation ieee posix shell tools portion ieee posix specification ieee standard 10031 offers functional improvements sh interactive programming use gnu operating system provides shells including version csh bash default shell like gnu software bash quite portable currently runs nearly every version unix operating systems independentlysupported ports exist msdos os2 windows platforms 
p1024
asS'18793369'
p1025
(lp1026
Vdistribution different shells would command linux find distribution different shells used users 
p1027
aV getent passwd awk f: print 7 sort uniq c getent command dumps password database normally thats file etcpasswd come sources using getent passwd rather reading etcpasswd allows system doesnt getent command find systems equivalent perhaps ypcat passwd system uses nis read etcpasswd file directly youre sure information isnt stored elsewhere awk command grabs 7th colondelimited field line login shell account sort uniq c prints number occurrences shell add sort rn want list decreasing order popularity note carefully lists login shells _all_ accounts system many actually correspond users various ways filter list typically numeric user id 3rd field starts 1000 none 100 reliable 
p1028
aVusually inside etcpasswd answer passwd systems could nisyp ldap etc database see also pam configurable etcnsswitchconf see nsswitchconf5 man page also authorized login shells listed etcshells see shells5 add shells pathname make changeable chsh see chsh1 
p1029
aVrun root give username login shell grep v nologin etcpasswd awk beginfs:print 17 
p1030
aVcould cat etcpasswd awk shell field grep v anything didnt want sort unique like so: cat etcpasswd awk f : print 7 grep v whatever sort uniq c mac doesnt real users results 10 shell 1 binsh 70 usrbinfalse 1 usrsbinuucico presumably system actual users thered binsh binksh bincsh binbash quantities 
p1031
asS'10187510'
p1032
(lp1033
Vunderstanding pointers c trying learn pointers c getting mixed following concepts: char string char string2 main difference between: string2 string b string2 bye 
p1034
aVedit: difference compile undefined behavior youre dereferencing uninitialized pointer also please dont change question drastically posting 
p1035
aVstring read whatever string points char assigning bye makes sense 
p1036
aVc string array characters c string literals like could viewed returning pointer first element character array h e l l o thus char string bye makes sense char string bye doesnt 
p1037
aVchar pointer character literals returns pointer first character string therefore string bye meaningful making string point first character string bye string hand _the character_ pointed string pointer 8bit integer assignment string bye meaningless probably lead segmentation fault memory segment bye stored readonly 
p1038
aVsubtle inferences made answerers missing pov newbie char string declares pointer variable initialized point character array good type match traditionally statement string dereferences pointer variable assigns value pointed location variable declaration done somewhere however since string type char string type charand right side assignment expression pointer value type mismatch fixed two ways depending intent statement: string char expressions sides string h char expressions sides first reassigns string point memory containing sequence characters hello\u005c000 second assignment changes character pointed string char value h admittedly slightly confusing subject _all_ c programmers go little pain learning grasp _the pointer declaration syntax slightly different though related effect text statement_ get practice experience writing compiling expressions involving pointers eventually words make perfect sense 
p1039
aVpictures may help assume following memory map addresses completely arbitrary dont reflect known architecture: item address 0x00 0x01 0x02 0x03 0x00501234 h e l l 0x00501238 o 0x00 bye 0x0050123a b y 0x0050123c e 0x00 0x 0x string 0x80ff0000 0x00 0x50 0x12 0x34 string2 0x80ff0004 0x 0x 0x 0x shows situation declarations bye string literals stored arrays char somewhere memory available lifetime program note attempting modify contents string literals invokes undefined behavior dont want pass string literals pointer expressions like string evaluate addresses string literals arguments functions like scanf strtok fgets etc string pointer char containing address string literal string2 also pointer char value indeterminate 0x represents unknown byte value write string2 bye assign address bye 0x0050123a string2 memory map looks like this: item address 0x00 0x01 0x02 0x03 0x00501234 h e l l 0x00501238 o 0x00 bye 0x0050123a b y 0x0050123c e 0x00 0x 0x string 0x80ff0000 0x00 0x50 0x12 0x34 string2 0x80ff0004 0x00 0x50 0x12 0x3a seems simple enough right lets look statement string2 string couple problems first digression declarations c centered around types _expressions_ objects string2 pointer character access character value must _dereference_ string2 unary operator: char x string2 type _expression_ string2 char declaration becomes char string2 extension type _expression_ string2 char pointer char write string2 string youre attempting assign value type char string expression type char string2 thats going work char char compatible types error shows translation compile time written string2 string expressions type char assignment legal however havent assigned anything string2 yet value indeterminate contains random bit string may may correspond valid writable address attempting deference random potentially invalid pointer value invokes undefined behavior may appear work fine may crash outright may anything problem wont show runtime even better assigned string literal bye string2 run problem described youre trying modify contents string literal thats problem thats going show runtime 
p1040
asS'22527846'
p1041
(lp1042
Vscope lifetime local variables c would like understand difference following two c programs first program: void main int int b 10 ab printfd\u005cn second program: void main int foo printfd\u005cn int foo int b 10 return b cases address local variable b returned assigned know memory pointing accessed b goes scope however compiling two programs receive following warning second program only: warning c4172: returning address local variable temporary get similar warning first program 
p1043
aVfoo function undefined behavior since returns pointer part stack memory used anymore overwritten soon next function call something called b gone scope sure memory still exists probably changed far guaranteed applies first code since also scope b ends closing bracket block b declared edit: get warning first code return anything warning explicitly refers return since compiler may allocate stack space complete function including subblocks may guarantee value overwritten nevertheless undefined behavior may get additional warnings use higher warning level 
p1044
aVfirst code snippet even though explicitly add brackets stack space using region jumps returns code code still uses consecutive memory addresses stack several things happen: 1 compiler push additional variables stack even take code block 2 restricting visibility variable b codeblock less would declare beginning use exact place without 3 value b likely saved register would problem print later speculative second code snippet function call means jump return means: 1 pushing current stack pointer context stack 2 push relevant values function call stack 3 jump function code 4 execute function code 5 restore stack pointer value function call stack pointer restored anything stack lost yet operations stack likely override values think easy see get warning one case expected behavior 
p1045
aValready know b goes scope instance accessing memory illegal dumping thoughts one case throws warning doesnt second case youre returning address variable stored stack memory thus compiler detects issue warns first case however skips compiler checking compiler sees valid initialized address assigned compilers depends many cases intellect coder similar examples depicting first case could char temp3 strcpy temp abc compiler sees temp memory space depends coder intellect many chars going copy memory region 
p1046
aVmaybe related implementation compiler second programthe compiler identify return call warning program return variable scope think easy identify using information ebp register first program compiler needs work achieving 
p1047
aVprograms invoke undefined behaviour statements grouped together within curly braces called block compound statement variable defined block scope block go block scope variable ceases exist illegal access int mainvoid int block scope starts int b 10 b exists block b block scope ends dereferences memory longer scope invokes undefined behaviour printfd\u005cn likewise automatic variables defined function function scope function returns variables allocated stack longer accessible explains warning get second program want return variable function allocate dynamically int mainvoid int foo printfd\u005cn int foovoid int b 10 local variable returning address b longer exists function foo returns return b also signature main one following int mainvoid int mainint argc char argv 
p1048
aVfirst program variable b block level variable visibility inside block lifetime b lifetime function lives upto exit main function since b still allocated space prints value stored b since points b 
p1049
asS'15185801'
p1050
(lp1051
Vcout declared scope c program: includeiostream int main char f char t1 char t2 coutt causes error cout declared scope return 0 g testcpp get error error: cout declared scope 
p1052
aVuse std::cout since cout defined within std namespace alternatively add using std::cout directive 
p1053
aVput following code int main: using namespace std able use cout example: includeiostream using namespace std int main char f char t1 char t2 coutt return 0 take moment read cout going here: 
p1054
asS'31903594'
p1055
(lp1056
Vtypedef struct c vs c gives error c c: typedef struct nodes int data struct node next node gives following error c homeds cpplinkedlistcpp10error: conflicting declaration \u2018typedef struct nodes node\u2019 homeds cpplinkedlistcpp9error: \u2018struct node\u2019 previous declaration \u2018struct node\u2019 build failed: 2 errors 0 warnings 0 minutes 0 seconds work c change this: typedef struct node int data struct node next node dont understand happens want know order execution c c understand 
p1057
aVlets analyse code bit: typedef struct nodes int data struct node next node declares defines struct nodes type two members declares type alias refer node c member declaration struct node next automatically forwarddeclares type called node typedef target node: youre trying give two types name c conflict type called node fact referred struct node second snippet worked since parsing member declaration struct node already exists new type forwarddeclared \u2026 since youre renaming typedef statement c doesnt really care knowing type struct _is_ difference syntax name c11: 7133: given nonclass scope typedef specifier used redefine name type declared scope refer type already refers _ example:_ typedef struct typedef int typedef int typedef _\u2014end example _ c11: 7136: given scope typedef specifier shall used redefine name type declared scope refer different type _ example:_ class complex typedef int complex error: redefinition _\u2014end example _ course c moot write: struct node int data node next need typedefaway _elaboratedtypespecifier_ struct 
p1058
aVc example gave error youre using tag name node havent defined struct node given two choices second one use prefer bit economy: typedef struct node_t int data struct node_t next node_t c c tag names namespace problem using name tag typedef name c allows use either node_t struct node_t refer struct type c search tag names type name declared type name doesnt exist doubledefinition isnt needed doesnt hurt languages explicit struct node_t version required point type completely defined selfreference forward references use struct version prefer header files mostly reduces problems order include directives ps: _does_ work either language see lrios answer pointers c11 standard used enough bilingual even pure c header files unlikely disappear soon simple approach works either language 
p1059
asS'28574670'
p1060
(lp1061
Vdifference function block scope c difference block scope function scope c told variables declared inside curly brackets counts block scope declare function starts closed curly bracket im confused 
p1062
aVc language _function scope_ formal term describes scope _labels_ label visible entire function regardless function declared labels entities unusual property hence need special kind scope nothing else _function scope_ variables cannot function scope variables declared locally always _block scope_ outermost pair envelops entire function also block 
p1063
asS'534375'
p1064
(lp1065
Vpassing values python pass collection like list array another function python make copy pointer 
p1066
aVobject passed copy reference underlying object 
p1067
aVpython passes referencestoobjects value python passes referencestoobjects value like java everything python object sounds simple notice data types seem exhibit passbyvalue characteristics others seem act like passbyreference whats deal important understand mutable immutable objects objects like strings tuples numbers immutable altering inside functionmethod create new instance original instance outside functionmethod changed objects like lists dictionaries mutable means change object inplace therefore altering object inside functionmethod also change original object outside 
p1068
aVreference passed parameter immutable object modifying within method create new instance heres thread subject list2007august453520html 
p1069
aVreference: x 0123 def foox_list: x_list0 1 foox x 1 1 2 3 
p1070
aVwould also recommend looking copy module: python documentation copy help understand underlying issues use perform deep copy 
p1071
aVthing whole referencevalue concept wont fit python python value variable python objects names refer objects call function put name inside parenthesis like this: def funcx: defines function takes argument something funcmyname calling function actual object myname pointing passed name myname inside function another name x given refer object passed modify object inside function mutable cant change outside name pointing happens anothername myname therefore answer question with: pass value values references objects 
p1072
aVplease let give humble example def swapa b: x print idx print ida print idb b print ida b x print idb a0 20 var1 1234 var2 56789 print idvar1 print idvar2 swapvar1 var2 print idvar1 print idvar2 print var1 print var2 produces following result 28329344 var1 28331264 var2 28329344 x 28329344 28331264 b b 28331264 b x 28329344 b return 28329344 var1 28331264 var2 1 2 3 4 20 6 7 8 9 mapping memory addresses 28329344 28331264 var1 var2 b x ab bx b a0 20 0 20 return 1234 20 6 7 8 9 
p1073
aVanswers helpful find need exhibit fine distinction havent seen covered ive proven subsequent cl experiment: 1 immutable object alone cannot changed within function call answers far said much 2 immutable object contained within mutable object reassigned within method call num change immutable number object supports point 1: def incr_numnum: num 1 num 0 num 0 incr_numnum num 0 list0 immutable number object also def incr_listlist: list0 1 list 0 list0 0 incr_listlist list0 1 _so list0 immutable number object change supports point 2 examples number object num not_ immutable number object list0 contained within mutable list object list num 1st example noncontianed number object although wellintended feel @stephen pape quoted similar ones totally correct motivated write answer: objects like strings tuples numbers immutable altering inside functionmethod create new instance original instance outside functionmethod changed 2nd code experiment shows number object list0 altered within method original instance outside function changed 
p1074
asS'5580761'
p1075
(lp1076
Vuse double pointer use pointers pointers double pointer used c anyone explain example know double pointer pointer pointer would need pointer pointer 
p1077
aVone reason want change value pointer passed function function argument require pointer pointer simple words use want preserve retain change memoryallocation assignment even outside function call pass function double pointer arg may good example show basic use: void allocateint p p intmallocsizeofint int main int p null allocatep p 42 freep 
p1078
aVstrings great example uses double pointers string pointer time need point string youll need double pointer 
p1079
aVexample might want make sure free memory something set pointer null afterwards void safefreevoid memory memory freememory memory null call function youd call address pointer void mymemory somecrazyfunctionthatallocatesmemory safefreemymemory mymemory set null attempt reuse obviously wrong 
p1080
aVinstance want random access noncontiguous data p p0 p1 p2 p0 data1 p1 data2 \u005c c p mallocsizeoft n p0 mallocsizeoft p1 mallocsizeoft store pointer p points array pointers pointer points piece data sizeoft big may possible allocate contiguous block ie using malloc sizeoft n bytes 
p1081
aVwant list characters word use char word want list words sentence use char sentence want list sentences monologue use char monologue want list monologues biography use char biography want list biographies biolibrary use char biolibrary want list biolibraries lol use char lol _yes know might best data structures_ 
p1082
aVone thing use constantly array objects need perform lookups binary search different fields keep original array int num_objects object original_array mallocsizeofobjectnum_objects make array sorted pointers objects int compare_object_by_name const void v1 const void v2 object o1 object v1 object o2 object v2 return strcmpo1name o2name object object_ptrs_by_name mallocsizeofobject num_objects int 0 inum_objects object_ptrs_by_namei original_arrayi qsortobject_ptrs_by_name num_objects sizeofobject compare_object_by_name make many sorted pointer arrays need use binary search sorted pointer array access object need data original array objects stay unsorted pointer array sorted specified field 
p1083
aVpointers pointers also come handy handles memory want pass around handle functions relocatable memory basically means function change memory pointed pointer inside handle variable every function object using handle properly point newly relocated allocated memory libraries like todo opaque datatypes datatypes dont worry theyre memory pointed simply pass around handle functions library perform operations memory library functions allocating deallocating memory underthe hood without explicitly worry process memory management handle pointing instance: include stdlibh typedef unsigned char handle_type data_structure library functions would work typedef struct int data_a int data_b int data_c lib_object handle_type lib_create_handle initialize handle memory points array 10 lib_objects handle_type handle mallocsizeofhandle_type handle mallocsizeoflib_object 10 return handle void lib_func_ahandle_type handle something array lib_objects void lib_func_bhandle_type handle something takes input lib_objects makes reallocate memory new objects created first reallocate memory somewhere else slots dont destroy currently allocated slots handle reallochandle sizeoflib_object 20 operation new memory return void lib_func_chandle_type handle something else array lib_objects void lib_free_handlehandle_type handle freehandle freehandle int main create handle memory library functions use handle_type my_handle lib_create_handle something memory lib_func_amy_handle something else handle make point somewhere else thats invisible us standpoint calling function working handle lib_func_bmy_handle something new memory chunk dont think fact memory moved hood still pointed handle lib_func_cmy_handle deallocate handle lib_free_handlemy_handle return 0 hope helps jason 
p1084
aVchar ch stores single string char ch stores array strings code include stdioh include conioh void func char ptr ptr malloc255 allocate memory strcpy ptr stack overflow rocks main char ptr 0 func ptr printfs\u005cn ptr freeptr getch return 0 one simpler example int main char p p char malloc100 p0 char apple write p p1 char banana write p1 cout p endl p increments next string cout p 
p1085
aVsaw good example today blog post imagine structure nodes linked list probably typedef struct node struct node next node want implement remove_if function accepts removal criterion rm one arguments traverses linked list: entry satisfies criterion something like rmentrytrue node removed list end remove_if returns head may different original head linked list may write node prev null curr head curr null node const next currnext rmcurr prev node removed head prevnext next else remove head head next freecurr else prev curr curr next loop message without double pointers maintain prev variable reorganize pointers handle two different cases double pointers actually write head double pointer node curr head curr node entry curr rmentry curr entrynext freeentry else curr entrynext dont need prev directly modify prevnext pointed make things clearer lets follow code little bit removal: 1 entry head: head curr headnext \u005c head points pointer new heading node directly changing heads content new pointer 2 entry head: similarly curr prevnext pointed points entrynext matter case reorganize pointers unified way double pointers 
p1086
aVadding ashas use single pointer example bellow eg alloc1 loose reference memory allocated inside function void alloc2int p p intmallocsizeofint p 10 void alloc1int p p intmallocsizeofint p 10 int main int p alloc1p printfd pvalue undefined alloc2p printfd pwill print 10 freep return 0 
p1087
aVused double pointers today programming something work answer use first time actually use double pointers deal real time encoding frames contained buffers members structures encoder use pointer one structures problem pointer changed point structures another thread order use current structure encoder use double pointer order point pointer modified another thread wasnt obvious first least us take approach lot address printed process : use double pointers work pointers changed places application might also find double pointers must deal hardware returns address 
p1088
aVhopefully following example clear concepts regarding pointers double pointers differences usage common scenarios int setptrint x printfu\u005cnx xmallocsizeofint x1 return x function setptr manipulate x either 1 taking fn arg int x malloc setting value x return x 2 taking arg int malloc set x value value note: cant set general pointer directly without mallocpointer indicates type variable hold address data typenow either define variable give reference declare pointerint xnull allocate memory inside called function pass x reference either case need address memory pointer case pointer initially points null defined like int x points random address need assign valid memory address pointer 1 either need allocate memory malloc int xnull means address 0 need either o following 1 void main int x xmalloc xsome_val void main int x fnx void fnint x xmalloc x5 int fnint x xmalloc x4 return x 2 need point valid memory like defined variable inside function pointer defined int main int int xa fnx printfdx void fnint x x2 cases value pointed x changed inside fn suppose like int main int xnull printfu\u005cnsizeofx printfu\u005cnx xsetptrx x2 printfd\u005cnx return 0 output 4 1 includestdioh void setptrint x printfinside setptr\u005cn printfxu\u005cnx printfxu\u005cnx xmallocsizeofint x1 return x int main int xnull printfxu\u005cnx printfxu\u005cnx int xa printfxu\u005cnx printfau\u005cna printfxu\u005cnx setptrx printfinside main again\u005cn x2 printfxu\u005cnx printfxu\u005cnx printfxd\u005cnx printfad\u005cna return 0 
p1089
aVsimple answer lets say pointer value address want change address could pointer1 pointer2 pointer1 would address pointer2 want function want result persist function done need extra work need new pointer3 point pointer1 pass pointer3 function fun example take look output bellow first understand: include stdioh int main int c 1 int d 2 int e 3 int c int b d int f e int pp pointer pointer printf\u005cn value: x \u005cn printf\u005cn bs value: x \u005cn b printf\u005cn fs value: x \u005cn f printf\u005cn change lets see \u005cn printf\u005cn b \u005cn b printf\u005cn value now: x b seems function lets see \u005cn printf\u005cn cant_changea f \u005cn cant_changea f printf\u005cn value now: x doh b function tricked us \u005cn printf\u005cn lets see pointer pointer solution help us remember pp point \u005cn printf\u005cn changepp f \u005cn changepp f printf\u005cn value now: x yeah f function rocks \u005cn return 0 void cant_changeint x int z x z printf\u005cn value is: x inside function f outside function lets see\u005cn x void changeint x int z x z printf\u005cn value is: x inside function f outside function lets see\u005cn x output: value: bf94c204 bs value: bf94c208 fs value: bf94c20c change lets see b value now: bf94c208 b seems function lets see cant_changea f value is: bf94c20c inside function f outside function lets see value now: bf94c208 doh b function tricked us lets see pointer pointer solution help us remember pp point changepp f value is: bf94c20c inside function f outside function lets see value now: bf94c20c yeah f function rocks 
p1090
aVdouble pointers objective change studenta points using function include stdioh include stdlibh typedef struct person char name person need ponter pointer example: studenta void changeperson x person y x y since x pointer pointer access value: pointer person struct void dontchangeperson x person y x y int main person studenta person mallocsizeofperson studentaname brian person studentb person mallocsizeofperson studentbname erich could done job simple need work want use function job studenta studentb printf1 studenta changed\u005cn studentaname dontchangestudenta studentb printf2 studenta changed\u005cn studentaname changestudenta studentb printf3 studenta changed\u005cn studentaname return 0 output: 1 studenta brian changed 2 studenta brian changed 3 studenta erich changed 
p1091
aVfollowing simple c example shows want use function set pointer point object need pointer pointer otherwise pointer keep reverting null c answer believe c also reference: googlepass value c default arguments c passed value argument passed value arguments value copied functions parameter want set pointer b equal string include iostream include string void function_1std::string std::string b b std::cout b nullptr false void function_2std::string std::string b b std::cout b nullptr false int main std::string ahello std::string bnullptr std::cout b nullptr true function_1a b std::cout b nullptr true function_2a b std::cout b nullptr false output: 10100 happens line function_1a b value main::a address copied parameter std::string function_1::a therefore function_1::a pointer ie memory address string main::a value main::b address memory copied parameter std::string function_1::b therefore 2 addresses memory null pointers line b local variable function_1::b changed equal function_1::a main::a variable main::b unchanged call function_1 main::b still null pointer happens line function_2a b treatment variable same: within function function_2::a address string main::a variable b passed pointer pointer value main::b address pointer main::b copied std::string function_2::b therefore within function_2 dereferencing function_2::b access modify main::b line b actually setting main::b address equal function_2::a address main::a want want use function modify thing object address pointer pass pointer thing thing _actually_ pass cannot modified calling scope local copy made exception parameter reference std::string usually const generally call fx x object able assume f _wont_ modify x x pointer assume f _might_ modify object pointed x 
p1092
asS'5333160'
p1093
(lp1094
Vproblem using fprintf im trying print text file numerous variables yet doesnt work checked verified write correct syntax also checked return value positive therefore know write file however open file empty would happy help code: initiate dynsaledayptr main: file dynsaledayptr createtextfilessale_daytxt create function: file createtextfiles char filename file salefileptrnull ifsalefileptrfopenfilenameanull printffile couldnt opened\u005cn return salefileptr call function textaddsale done function called main: textaddsaledynsaledayptrdynnumofrecords bool textaddsale file dynsaledayptr int dynnumofrecords char id6 char name 50 char pricechar20 char tmp null int price1 dynamicrecord newrecnull scanfsssidnamepricechar newrec dynamicrecord mallocsizeofdynamicrecord newrec null return false tmp charmallocstrlenname1 tmp null free newrec return false strcpytmpname newrecproductname tmp strcpynewrecproductid id newrecproductpriceatoi pricechar fprintfdynsaledayptrd d strlennewrecproductname newrecproductid newrecproductname newrecproductprice0 dynnumofrecordsdynnumofrecords1 return true thanks 
p1095
aVagree @pmg try something like this: file pfile fopenfootxtw pfilenull bad fprintfpfilehello world\u005cn fclosepfile make work first fix whatevers wrong big app 
p1096
aVthought: scanfsssidnamepricechar statement bit dodgy since havent said many bytes go string better use fgets parse string retrieving individual values create better format specifier statement causes memory overwrite rest program could malfunction causing things like describe 
p1097
aVfprintf likely uses buffered output therefore either fflush dynsaledayptr stream better yet print newline file latter added benefit making file contents actually readable also dont forget close stream youre finished writing also render fflush unnecessary 
p1098
aVneed flush stream fflushfile course close stream done fclosefile 
p1099
asS'252552'
p1100
(lp1101
Vneed c unions unions used need 
p1102
aVunions allow data members mutually exclusive share memory quite important memory scarce embedded systems following example: union int int b int c myunion union take space single int rather 3 separate int values user set value set value b would overwrite value since sharing memory location 
p1103
aVunions used want model structs defined hardware devices network protocols youre creating large number objects want save space really dont need 95 time though stick easytodebug code 
p1104
aVunions often used convert binary representations integers floats: union int float f u convert floatingpoint bits integer: uf 314159f printfas integer: 08x\u005cn ui although technically undefined behavior according c standard youre supposed read field recently written act welldefined manner virtually compiler unions also sometimes used implement pseudopolymorphism c giving structure tag indicating type object contains unioning possible types together: enum type ints floats double struct type s_type union int s_ints2 float s_floats2 double s_double void do_somethingstruct switchss_type case ints: something ss_ints break case floats: something ss_floats break case double: something ss_double break allows size struct 12 bytes instead 28 
p1105
aVdifficult think specific occasion youd need type flexible structure perhaps message protocol would sending different sizes messages even probably better programmer friendly alternatives unions bit like variant types languages hold one thing time thing could int float etc depending declare example: typedef union myunion myunion union myunion int myint float myfloat myunion contain int float _depending recently set_ this: myunion u umyint 10 u holds int equal 10 umyfloat 10 u holds float equal 10 longer holds int obviously try printfmyintd umyint youre probably going get error though im unsure specific behaviour size union dictated size largest field case float 
p1106
aVunions great one clever use unions ive seen use defining event example might decide event 32 bits within 32 bits might like designate first 8 bits identifier sender event sometimes deal event whole sometimes dissect compare components unions give flexibility union event unsigned long eventcode unsigned char eventparts4 
p1107
aVheres example union codebase memory paraphrased may exact used store language elements interpreter built example following code: set b times 7 consists following language elements: symbolset variablea symbolto variableb symboltimes constant7 symbol language elements defines define values thus: define elem_sym_set 0 define elem_sym_to 1 define elem_sym_times 2 define elem_sym_fullstop 3 define elem_variable 100 define elem_constant 101 following structure used store element: typedef struct int typ union char str int val telem size element size maximum union 4 bytes type 4 bytes union though typical values _actual_ sizes cepend implementation order create set element would use: telem e etyp elem_sym_set order create variableb element would use: telem e etyp elem_variable estr strdup b make sure free later order create constant7 element would use: telem e etyp elem_constant eval 7 could easily expand include floats float flt rationals struct ratnl int num int denom types basic premise str val contiguous memory actually overlap way getting different view block memory illustrated structure based memory location 0x1010 integers pointers 4 bytes: 0x1010 0x1011 typ 0x1012 0x1013 0x1014 0x1015 str val 0x1016 0x1017 structure would look like this: 0x1010 0x1011 typ 0x1012 0x1013 0x1014 0x1015 str 0x1016 0x1017 0x1018 0x1019 val 0x101a 0x101b 
p1108
aVunions particularly useful embedded programming situations direct access hardwarememory needed trivial example: typedef union struct unsigned char byte1 unsigned char byte2 unsigned char byte3 unsigned char byte4 bytes unsigned int dword hw_register hw_register reg access reg follows: regdword 0x12345678 regbytesbyte3 4 endianness byte order processor architecture course important another useful feature bit modifier: typedef union struct unsigned char b1:1 unsigned char b2:1 unsigned char b3:1 unsigned char b4:1 unsigned char reserved:4 bits unsigned char byte hw_registerb hw_registerb reg code access directly single bit registermemory address: x regbitsb2 
p1109
aVvariant 9e11400698cc26f4932d211828vs8529 used com interfaces two fields type union holding actual value treated depending type field 
p1110
aVused union coding embedded devices c int 16 bit long need retrieve higher 8 bits lower 8 bits need read fromstore eeprom used way: union data int data struct unsigned char higher unsigned char lower parts doesnt require shifting code easier read hand saw old c stl code used union stl allocator interested read sgi stl it: union _obj union _obj _m_free_list_link char _m_client_data1 client sees 
p1111
aV file containing different record types network interface containing different request types take look this: x25 buffer command handling one many possible x25 commands received buffer handled place using union possible structures 
p1112
aVid say makes easier reuse memory might used different ways ie saving memory eg youd like variant struct thats able save short string well number: struct variant int type double number char string 32 bit system would result least 96 bits 12 bytes used instance variant using union reduce size 64 bits 8 bytes: struct variant int type union double number char string value youre able save even youd like add different variable types etc might true similar things casting void pointer union makes lot accessible well type safe savings dont sound massive youre saving one third memory used instances struct 
p1113
aVlots usages grep union usrinclude similar directories cases union wrapped struct one member struct tells element union access example checkout man elf real life implementations basic principle: struct _mydata int which_one union _data int float b char c foo bar switch barwhich_one case integer : access barfooa break case floating : access barfoob break case character: access barfooc break 
p1114
aVschool used unions like this: typedef union unsigned char color4 int new_color u_color used handle colors easily instead using ltlt operators go different index char array 
p1115
aVive seen couple libraries replacement object oriented inheritance eg connection \u005c network usb virtualconnection want connection class either one could write something like: struct connection int type union struct network network struct usb usb struct virtual virtual example use libinfinity: sessionch3e887f0d63bd754c6b5ec232948027cbbf4d61fchbheadl74 
p1116
aVlow level system programming reasonable example iirc ive used unions breakdown hardware registers component bits access 8bit register day component bits forget exact syntax structure would allow control register accessed control_byte via individual bits would important ensure bits map correct register bits given endianness typedef union unsigned char control_byte struct unsigned int nibble : 4 unsigned int nmi : 1 unsigned int enabled : 1 unsigned int fired : 1 unsigned int control : 1 controlregister 
p1117
aVsimple usefull example imagine: uint32_t array2 want access 3rd 4th byte byte chain could uint16_t array1 sadly breaks strict aliasing rules known compilers allow following : union un uint16_t array164 uint32_t array322 technically still violation rules known standards support usage 
p1118
aVmany answers deal casting one type another get use unions types ie parsing serial data stream allow parsing construction _framed_ packet become trivial typedef union uint8 bufferpacket_size packet size large enough entire set fields including payload struct uint8 size uint8 cmd uint8 payloadpayload_size uint8 crc fields packet_t called every time new byte data ready point packets buffer: packet_builderpacketbuffer new_data void packet_builderuint8 buffer uint8 data static uint8 received_bytes 0 range checking etc removed brevity bufferreceived_bytes data received_bytes using struc way adds lots logic relates byte 0 size byte 1 cmd etc void packet_handlerpacket_t packet process fields readable manner ifpacketfieldssize too_big handle error ifpacketfieldscmd cmd_x stuff _edit_ comment endianness struct padding valid great concerns used body code almost entirely embedded software control ends pipe 
p1119
asS'33622787'
p1120
(lp1121
Vpointers considered method calling reference c universitys c programming class professor subsequent book written uses term call pass reference referring pointers c example considered call reference function professor: int sumint int b example considered call value function professor: int sumint int b ive read c doesnt support call reference understanding pointers pass value basically incorrect say pointers cs way passing reference would correct say cannot pass reference c use pointers alternative update 111115 way question originated believe debate terminology stemmed fact im seeing two specific distinctions passbyreference term used mainly today: specific term used languages like c passbyreference term used professor paradigm explain pointers: general term used languages like c developed thus term rewritten reading @haris updated answer makes sense isnt black white 
p1122
aV_you cannot pass reference c use pointers alternative_ yup thats correct elaborate little whatever pass argument c functions passed values whether variables value variable address makes difference sending _when passbyvalue passing value variable function passbyreference passing alias variable function c pass pointer function still passby value copying value pointer address function_ sending value variable value received function changing wont effect original value sending address variable also valuethe address case sent since address variable used change original value example see c code understand real difference callbyvalue callbyreference taken byreferencehtml website program sort two numbers using call reference smallest number output first include iostream using namespace std function prototype call reference void swapfloat x float y int main float b cout enter 2 numbers: endl cin b ifab swapab looks like callbyvalue fact call reference function prototype variable contains value smallest number cout sorted numbers: cout b endl return 0 function definition call reference variables x y values changed void swapfloat x float y swaps x y data calling function float temp temp x x y y temp c example _reference variable_which present c used quote website _a reference alias alternate name existing variable_ _the main use references acting function formal parameters support passbyreference_ different use pointers function parameters _a pointer variable pointer short basically variables store piece data unlike normal variable stores value int double char pointer stores memory address_ essentially one sending address receiving pointers one sending value one sendingreceiving reference variable one sending alias reference update : 11 november 2015 long debate c chatroom comments answers question realized another way look question another perspective lets look simple c code int int p p 123 scenario one use terminology ps value reference case send pointer int p function one argue since reference sent function thus called _passbyreference_ matter terminology way looking scenario would completely disagree argument person completely follows book rules would wrong note: update inspired 
p1123
aVc99 standard emphasis mine: 625 types 20 number derived types constructed object function types follows: \u2014 _pointer typ_e may derived function type object type called _referenced type_ pointer type describes object whose value provides reference entity referenced type pointer type derived referenced type sometimes called \u2018\u2018pointer _t_\u2019\u2019 construction pointer type referenced type called \u2018\u2018pointer type derivation\u2019\u2019 pointer type complete object type based professor said makes sense correct pointer passed value functions pointer points valid entity value provides reference entity 
p1124
aVreference overloaded term general reference simply way refer something pointer refers object pointed passing value pointer object standard way pass reference c c introduced reference types better way express references introduces ambiguity technical english since may use term pass reference refer using reference types pass object reference c context former use imo deprecated however believe former use common contexts eg pure c ambiguity 
p1125
aVprofessor right value copied reference copied reference says value pass int function copied changes copy affect original reference pass int pointer copied modifying original reference array always reference could one billion items array faster say modifying original 
p1126
aVc even pass reference really strictly speaking c always uses pass value simulate pass reference defining functions accept pointers using operator calling compiler essentially simulate pass array function passing pointer instead see question 64 et al another way looking parameter type say int integer passed reference pointer integer passed value fundamentally c nothing truly equivalent formal pass reference cquestionstaggedc2b2b show questions tagged c reference parameters demonstrate pointers passed value lets consider example number swapping using pointers int mainvoid int num1 5 int num2 10 int pnum1 num1 int pnum2 num2 int ptemp printfbefore swap pnum1 d pnum2 d\u005cn pnum1 pnum2 temp pnum1 pnum1 pnum2 pnum2 ptemp printfafter swap pnum1 d pnum2 d\u005cn pnum1 pnum2 instead swapping numbers pointers swapped make function void swapint pnum1 int pnum2 int ptemp pnum1 pnum1 pnum2 pnum2 temp int mainvoid int num1 5 int num2 10 int pnum1 num1 int pnum2 num2 printfbefore swap pnum1 d pnum2 d\u005cn pnum1 pnum2 swappnum1 pnum2 printfafter swap pnum1 d pnum2 d\u005cn pnum1 pnum2 boom swapping tutorials betweencallbyvalueandcallbyreferenceincphpexamplecallby reference mention pointer reference call reference misleading see answer difference passing reference passing value 
p1127
aVc passes arguments value period however pointers _mechanism_ used _effectively_ passing arguments reference like coin used _effectively_ screw driver got right kind screw: screws slit even chosen operate well coins still dont turn coins actual screw drivers c still passes arguments value c references quite limited pointers though implicit conversions cannot become part data structures use looks lot like usual callby reference code would look semantics much catered match needs callbyreference parameters still tangible pure callbyreference implementations like fortran parameters pascal var parameters use references perfectly well outside function call contexts 
p1128
aVlanguages support passbyreference exists means function given something used identify variable know caller called function returns _but stored places wont exist that_ consequently caller know anything done variable result passing function reference done time function returns compare c c programs: c c int x0 int x0 foox fooref x x x bar bar x x bozx bozx c compiler way knowing whether bar might change x foo received unrestricted pointer contrast c compiler knows bar cant possibly change x since foo receives temporary reference called byref net terminology way copy byref survive past point foo returns passing pointers things allows code _do_ things done passbyref semantics passbyref semantics make possible code offer stronger guarantees things _wont_ 
p1129
aVpassing reference concept yes passing value pointer function instance value pointer used reference variable someone else used screwdriver analogy explain wrong refer passing pointers passing reference saying screw screw coin doesnt mean would call coin screw driver would say great analogy come wrong conclusion fact wouldnt claim coin screwdriver would still say screwed screw ie even though pointers c references using _is_ passing reference 
p1130
asS'161788'
p1131
(lp1132
Vdownsides passing structs value c rather passing pointer downsides passing structs value c rather passing pointer struct large obviously performancd aspect copying lots data smaller struct basically passing several values function maybe even interesting used return values c single return values functions often need several simple solution put struct return reasons since might obvious everyone im talking ill give simple example youre programming c youll sooner later start writing functions look like this: void examine_dataconst char ptr size_t len char p size_t l examine_datap l isnt problem issue agree coworker order parameters use convention functions happens want return kind information typically get something like this: char get_datasize_t len len datalen return data size_t len char p get_datalen works fine much problematic return value return value except implementation isnt way tell function get_data isnt allowed look len points nothing makes compiler check value actually returned pointer next month someone else modifies code without understanding properly didnt read documentation gets broken without anyone noticing starts crashing randomly solution propose simple struct struct blob char ptr size_t len examples rewritten like this: void examine_dataconst struct blob data use datatr datalen struct blob ptr len examine_datablob struct blob get_datavoid return struct blob ptr data len len struct blob data get_data reason think people would instinctively make examine_data take pointer struct blob dont see still gets pointer integer much clearer go together get_data case impossible mess way described since input value length must returned length 
p1133
aVid say passing nottoolarge structs value parameters return values perfectly legitimate technique one take care course struct either pod type copy semantics well specified update: sorry c thinking cap recall time legal c return struct function probably changed since would still say valid long compilers expect use support practice 
p1134
aVthink question summed things pretty well one advantage passing structs value memory ownership explicit wondering struct heap responsibility freeing 
p1135
aVsimple solution return error code return value everything else parameter function parameter struct course dont see particular advantage passing value sent pointer passing structure value dangerous need careful passing remember copy constructor c one structure parameters pointer pointer value copied might confusing hard maintain complete answer full credit roddy whynot161845 stack usage another reason pass structure value believe debugging stack overflow real pita replay comment: passing struct pointer meaning entity ownership object full knowledge released passing struct value create hidden references internal data struct pointers another structures etc hard maintain possible 
p1136
aVsmall structs eg point rect passing value perfectly acceptable apart speed one reason careful passingreturning large structs value: stack space lot c programming embedded systems memory premium stack sizes may measured kb even bytes youre passing returning structs value copies structs get placed stack potentially causing situation site see application seems excessive stack usage structs passed value one things look first 
p1137
aVone thing people forgotten mention far overlooked structs usually padding struct short char b short c char d every char 1 byte every short 2 bytes large struct nope 6 bytes least commonly used systems systems 8 problem alignment constant system dependent struct different alignment different sizes different systems padding eat stack also adds insecurity able predict padding advance unless know system pads look every single struct app calculate size passing pointer adds insecurity size pointer known system always equal regardless struct looks like pointer sizes always chosen way aligned need padding 
p1138
aVone reason mentioned cause issue binary compatibility matters depending compiler used structures passed via stack registers depending compiler optionsimplementation see: fpccstructreturn fregstructreturn two compilers disagree things blow needless say main reasons illustrated stack consumption performance reasons 
p1139
aV_really_ answer question one needs dig deep assembly land: following example uses gcc x86_64 anyone add architectures like msvc arm etc lets example program: fooc typedef struct double x y point void give_two_doublesdouble x double y x 10 y 20 point give_point point 10 20 return int main return 0 compile full optimizations gcc wall o3 fooc o foo look assembly: objdump d foo vim get: 0000000000400480 give_two_doubles: 400480: 48 ba 00 00 00 00 00 mov 0x3ff0000000000000rdx 400487: 00 f0 3f 40048a: 48 b8 00 00 00 00 00 mov 0x4000000000000000rax 400491: 00 00 40 400494: 48 89 17 mov rdxrdi 400497: 48 89 06 mov raxrsi 40049a: c3 retq 40049b: 0f 1f 44 00 00 nopl 0x0raxrax1 00000000004004a0 give_point: 4004a0: 66 0f 28 05 28 01 00 movapd 0x128ripxmm0 4004a7: 00 4004a8: 66 0f 29 44 24 e8 movapd xmm00x18rsp 4004ae: f2 0f 10 05 12 01 00 movsd 0x112ripxmm0 4004b5: 00 4004b6: f2 0f 10 4c 24 f0 movsd 0x10rspxmm1 4004bc: c3 retq 4004bd: 0f 1f 00 nopl rax excluding nopl pads give_two_doubles 27 bytes give_point 29 bytes hand give_point yields one fewer instruction give_two_doubles whats interesting notice compiler able optimize mov faster sse2 variants movapd give_two_doubles actually moves data memory makes things slow apparently much may applicable embedded environments playing field c time nowdays im assembly wizard comments would 
p1140
aVpage 150 pc assembly clear explanation c allows function return struct: c also allows structure type used return value func tion obviously structure returned eax register different compilers handle situation differently common solution compilers use internally rewrite function one takes structure pointer parameter pointer used put return value structure defined outside routine called use following c code verify statement: struct person int int age struct person create struct person jingguo 1 age 2 return jingguo int mainint argc const char argv struct person result result create return 0 use gcc generate assembly piece c code: file fooc text globl create type create @function create: pushl ebp movl esp ebp subl 16 esp movl 8ebp ecx movl 1 8ebp movl 2 4ebp movl 8ebp eax movl 4ebp edx movl eax ecx movl edx 4ecx movl ecx eax leave ret 4 size create create globl main type main @function main: pushl ebp movl esp ebp subl 20 esp leal 8ebp eax movl eax esp call create subl 4 esp movl 0 eax leave ret size main main ident gcc: ubuntu 4434ubuntu5 443 section notegnustack@progbits stack call create: ebp saved ebp ebp4 age part struct person ebp8 part struct person ebp12 ebp16 ebp20 ebp8 address stack right calling create: ebp8 address return address ebpesp saved ebp 
p1141
aVheres something one mentioned: void examine_dataconst char c size_t l c0 l compiler error void examine_dataconst struct blob blob blobptr0 l perfectly legal quite likely blow runtime members const struct const member pointer like char becomes char const rather const char really want course could assume const documentation intent anyone violates writing bad code thats good enough especially spent four hours tracking cause crash alternative might make struct const_blob const char c size_t l use thats rather messy gets naming scheme problem typedefing pointers thus people stick two parameters likely case using string library 
p1142
aVwant point one advantage passing structs value optimizing compiler may better optimize code 
p1143
asS'3351809'
p1144
(lp1145
Vreading file using fscanf c need read print data file wrote program like includestdioh includeconioh int mainvoid char item9 status file fp fp fopend:\u005c\u005csample\u005c\u005cdatabasetxt r null printfno file\u005cn exit1 fp null printferror reading file\u005cn whilefscanffps citemstatus 1 printf\u005cns \u005ct c itemstatus iffeoffp putseof else putscan read getch return 0 databasetxt file contains test1 test2 b test3 c run code prints read please help find problem 
p1146
aVfscanf treat 2 arguments thus return 2 statement false hence never displaying read plus read 1 line eof resulting see 
p1147
aVfirst youre testing fp twice printferror reading file\u005cn never gets executed output fscanf equal 2 since youre reading two values 
p1148
aVcode: whilefscanffps citemstatus 1 1 2 scanf functions return number objects read 
p1149
aVscanf return number input items successfully matched code would two less case less matches specified short little careful manual pages: include stdioh include errnoh include stdboolh int mainvoid char item9 status file fp iffp fopend:\u005c\u005csample\u005c\u005cdatabasetxt r null printfno file\u005cn exit1 true int ret fscanffp c item status ifret 2 printf\u005cns \u005ct c item status else iferrno 0 perrorscanf: break else ifret eof break else printfno match\u005cn printf\u005cn iffeoffp putseof return 0 
p1150
asS'28693737'
p1151
(lp1152
Vbash programming language tldr shell scripts programming language programming language use shell scripts disclaimer: bit offtopic bash stands _bourneagain shell_ unix shell command line user interface maybe one could call interpreter im filling application new job get asked experience different programming languages box bottom _other experiences_ \u005c started typing _python 27 powershell bas_ wait bash isnt programming language console execute shell scripts eh oh god idea 
p1153
aVsay yes programming language according man bash bash shcompatible command language say command language programming language user communicates operating system application man bash: description bash shcompatible command language interpreter executes commands read standard input file bash also incorporates useful features korn c shells ksh csh bash gnu projects shell bash bourne shell bash shcompatible shell incorporates useful features korn shell ksh c shell csh intended conform ieee posix p10032iso 99452 shell tools standard offers functional improvements sh programming interactive use addition sh scripts run bash without modification unix shell unix shell commandline interpreter shell provides traditional user interface unix operating system unixlike systems users direct operation computer entering commands text command line interpreter execute creating text scripts one commands users typically interact unix shell using terminal emulator however direct operation via serial hardware connections networking session common server systems 
p1154
aVbash certainly _is_ programming language one specialises unixlinux shell scripting turing complete could theoretically write program bash 
p1155
asS'37210311'
p1156
(lp1157
Vcall result example proper example explaining callbyresult pseudocode learned algol 68 ada could use way cannot find clear example callbyresult 
p1158
aVmade pseudocode begin integer n procedure pk: integer begin n : n1 k : k4 printn end n : 0 pn printn end implement using ada language calladb gnatio use gnatio procedure call x : integer procedure nonsense a: integer begin x : x 1 : 4 putx end nonsense begin x : 0 nonsense x put putx new_line end call since ada uses callbyresult way result 1 4 could checked entering code onlineadacompiler result applied different passing parameter types call value: 1 1 call reference: 5 5 compare call valueresult: 1 4 
p1159
asS'3554120'
p1160
(lp1161
Vopen directory using c accepting path command line input diropendirargs1 doesnt enter loopie dirnull pass command line input dir pointer void mainint cchar args dir dir struct dirent dent char buffer50 strcpybuffer args1 dir opendirbuffer part ifdirnull whiledentreaddirdirnull printfdentd_name closedir aout roottest used run program aout execute program roottest input user ie valid path 
p1162
aVreally post code goes start with: include stdioh include direnth int main int c char v int len struct dirent pdirent dir pdir c 2 printf usage: testprog dirname\u005cn return 1 pdir opendir v1 pdir null printf cannot open directory s\u005cn v1 return 1 pdirent readdirpdir null printf s\u005cn pdirentd_name closedir pdir return 0 need check case args1 set refers actual directory run with: testprog tmp tmp subdirectory current directory use valid directory get: file1txt file1_file1txt file2avi file2_file2avi file3btxt file3_file3btxt note pass _directory_ _file_ execute: testprog tmpfile1txt get: cannot open directory tmpfile1txt thats file rather directory youre sneaky attempt use diropendirnamev1 initial diropen fails 
p1163
aVfeedback segment code though part work void mainint cchar args int main \u005c standard defines main returning int c args typically named argc argv respectfully allowed name anything dir dir struct dirent dent char buffer50 strcpybufferargs1 buffer overflow here: args1 longer 50 bytes buffer able hold write memory shouldnt theres reason see copy buffer sidestep issues using strcpy diropendirbuffer part returning null reasons: directory didnt exist type right space typed your_program directory fail tries opendirmy lack permissions directory theres insufficient memory unlikely 
p1164
aVparameters passed c program executable nothing array stringor character pointerso memory would already allocated input parameter program access parametersso need allocate bufferand way avoid error handling code program wellreduce chances segfault : 
p1165
aVsimple way implement ls command using c run use example xls tmp includestdioh include direnth void mainint argcchar argv dir dir struct dirent dent dir opendirargv1 ifdirnull whiledentreaddirdirnull ifstrcmpdentd_name0 strcmpdentd_name0 dentd_name else printfdentd_name printf\u005cn closedir 
p1166
asS'28325228'
p1167
(lp1168
Velse without previous beginning learn c programming really advanced level bear piece code guess pretty easy understand trying however get error saying last else called without suspect problem ifelse statement inbetween else would guys solve int talet scanfd talet int 1 99 int talet 0 talet 10 10 talet 10 talet 10 0 printf\u005cn else continue printfburr else printfd 1 
p1169
aVproblem here: printfburr else printfd cant statements else block remove move inside else block something like this: else printfburr printfd 
p1170
aVproblem brackets indenting important understand open close brackets int talet scanfdtalet int i1 whilei99 int italet0 taleti1010 taleti10 talet100 printf\u005cn else continue printfburr else printfd ii1 
p1171
aVproblem printf outside brackets compiler thinks statement finished reaches else throws error since open condition italet0 taleti1010 taleti10 talet100 printf\u005cn else continue printfburr moved else printfd 
p1172
aVtry keep codeblocks clean readable possible prevent making mistakes write else horstmann style: condition statements else statements bit compact tbs1 style: condition statements else statements choose one like styles comment provided crashmstr thanks stick improve code quality 
p1173
asS'17182648'
p1174
(lp1175
Vunderstanding static storage class c static default storage class global variables two variables count road static storage class static int count int road int main printfd\u005cn road return 0 question is: default global variables static means limiting scope global variable particular c file extern variables another file question might basic many really confused want learn correct details 
p1176
aVvariable count accessible name within one source file static precedes formally said _internal linkage_ see isoiec 9899:2011 §622 linkages identifiers variable road could accessed source files files included equivalent extern int road one statements formally said _external linkage_ generally people would call count static variable road global variable see also extern variables c inc 
p1177
aVformal c terminology specifiers like extern static register etc called _storageclass_ specifiers actual object properties specifiers control called _storage duration_ _linkage_ question seem mixing two unrelated concepts: _storage duration_ _linkage_ actually _linkage_ describes external visibility object variables defined file scope static storage duration regardless whether used keyword static declaration simply means live forever say anything external visibility meanwhile variables defined keyword static internal linkage variables defined without keywords keyword extern external linkage example variable road static storage duration _external_ linkage access directly translation units variable count static storage duration _internal_ linkage cant access directly translation units declare variable without storage class specifier like road example treated called _tentative definition_ finally resolve example variable static storage duration _external_ linkage point view right say default implied storage class specifier file scope variables actually extern static 
p1178
asS'571076'
p1179
(lp1180
Vcompile c program havent done c long time id like compile program idea proceed seems like makefile refers gcc lot ive never used gcc want executable run windows 
p1181
aVrequires gcc want run windows could download cygwin thats basically emulator gnulinux type stuff windows works emulation dll 
p1182
aValmost certainly dont need cygwin compile using gcc plenty standalone gcc clones windows like gcw 
p1183
aVmay need install either cygwin mingw unixlike environments windows downloadinginstalling either cygwin mingw option downloading installing optional features need following: gcc try version 2x first 3x binutils gnu make gmake 
p1184
aVreasonably portable c code havent looked may able ignore included makefile feed source whatever compiler want use happens try 
p1185
aVorder compile program need c compiler gcc although already given makefile set use gcc simplest thing would following: 1 install cygwin 2 open cygwin command prompt 3 go directory makefile 4 type make 5 compile program comfortable using command line tools download free version import source files new visual studio project way would need install cygwin use gcc would need know create projects run programs visual studio 
p1186
aVdevc uses mingw gcc compiler provides makefile support steps used build code using devc ie howto downloading source zip nist downloaded installed devc 5 beta 9 release created new empty project added c files sts20\u005csrc project options added lm linker column parameters added sts20\u005cinclude include directories directories set executable object directories obj directory build options hit ok close dialog go execute compile let whirl minute later find executable sts20\u005cobj directory 
p1187
aVfirst little chance program makefiles build visual studio visual studio good c compiler standard pov math functions particular poorly supported ms compilers may possible wont easy specially familiar c really stick makefiles instead trying import code ide kind scienfitic code clearly meant compiled command line test suite trying things randomly good idea use mingw msys install it: mingw give compilers gcc etc msys shell make file run correctly contrary one poster would advise using gcc 2 dont see point routinely use gcc 3 even 4 windows build scientific code works well code unixlike standard platform kind code 
p1188
asS'2566027'
p1189
(lp1190
Vuse typedef use typedef keyword c needed 
p1191
aVwikipedia: typedef keyword c c programming languages purpose typedef assign alternative names existing types often whose standard declaration cumbersome potentially confusing likely vary one implementation another and: kampr states two reasons using typedef first provides means make program portable instead change type everywhere appears throughout programs source files single typedef statement needs changed second typedef make complex declaration easier understand argument against: greg kh argues practice unnecessarily obfuscates code also cause programmers accidentally misuse large structures thinking simple types 
p1192
aVtypedef _type_ instance: typedef struct int int b thingy defines thingy given struct way use like this: thingy rather than: struct _thingy_struct int int b struct _thingy_struct bit verbose typedefs make things dramatically clearer specially pointers functions 
p1193
aValias another type typedef unsigned int uint uint alias unsigned int 
p1194
aVtypedef used create _aliases existing types_ bit misnomer define new types new types interchangeable underlying type typedefs often used clarity portability interface definitions underlying type subject change importance example: possibly useful posix: typedef int filedescriptor_t define struct foo give typedef struct foo int typedef struct foo foo_t define everything one go typedef struct bar int bar_t typedef useful function pointers: typedef int comparefunctionchar const char const comparefunction c strcmp typedef also used give names unnamed types cases typedef name said type: typedef struct int data_t typedef enum yes file_not_found return_code_t naming conventions differ usually recommended use trailing_underscore_and_t camelcase 
p1195
aV typedef doesnot introduce new type provide new name type typedef used for: 1 types combine arraysstructspointers functions 2 facilitate portability typedef type require port code different platformsselect right type making changes typedef 3 typedef provide simple name complicated type cast 4 typedef also used give names unnamed types cases typedef name said type note:_shouldnt use typedef structs always use tag structure definition even needed_ 
p1196
aVwikipedia: kampr states two reasons using typedef first second typedef make complex declaration easier understand example second reason using typedef simplifying complex types complex type taken kampr c programming language second edition p 136 char x x function returning pointer array pointer function returning char make declaration understandable using typedefs please see example typedef char pftype pf type pointer function returning char typedef pftype parrtype2 parr type array pointers functions returning char char charf returnb parrtype parrcharfcharf pftype finalf f function returning pointer array pointer function returning char returnparr 
p1197
aVexplaining use typedef following example typedef used make code readable include stdioh include mathh define new type name typedef follow steps: 1 write statement variable desired type declared 2 name declared variable would normally appear substitute new type name 3 front everything place keyword typedef typedef primitive data type typedef double distance typedef struct typedef struct int x int y point typedef array typedef point points100 points ps 0 ps array 100 point typedef function typedef distance distancefun_ppointpoint type_def distancefun_p int distancefun_ppointpoint prototype function distance finddistancepoint point int mainint argc char const argv delcare function pointer distancefun_p func_p initialize function pointer function address func_p finddistance initialize two point variables point p1 00 p2 11 call function pointer distance d func_pp1p2 printfthe distance f\u005cn d return 0 distance finddistancepoint p1 point p2 distance xdiff p1x p2x distance ydiff p1y p2y return sqrt xdiff xdiff ydiff ydiff front everything place keyword typedef 
p1198
asS'3645123'
p1199
(lp1200
Vopening file mode file opened using following command: file f1fopentestdata man page reads: open reading appending writing end file file created exist initial file position reading beginning file output always appended end file f1 2 separate offset pointers one read amp another write 
p1201
aVone pointer initially start file _when write operation attempted moved end file_ reposition using fseek rewind anywhere file reading writing operations move back end file 
p1202
aVone pointer 
p1203
aV_never_ mix reading writing operations file without calling fseek may work wish implementations program depends undefined behavior thus questions 2 positions meaningless 
p1204
asS'32191893'
p1205
(lp1206
Vadding server hostname line find output need listing files specific extension server need show server hostname file size absolute path file echo hostname find pwd iname jpg exec du \u005c echo hostname find pwd iname jpgxargs du almost get there: joes_server 5473 homejoepicssunsetjpg 8522 homejoepicsmountainsjpg cannot figure include hostname line find output attempts add hostname function xargs exec section result errors tries apply hostname finds output way include hostname line find output looped many servers id like output like: joes_server 5473 homejoepicssunsetjpg joes_server 8522 homejoepicsmountainsjpg marys_server 5398 homemarysnapshotsbackgroundjpg janes_server 9642 homejanepicturesflowersjpg thanks 
p1207
aV find pwd iname jpg exec du sed shostname: changes: 1 use pwd instead pwd \u005c need run command bash puts parameter already 2 quote quote quote 3 use instead find exec pass one file invocation du efficient way version find doesnt support use print0 xargs 0 du 4 pipe whole thing sed insert hostname front line 
p1208
asS'41981565'
p1209
(lp1210
Vclarification argc argv doubts argc argv cant seem grasp concept use use like program receives command line two integers 100000 100000 computes thir addition prints result performing needed check te number paramenters correctness include stdioh include stdlibh int mainint argc char argv int b char ch argc 4 printferror wrong number command line parameters\u005cn exit1 sscanfargv1 d 1 printferror first parameter valid integer\u005cn argv1 exit2 sscanfargv2 d b 1 printferror second parameter valid integer\u005cn argv2 exit2 ch argv30 ch printfthe sum result d\u005cn b else ch b printfthe subtraction result d\u005cn b else ch c printfthe multiplication result d\u005cn b else ch d b 0 printfthe division result d\u005cn b else printferror second value shoulb different 0 \u005cn else printferror parameter c correspond valid value\u005cn ch return 0 program receive command line two arguments input using codeblocks 
p1211
aV argc number parameters passed program invoked command line argv array received parameters array strings note name program always passed automatically assuming program executable test invoke terminal: text 145 643 argc 3: program name two numbers argv char array text145643 
p1212
aVwrite code say helloc run terminal going directoryfolder terminal compile using compiler like gcc gcc helloc o using windows compiler like turbo c visual studio would create exe file creates executable file run file command line give commandline arguments way input program terminal could arg1 arg2 arg1 arg2 command line arguments see windows using compiler like turbo c see link argc argv main functions uses mainint argc char argv take command line arguments argc number command line arguments passed case 3 argv array strings case 3 strings argv1 equal arg1 argv2 equal arg2 argv0 give command line arguments command line linux windows explanation linux see commandlineargumentsparametershtml command line arguments turbo c recommend turbo c know command line arguments read 
p1213
asS'20824905'
p1214
(lp1215
Vproblems compiling program extern variable inside main function create separate block new pair curly braces like one: int mainvoid int x 10 extern int y printf\u005ctno d\u005cn y int y 20 compile code come across error : testc: function \u2018main\u2019: testc:12:9: error: declaration \u2018y\u2019 linkage follows extern declaration int y 20 testc:9:16: note: previous declaration \u2018y\u2019 extern int y definitaion int y placed end main function code compiles run perfectly okay could reason behind error according book variable declared extern use defining compiler search whole file definition variable 
p1216
aVcant declare variable identical name twice block block scope 
p1217
aVc distinguishes variables file scope outside function variables local scope yvariable declare extern use printf refers variable file scope variable declared must defined elsewhere storage must allocated second declaration y inside local variable different file scope variable outside declaration file scope variable tentative definition file scope variable later case declaration visible variable used somewhere else definition storage provided everything works fine 
p1218
aVyes problem used extern means int y defined globally file different file without defining y globally printing extern value thats error linker 
p1219
asS'31147850'
p1220
(lp1221
Vread text file c im trying read txt file containing strings 1s 0s print manner tried code couple months ago worked fine reading text file tried outputs something really strange also tried changing directory file nonexistant file still outputs thing shouldve quit program immediately please help content txt file: 10000001 01110111 01111111 01111010 01111010 01110111 expected output: data_in24b10000001 10000 real output: data_in24bsome weird symbol changes everytime recompile 10000 code: include stdioh include stdlibh include stringh int main int argc char argv int j j 0 char words50 file fp fp fopen argv1 r fp null printf cant open file\u005cn feof fp 0 fscanf fp words printf data_in24bs\u005cn words printf 10000\u005cn fclose fp system pause return 0 input argument following: c:\u005cusers\u005cbeanz\u005cdocuments\u005cmatlab\u005cfootball frame\u005cframe1txt 
p1222
aVread line one one getline3 pagesman3getline3html available fgets youll need large enough line buffer least 256 bytes parse line buffer appropriately using sscanf n might useful test scanned item count result sscanf functions eg strtok strtol etc 
p1223
aVremember feof set trying read past end file end file final iteration loop try readprocess data contains trash prior contents always check returned value fscanf trying use associated data strongly suggest eliminate call feof use fscanf control loop 
p1224
asS'36730564'
p1225
(lp1226
Vdifference immutable const member functions d programming language reference shows two examples declarations qualifiers possible: struct int method const const stuff struct int method immutable immutable stuff docs: const member functions functions allowed change part object member functions reference and: immutable member functions guaranteed object anything referred reference immutable ive found question isthedifferencebetweenconstandimmutableind answers talking data types storage classes goes d const faq difference two definitions expressions replace const stuff legal immutable stuff 
p1227
aVimmutable methods may called immutable objects work guarantee object change ever const methods may called const immutable mutable objects guarantee change object references may change object id go const unless good reason need immutable const functions callable three mutability storage classes type system level anyway mutating immutable object possible causes undefined behavior 
p1228
asS'182732'
p1229
(lp1230
Vbetter use shebang line execute script looking shebang wondering would use could execute bash script using: bash foosh foosh shebang line foosh pros cons one use default 
p1231
aVwould say yes intrinsically better use shebang pro: put scripts path maybe usrlocalbin bin mark executable execute name without thinking interpreter need invoke bash python ruby perl etc place executable file named foo shebang anywhere path simply type foo execute con: type binbash top chmod x file nearzero cost convenient return 
p1232
aVmain reason using hashbang specifying exact interpreter want use writing portable shell scripts nice one often relies features particular shell word _bashism_ foundation real world thus desirable make clear interpreter also limited _shell_ scripts anything shell script hashbang must otherwise system wont know file try interpret script users default shell usually desired operation awk perl python ruby tcltk name awk actually another example hasbang important subtle differences various implementations requiring specific interpreter might good way prevent unexpected disappointments holds python scripts version 23only 
p1233
asS'5012126'
p1234
(lp1235
Vsimple c program opening file im trying make program open file called writetxt include stdioh main file fp fp fopenwritetxt w return 0 work returns nothing 
p1236
aVexpect return opens file platforms creating one doesnt exist probably fclosefp file end 
p1237
aVold variant main theres really _much_ wrong code barring errors create file however since youre checking return value fopen may get error sort know id start with: include stdioh include errnoh int main void file fp fp fopen writetxtw fp null printf file created okay errno d\u005cn errno return 1 fprintf fp there\u005cn want something file fclose fp printf file created okay\u005cn return 0 youre adamant file isnt created code says may victim dreaded ide working different directory think syndrome : ides visual studio actually run code theyre directory like solutionname\u005cbin solutionname\u005cdebug find putting: system cd windows system pwd unixy systems code see running _thats_ file created specify relative path line writetxt otherwise specify absolute path ensure tries create specific point file system 
p1238
aVthink study fundamentals c start attempting work files return means data passed back calling code called functionin case return 0 end program anything file pointer except cause new file created 
p1239
aVthink want print contents file writetxt assume contains characters include stdioh int main file fpchar ch fpfopenwritetxtr iffpnull printfsome problem opening file exit0 else whilechfgetcfpeof printfcch fclosefp return 0 
p1240
asS'156767'
p1241
(lp1242
Vwhats difference argument parameter verbally talking methods im never sure whether use word _argument_ _parameter_ something else either way people know mean whats correct whats history terms im c programmer also wonder whether people use different terms different languages record im selftaught without background computer science please dont tell read code complete completepracticalhandbookconstructiondp0735619670 im asking benefit people dont already copy steve mcconnell summary general consensus seems ok use terms interchangeably team environment except perhaps youre defining precise terminology also use _formal_ argumentparameter _actual_ argumentparameter disambiguate 
p1243
aVparameter variable declaration function argument actual value variable gets passed function 
p1244
aVparameter something fill call function put argument simply set: argument goes parameter argument value parameter bit info on: 
p1245
aVparameter variable method definition method called arguments data pass methods parameters public void mymethodstring myparam string myarg1 argument myclassmymethodmyarg1 
p1246
aVparameters functionmethod describe values uses calculate result arguments values assigned parameters particular call functionmethod 
p1247
aValready wikipedia entry subject see parameter defines distinguishes terms _parameter_ _argument_ short parameter part functionproceduremethod signature argument actual value supplied runtime andor callsite parameter wikipedia article also states two terms often used synonymously especially reasoning code informally: although parameters also commonly referred arguments arguments properly thought actual values references assigned parameter variables subroutine called runtime given following example function c adds two integers x y would referred parameters: int addint x int y return x y callsite using add example shown _123_ _456_ would referred _arguments_ call int result add123 456 also language specifications formal documentation choose use _parameter_ _argument_ exclusively use adjectives like _formal_ _actual_ instead disambiguate two cases example cc documentation often refers function _parameters_ _formal arguments_ function call _arguments_ _actual arguments_ example see \u201cformal actual arguments visual c language reference uslibrary3bstk3k5aspx 
p1248
aVterms somewhat interchangeable distinction described answers properly expressed terms _formal parameter_ name used inside body function _parameter_ value supplied call site _formal argument_ _argument_ also common also note mathematics term _argument_ far common _parameter_ usually means something quite different though _parameter_ parametric equation essentially _argument_ two functions 
p1249
aVeven simpler arguments parameters 
p1250
aVexample might help int main int x 5 int y 4 sumx y x y arguments int sumint one int two one two parameters return one two 
p1251
aVdont much difference usage c terms used practice mostly arguments often used functions value passed function calling statement called argument parameter would variable copies value function definition called formal parameter int main local variable definition int 100 int b 200 int ret calling function get max value ret maxa b printf max value : d\u005cn ret return 0 function returning max two numbers int maxint num1 int num2 local variable declaration int result num1 num2 result num1 else result num2 return result code num1 num2 formal parameters b actual arguments 
p1252
aVmay even simpler remember like case optional arguments method: public void methodstring parameter argument parameter parameter value argument argument : 
p1253
aVlets say youre airline build airplane install seats fill plane passengers send somewhere passengers rather spatiotemporally altered version thereof disembark next day reuse plane seats different passengers time plane function parameters seats arguments passengers go seats 
p1254
aVargument instantiation parameter 
p1255
aVediting im often put people forget: structure languages based natural languages english parameter placeholder set response format language definition party call limiting response argument position considered argue opinion: consider argument main difference thematic role argument agent thematic role parameter recipient interactions think argument male part making parameter female part argument goes parameter usage parameter _usually_ used definitions argument _usually_ used invocations questions finish sentence make less dissonant speaking definition: 1 argument used 2 parameter b speaking invocation: 1 parameter use 2 parameter answers 1 oninagainstwith parameter 2 arguments take b 1 example arguments 2 arguments used oninagainstwith overlaps imagine answering: language words sometimes produce identical responses rule: usually someone wants parameter information want know type variable name etc may become confused give example arguments usually someone wants argument information want know value passed function parameters 
p1256
aVuse terms parameters arguments misused somewhat among programmers even authors dealing methods term _parameter_ used identify placeholders method signature whereas term _arguments_ actual values pass method _mcsd cerfification toolkit exam 70483 programming c_ 1st edition wrox 2013 realworld case scenario define method two parameters int sumint num1 int num2 return num1 num2 call method using two arguments var ret sum2 3 
p1257
aVok lets real: intents purposes virtually thingok pedants might technical difference parameter general broad thing argumet specific thing great thanks thats really helpful hmmm: perhaps example order simple explanation lets take example: machine heres works: put things machine one end end new product comes machine goes machine anything comes well refined version goes eg put flour sugar one end machine comes: cake get idea different machines different rules one particular machine may accept petrol unleaded input said machines accept parameters type: petrol example argument argument particular specific example put machine suppose machine takes people input _people would parameter machine_ lets suppose machine turns people people arent mean people wonderful machinewhat argument argument particular person actually put machine eg george bush put machine argument would george bush kim kardiashian would argument parameter would people abstract concept argument would always particular person particular name put machine one example eg method ie particular machine turns inputs outputs may accept integer parameter lets suppose integer 5 passed function ie lets suppose put number 5 machine case integer 5 would argument parameter accepted method would type integer thats difference simple hope helps youre confused comment ill try fix 
p1258
aVoracles java tutorials define distinction thusly: parameters refers list variables method declaration arguments actual values passed method invoked invoke method arguments used must match declarations parameters type order detailed discussion parameters arguments: 
p1259
aVcreate method function java method like datatype name method datatype variablename parenthesis parameters call method function pass value parameter called arguments 
p1260
aVparameters variables received functionhence visible function declarationthey contain variable name data type arguments actual values passed another function thats see function call values without datatype 
p1261
asS'13337338'
p1262
(lp1263
Vcall name vs call value scala clarification needed understand scala function may called either byvalue byname example given following declarations know function called declaration: def f x:int y:int x call f 12 f 23555 f 123 4411 rules please 
p1264
aVexample given uses callbyvalue give new simpler example shows difference first lets assume function sideeffect function prints something returns int def something printlncalling something 1 return value going define two function accept int arguments exactly except one takes argument callbyvalue style x: int callbyname style x: int def callbyvaluex: int printlnx1 x printlnx2 x def callbynamex: int printlnx1 x printlnx2 x happens call sideeffecting function scala callbyvaluesomething calling something x11 x21 scala callbynamesomething calling something x11 calling something x21 see callbyvalue version sideeffect passedin function call something happened however callbyname version sideeffect happened twice callbyvalue functions compute passedin expressions value calling function thus _same_ value accessed every time however callbyname functions _recompute_ passedin expressions value every time accessed 
p1265
aVcase example parameters evaluated called function youre defining _by value_ want define parameters _by name_ pass code block: def fx: int y:int x way parameter x evaluated called function little post explains nicely 
p1266
aVexample martin odersky: def test x:int y: int xx want examine evaluation strategy determine one faster less steps conditions: test 23 call value: test23 22 4 call name: test23 22 4 result reached number steps test 348 call value: test 78 77 49 call name: 34 _34 7_34 77 49 call value faster test 724 call value: test78 77 49 call name: 7 7 49 call name faster test 34 24 call value: test724 test7 8 77 49 call name: 34_34 7_34 77 49 result reached within steps 
p1267
aVtry explain simple use case rather providing example imagine want build nagger app nag every time since time last got nagged examine following implementations: object main def mainargs: arraystring def ontimetime: long whiletime time printlntime nag printlnno nags def onrealtimetime: long whiletime time printlnrealtime nagging executed ontimesystemnanotime onrealtimesystemnanotime implementation nagger work passing name reason passing value reused therefore value reevaluated passing name value reevaluated every time variables accessed 
p1268
aViteratate @bens point comments think best think callbyname syntactic sugar parser wraps expressions anonymous functions called later point used effect instead defining def callbynamex: int printlnx1 x printlnx2 x running: scala callbynamesomething calling something x11 calling something x21 could also write: def callalsobynamex: int printlnx1 x printlnx2 x run follows effect: callalsobyname something calling something x11 calling something x21 
p1269
aVassume callbyvalue function discuss pass values function according martin odersky evaluation strategy follow scala play important role function evaluation make simple callbyname like pass function argument method also know higherorderfunctions method access value passed parameter call implementation passed functions below: according @dhg example create method first as: def something printlncalling something 1 return value function contain one println statement return integer value create function arguments callbyname: def callbynamex: int printlnx1 x printlnx2 x function parameter define anonymous function return one integer value x contain definition function 0 passed arguments return int value something function contain signature call function pass function argument callbyname case callbyvalue pass integer value function call function below: scala callbynamesomething calling something x11 calling something x21 something method called twice access value x callbyname method call defintion something method 
p1270
aVcallbyname invoked used callbyvalue invoked whenever statement encountered example: infinite loop ie execute function never get scala prompt scala def loopx:int :int loopx1 loop: x: intint callbyname function takes loop method argument never used inside body scala def callbynamex:inty: intx callbyname: x: int y: intint execution callbyname method dont find problem get scala prompt back using loop function inside callbyname function scala callbyname1loop10 res1: int 1 scala callbyvalue function takes loop method parameter result inside function expression evaluated executing outer function loop function executed recursively never get scala prompt back scala def callbyvaluex:inty:int x callbyvalue: x: int y: intint scala callbyvalue1loop1 
p1271
aVtypically parameters functions byvalue parameters value parameter determined passed function need write function accepts parameter expression dont want evaluated called within function circumstance scala offers callbyname parameters callbyname mechanism passes code block callee time callee accesses parameter code block executed value calculated object test def mainargs: arraystring delayedtime def time printlngetting time nano seconds systemnanotime def delayed t: long printlnin delayed method printlnparam: 1 c:scalac testscala 2 scala test 3 delayed method 4 getting time nano seconds 5 param: 81303808765843 6 getting time nano seconds 
p1272
aVdont think answers correct justification: call value arguments computed once: def fx : int y :int x following substitution model f12 3 4 11 f15 4194304 15 see arguments evaluated whether needed normally callbyvalue fast always like case evaluation strategy callbyname decomposition would been: f12 3 4 11 12 3 15 see never needed evaluate 4 11 hence saved bit computation may beneficial sometimes 
p1273
aVparameters usually pass value means theyll evaluated substituted function body force parameter call name using double arrow defining function first parameter call value second call name using def returnonex: int y: int: int 1 demonstrate benefits call name create infinite recursion def loopx: int: int loopx return one since loop2 passed name evaluated returnone2 loop2 terminate since loop2 evaluate returnoneloop2 2 returnoneloop2 2 returnoneloop2 2 
p1274
asS'2661369'
p1275
(lp1276
Vstorage classes difference variable declared auto static difference allocation memory auto static variable use static array pointers significance 
p1277
aVill assume youre talking auto variables probably mean local variables function auto default means variable allocated stack function called deallocated function returns static means variable allocated first time function called stays allocated rest program means: int foo static int x 0 return x printfd\u005cn foo outputs 0 printfd\u005cn foo outputs 1 printfd\u005cn foo outputs 2 
p1278
aVauto default static extern amp register 4 modifiers variable c auto : default normal variable static means runtime os delete variable memory function containing variable exits initialise variable every time function called rather static variable initialised first time function containing called continues reside memory program terminates words static effectively makes variable global memory local access statics stored depends 0 initialized 0 initialized static data goes bss block started symbol non 0 initialized data goes data one must note though staticvariables always memory accessed local scope function defined extern : used signal compiler externdefinition simply placeholder actual definition somewhere else declaring variable extern result program reserving memory variable scope declared also common find function prototypes declared extern register : signals compiler preferrably used cpuregister ram store variable used improve performance repeated access variable made ex: loop counter variables 
p1279
aVauto : auto storage class default classif declare variable within function without define storage automatically promoted auto variable simple way say local variable non static auto variable scope auto variable within function declare live till control within function eg int main int 10 int b10 printfdb example b local variable live till control within main functionbut visibility b within curly braces definewhen try compile code got error: undeclared variable b int main int 10 int d int b20 db printfdd output 20\u005c b alive control reside main function static: use static prefix variable alive across entire run program means extent static variable entire run program scope static variable within module declare used static global variable scope global variable limited file declare word say static make variable function private file declare initialized static variable create data segment ds either create bss block started symbol process note: static variable initialize compile timewhen memory allocate itif initialize responsibility compiler initialize zero experience create lookup table table required entire run program want make file specific declare static knowledge see link: 
p1280
asS'2648112'
p1281
(lp1282
Vinclude using namespace c using cout need specify both: includeiostream using namespace std cout defined iostream correct iostream namespace std meaning statements respect using cout confused need include 
p1283
aViostream name file cout defined hand std namespace equivalent sense javas package cout instance defined iostream file inside std namespace could exist another cout instance another namespace indicate want use cout instance std namespace write std::cout indicating scope std::couthello worldstd::endl avoid std:: everywhere use using clause couthello worldendl two different things one indicates scope actual inclusion cout response comment imagine iostream two instances named cout exist different namespaces namespace std ostream cout namespace float coutinstance another type including iostream youd still need specify namespace include statement doesnt say hey use cout std:: thats using specify scope 
p1284
aVcout logically defined within iostream logically mean may actually file iostream may file included iostream either way including iostream correct way get definition cout symbols iostream namespace std make use cout symbol must tell compiler find ie namespace couple choices: explicit std::cout std::endl import one symbol namespace symbols must still explicit using std::cout cout std::endl import entire namespace using namespace std cout endl shorten namespace interesting standard useful long namespace names namespace std s::cout s::endl 
p1285
aVinclude iostream references header file defines cout youre going use cout always need include need using namespace std thats simply allows use shorthand cout endl like rather std::cout std::endl namespace explicit personally prefer use using namespace since requires explicit meaning though admittedly verbose 
p1286
aVc implementation uses c style header files many file contains something similar to: include bunches things included namespace std various things extern istream cin extern ostream cout extern ostream cerr various things std namespace c standard says standard things reside keep overpopulating global namespace could cause difficulty coming names classes variables functions arent already used names standard things saying using namespace std telling compiler want search namespace std addition global namespace looking names compiler sees source line: return foo somewhere using namespace std line look foo various different namespaces similar scopes finds foo meets requirements line searches namespaces certain order first looks local scope really unnamed namespace next local scope outside function enclosing objects named things methods case global names functions case unless youve silly overloaded im ignoring std namespace youve used using namespace std line may last two wrong order std may searched global avoid writing code depends 
p1287
asS'34548762'
p1288
(lp1289
Vvoid f  saw picture today think id appreciate explanations picture: c code found confusing wondered codes ever practical googled picture found another picture reddit entry picture: interesting explanation reading spirally something valid c compilers parse itd great simpler explanations weird code apart kind codes useful question anddeclarationfollowsusageforparsingcandcdeclarations spiral rule im asking applied expressions read rule im questioning usage expressions spiral rules validity well regarding nice answers already posted 
p1290
aVrule called clockwisespiral rule complex declaration cfaq three simple steps follow: 1 starting unknown element move spiralclockwise direction ecountering following elements replace corresponding english statements: x array x size array undefined size type1 type2 function passing type1 type2 returning pointers 2 keep spiralclockwise direction tokens covered 3 always resolve anything parenthesis first check link examples also note help also website called: enter c declaration give english meaning void f outputs: declare f array pointer function returning pointer function returning void edit: pointed comments random832 address array arrays lead wrong result declarations example int x12 spiral rule ignores fact higher precedence front array arrays one first add explicit parentheses applying spiral rule example: int x12 int x12 also valid c due precedence spiral rule correctly reads x array 1 array 2 pointer pointer int correct english declaration note issue also covered answer declarationswhenisitinerror1626538916265389 james kanze haccks 
p1291
aVdoubt constructions like use real life even detest interview questions regular developers likely ok compiler writers typedefs used instead 
p1292
aVregarding usefulness working shellcode see construct lot: int ret intcode ret quite syntactically complicated particular pattern comes lot complete example shellcodeincprogram question usefulness extent original picture questionable would suggest production code drastically simplified syntactical constructs come quite bit 
p1293
aVspiral rule kind falls following precedence rules: array pointer pointer array f f function returning pointer f f pointer function returning subscript function call operators higher precedence unary f parsed f parsed want pointer array pointer function need explicitly group identifier f realize f complicated expressions identifiers could simple identifier could function call like fn f could array like pmn pm could array pointers functions like pmn pm etc would nice indirection operator postfix instead unary would make declarations somewhat easier read left right void f definitely flows better void f come across hairy declaration like start finding _leftmost_ identifier apply precedence rules recursively applying function parameters: f f f array f pointers higher precedence f functions f returning pointers f functions void f returning void signal function standard library probably type specimen kind insanity: signal signal signal function parameters signal sig sig signalint sig int signalint sig func func signalint sig func pointer signalint sig funcint function taking int signalint sig void funcint returning void signalint sig void funcint returning pointer signalint sig void funcintint function taking int void signalint sig void funcintint returning void point people say use typedefs certainly option: typedef void outerfuncvoid typedef outerfunc innerfuncvoid innerfunc fn would _use_ f expression know array pointers use execute correct function go typedefs puzzle correct syntax contrast naked version pretty eyestabby tells exactly _use_ f expression namely fi assuming neither function takes arguments 
p1294
aV remember rules c declares precedence never doubt: start suffix proceed prefix read sets inside \u005c mid1980s except modified parentheses course note syntax declaring exactly mirrors syntax using variable get instance base class seriously isnt hard learn glance willing spend time practising skill youre going maintain adapt c code written people _definitely_ worth investing time also fun party trick freaking programmers havent learned code: always fact something _can_ written oneliner doest mean unless extremely common pattern become standard idiom stringcopy loop follow _much_ happier build complex types layered typedefs stepbystep dereferences rather relying ability generate parse one swell foop performance good code readability maintainability tremendously better could worse know legal pli statement started something like: else else else 
p1295
aVc declaration mirrors usage\u2014that\u2019s it\u2019s defined standard declaration: void f assertion expression fi produces result type void means: f must array since index it: fi elements f must pointers since dereference them: fi pointers must pointers functions taking arguments since call them: fi results functions must also pointers since dereference them: fi pointers must _also_ pointers functions taking arguments since call them: fi function pointers must return void \u201cspiral rule\u201d mnemonic provides different way understanding thing 
p1296
aVspiral happens declaration one operator side within level parentheses claiming proceed spiral generally would suggest alternate arrays pointers declaration int foo reality array levels come pointer levels 
p1297
aVrandom trivia factoid might find amusing know theres actual word english describe c declarations read: boustrophedonically alternating righttoleft lefttoright reference: van der linden 1994 76 
p1298
aV reading spirally something valid applying spiral rule using cdecl always fails cases spiral rule works many cases universal decipher complex declarations remember two simple rules: always read declarations inside out: start innermost parenthesis locate identifier thats declared start deciphering declaration choice always favour : precedes identifier follows identifier represents array pointer likewise precedes identifier follows identifier represents function pointer parentheses always used override normal priority rule actually involves zigzagging one side identifier deciphering simple declaration int a10 applying rule: int a10 int a10 array int a10 array pointers int a10 array pointers int lets decipher complex declaration like void f applying rules: void f f void f f array void f f array pointers void f f array pointers function void f f array pointers function returning pointer void f f array pointers function returning pointer function void f f array pointers function returning pointer function returning void gif demonstrating go click image larger view: enter image description rules mentioned taken book c programming modern approach kn king 
p1299
aVfound method described bruce eckel helpful easy follow: defining function pointer define pointer function arguments return value say: void funcptr looking complex definition like best way attack start middle work way \u201cstarting middle\u201d means starting variable name funcptr \u201cworking way out\u201d means looking right nearest item nothing case right parenthesis stops short looking left pointer denoted asterisk looking right empty argument list indicating function takes arguments looking left void indicates function return value rightleft right motion works declarations review \u201cstart middle\u201d \u201cfuncptr \u201d go right nothing \u2013 youre stopped right parenthesis go left find \u2018\u2019 \u201c pointer \u201d go right find empty argument list \u201c function takes arguments \u201d go left find void \u201cfuncptr pointer function takes arguments returns void\u201d may wonder funcptr requires parentheses didnt use compiler would see: void funcptr would declaring function returns void rather defining variable think compiler going process figures declaration definition supposed needs parentheses \u201cbump against\u201d goes back left finds \u2018\u2019 instead continuing right finding empty argument list complicated declarations amp definitions aside figure c c declaration syntax works create much complicated items instance: : c03:complicateddefinitionscpp 1 void fp1int10 2 float fp2intintfloatint 3 typedef double fp310 fp3 4 int f410 int main : walk one use rightleft guideline figure number 1 says \u201cfp1 pointer function takes integer argument returns pointer array 10 void pointers\u201d number 2 says \u201cfp2 pointer function takes three arguments int int float returns pointer function takes integer argument returns float\u201d creating lot complicated definitions might want use typedef number 3 shows typedef saves typing complicated description every time says \u201can fp3 pointer function takes arguments returns pointer array 10 pointers functions take arguments return doubles\u201d says \u201ca one fp3 types\u201d typedef generally useful building complicated descriptions simple ones number 4 function declaration instead variable definition says \u201cf4 function returns pointer array 10 pointers functions return integers\u201d rarely ever need complicated declarations definitions however go exercise figuring even mildly disturbed slightly complicated ones may encounter real life taken from: thinking c volume 1 second edition chapter 3 section function addresses bruce eckel htmlframeshtml 
p1300
aVdeclaration void f obscure way saying function f typedef void resultfunction typedef resultfunction function practice descriptive names needed instead _resultfunction_ _function_ possible would also specify parameter lists void 
p1301
aV void f resolving void f void resoiving f function returning void resolving f pointer function returning void resolving f function returning pointer function returning void resolving f pointer function returning pointer function returning void resolving f array pointer function returning pointer function returning void 
p1302
asS'4625309'
p1303
(lp1304
Vlocal variables bash: local vs subshell far know two ways create local variables bash function: create subshell declare every variable local example: using local function foo local count count seq 10 echo count done using subshell function foo count seq 10 echo count done obvisously version using subshell simpler write dont care declaring variables local mention environment variables createdexported tools like getopts imagine creating subshell overhead better approach proscons 
p1305
aVcreating subshell involves fork definitely overhead compared local variable subshells cheap dont worry cost need one free script going heavily used performance really matters youll hundreds users running time many times day might worry performance cost subshell otoh run month script whole runs 10 seconds probably wouldnt however terms clarity much better explicit declare variables reduces risk script breaking someone comes along says subshell clearly isnt needed really isnt id want remove subshells functions look evolution perl scripts started freeforall variables coming existence demand gradually become rigorous normal style predeclare variables extent shells followed similar path rigorously perl awk also interesting case study functions use global variables unless arguments function leads functions written 3 active arguments say 5 inactive arguments effectively define local variables slightly eccentric though works 
p1306
aVmaking sure functions always declare variables local quite difficult think errorprone prefer always use subshellfunctions: f echo subshell need declare local variables also way change global variables good opinion one additional consequence always need check return exit code functions act accordingly cannot exit script within subshell function f echo trying exit exit 1 f echo exit exit script need way: f echo trying exit exit 1 f exit echo exit exit 
p1307
asS'57105'
p1308
(lp1309
Vmultiple shells unix like system started learning fundamentals unix wondering many shells unix like system book advanced programing unix environment shell commandline interpreter reads user input executes commandsthe user input shell normally terminal interactive shell sometimes \ufb01le called shell script book goes list number shell programs like bourne shell bourneagain shellcshell etc question basically need multiple shells 
p1310
aVpeople different needs good alternatives fitting needs given situation shell tool replaceable opinion thats power unixlinux opposed microsoft windows chosen similarly many text editors people develop new browser theres already one gnome kde xfce lxde e17 etc 
p1311
aVshort answer due weird licensing history single entity developed unix community process volunteers corporations participated entities didnt always share tools separate shells happened time realized counter productive late unify shells use instead work done ensure shells would theoretically compatible one another long answer complex tightly linked history unix theres way hold single answer page widely misdocumented find detailed precise answers looking around web books dealing unix history 
p1312
aVshells used modern unix environments meant conform posix sh specification posix sh derived original korn shell ksh88 turn derived earlier bourne shell posix sh specifies small subset even ksh88s functionality shell implements minimum requirement missing many features required writing trivial scripts safe reasonable manner example local variables arrays nonstandard extras therefore first reason extend shell extra features different shells choose focus different things example zsh focuses advanced interactive features ksh93 current original korn shell focuses powerful programming features performance even minimal shells like dash add least nonstandard extras like local variables extra features rarely widely interoperable ksh88 featureset fairly well interoperable extended globbing syntax nonstandard features guarantees must really know youre use portable way second reason legacy still lot proprietary unixes use ancient nonstandard implementations binsh recently solaris still used bourne defuault chose maintain heirloom shell rather upgrade something modern systems usually come different shells switch instance changing path variable altering shebangs within individual scripts summarize multiple shells often default: extra features especially dealing nonportable extras handle legacy scripts often unmaintained size performance embedded systems often require small shells like mksh busybox sh licensing reasons atampt ksh proprietary software around 2000 largely gave rise kshlike clones zsh bash historical reasons though popular today radical attempts redesigning language scsh es process substitution feature many shells originally comes rc bit different syntax brace expansion csh different shells different combinations features available usually subtle subtle differences 
p1313
aVmostly history bourne developed part propriety sysv unix bsd used csh later bash developed opensource alternative bourne shell improved versions like ksh bournelike shell adopted posix standard ksh compliant bash compliant shells like csh tcsh much easier use interactively original bourne shell lack command completion etc horrible scripting environments unixbased embedded systems scripting features size speed important interactive features like command completion different variant shells tend used portable scripting use posix compliant bournevariant avoid extensions 
p1314
aVdifferent shells exist reasons different web browsers exist: everyone preference shells historical baggage momentum different features idiosyncrasies 
p1315
asS'31231376'
p1316
(lp1317
Vx0 x00 x000 im studying little c im fighting pointers understand 3 level pointers declaring: int x5 x pointer array 5 elements pointers int also know x0 x0 x1 x1and given declaration x0 x00 x000 
p1318
aVx0 x00 x000 according post x0 x00 x000 simplified x x x equal first one address pointer second one address another pointer third one int value 
p1319
aVtrying compare different types value take addresses might get expect keep mind declaration makes difference int y 555 would allow comparisons want since y y0 y00 y000 would different values types address int x5 occupy contiguous space x x 0 address x00 x000 different addresses 
p1320
aV x0 dereferences outermost pointer pointer array size 5 pointer int results array size 5 pointer int x00 dereferences outermost pointer _and_ indexes array resulting pointer int x000 dereferences everything resulting concrete value way ever feel confused kind declarations mean use cdecl 
p1321
aVlet consider step step expressions x0 x00 x000 x defined following way int x5 expression x0 array type int 5 take account expression x0 equivalent expression x dereferencing pointer array get array let denote like y declaration int y5 expression x00 equivalent y0 type int let denote like z declaration int z expression x000 equivalent expression y00 turn equivalent expression z0 type int x0 type int 5 x00 type int x000 type int objects different types way different sizes run example std::cout sizeof x0 std::endl std::cout sizeof x00 std::endl std::cout sizeof x000 std::endl 
p1322
aVx pointer array 5 pointers int _x0 array_ 5 pointers int x00 pointer int x000 int x0 pointer array x000 x pointer int 0x500 0x100 x00 0x100 10 x pointer array 5 pointers int pointer int 0x504 0x222 x01 0x222 pointer int 0x508 0x001 x02 0x001 pointer int 0x50c 0x123 x03 0x123 pointer int 0x510 0x000 x04 0x000 see x0 array converted pointer first element used expression exceptions therefore x0 give address first element x00 0x500 x00 contains address int 0x100 x000 contains int value 10 x0 equal x00and therefore x00 x00 hence x0 x00 x000 
p1323
aVmemory layout pointer: x: address array v pointer 0 pointer 1 pointer 2 pointer 3 pointer 4 v integer x0 yields address array x00 yields pointer 0 x000 yields integer believe obvious different close enough basic understanding wrote way wrote however haccks rightly points first line 100 precise come fine details: definition c language value x0 whole array integer pointers however arrays something cant really anything c always manipulate either address elements never entire array whole: 1 pass x0 sizeof operator thats really use value result depends type 2 take address yields value x e address array type int5 words: x0 x 0 x 0 x 3 _all contexts_ value x0 decay pointer first element array pointer value address array type int effect casted x pointer type int due arraypointer decay case 3 uses x0 ultimately result pointer points beginning pointer array call printfp x0 print contents memory cells labeled address array 
p1324
aVtheres principle c that: declaration variable indicates exactly way using variable consider declaration: int x5 rewritten clearer: int x5 due principle have: xi treated int value 04 \u2192 xi treated int pointer 04 \u2192 x treated int pointer \u2192 x treated int pointer therefore: x0 int pointer \u2192 x00 x0 0 int pointer \u2192 x000 x00 0 int value figure difference 
p1325
aVfirst thing say x 0 x 0 x x 0 0 x 0 0 x x 0 0 0 x 0 0 x x \u2260 x \u2260 x following picture things clear x000 2000 x00 1001 x0 10 enter image description example value x00010 address x000 1001 address stored x001001 address x00 2000 address stored x02000 x000 \u2260 x00 \u2260 x0 _editings_ program 1: int x xintmallocsizeofint xintmallocsizeofint xintmallocsizeofint x10 printfd d d d\u005cnxxxx printfd d d d dx000x00x0xx output 142041096 142041112 142041128 10 10 142041128 142041112 142041096 1076392836 program 2: int x11110 printfd d d d \u005cn x000x00x0x output 10 1074058436 1074058436 1074058436 
p1326
aVview arrays realworld perspective would appear thus: x0 freight container full crates x00 single crate full shoeboxes within freight container x000 single shoebox inside crate inside freight container even shoebox crate freight container still shoebox freight container 
p1327
aVp pointer: youre stacking dereferences p00 equivalent p00 c reference amp dereference notation: p p0 p00 p000 equivalent to: p p0 p00 p000 look amp refactored removing it: p p0 p00 p000 p00000 
p1328
aVanswers correct none emphasize idea possible three contain value theyre way incomplete reason cant understood answers illustrations helpful definitely reasonable circumstances fail cover situation pointer x points pretty easy construct clearly bit harder understand program well see force three values identical note: behavior program undefined im posting purely interesting demonstration something pointers _can_ _shouldnt_ include stdioh int main int x5 x int 5 x printfp\u005cn x0 printfp\u005cn x00 printfp\u005cn x000 compiles without warnings c89 c99 output following: ptrs 0xbfd9198c 0xbfd9198c 0xbfd9198c interestingly enough three values identical shouldnt surprise first lets break program declare x pointer array 5 elements element type pointer int declaration allocates 4 bytes runtime stack depending implementation machine pointers 4 bytes x referring actual memory location c family languages contents x garbage something left previous usage location x doesnt point anywhere certainly allocated space naturally take address variable x put somewhere thats exactly well go ahead put x since x different type x need cast dont get warnings memory model would look something like this: 0xbfd9198c 0xbfd9198c 4byte block memory address 0xbfd9198c contains bit pattern corresponding hexadecimal value 0xbfd9198c simple enough next print three values answers explain expression refers relationship clear see values low level sensetheir bit patterns identical type data associated expression means interpreted values different instance printed x000 using format string d wed get huge negative number values practice different bit pattern actually really simplein diagrams arrows point memory address rather different ones however able force expected result undefined behavior undefined isnt production code simply demonstration sake completeness reasonable situation use malloc create array 5 int pointers create ints pointed array malloc always returns unique address unless youre memory case returns null 0 youll never worry self referential pointers like hopefully thats complete answer youre looking shouldnt expect x0 x00 x000 equal could forced anything went head let know clarify 
p1329
asS'1164167'
p1330
(lp1331
Vvariable declaration header file case variable may used several sources good practice declare header better declare c file use extern files 
p1332
aVdeclare extern header file define exactly 1 c file note c file also use header standard pattern looks like: fileh extern int x declaration filec include fileh int x 1 definition redeclaration 
p1333
aV_declare_ variable header file: extern int x _define_ _one_ c file: int x c difference definition declaration definition reserves space variable whereas declaration merely introduces variable symbol table cause linker go looking comes link time 
p1334
aVdeclare like int x header file included multiple places youll end multiple instances x potentially compile link problems correct way approach header file say extern int x declared fooc fooc say int x exported fooh include header file many places like 
p1335
aVkey keep declarations variable header file source file use trick samplec define sample_c include sampleh rest sample c sampleh ifdef sample_c define extern else define extern extern endif extern int x samplec compiled defines variables file includes sampleh given extern variable allocate space variable change type x change everybody wont need remember change source file header file 
p1336
aVsolution ifndef version_h define version_h static const char sver 1421 static const char aver 1100 else extern static const char sver extern static const char aver endif version_h draw back see include guard doesnt save include twice file 
p1337
asS'9144927'
p1338
(lp1339
Vcalls main function c  possible duplicate: c main method initially called methodinitiallycalled want know calls main function c actual use main function main specialnecessary write c program main function 
p1340
aVprogram series code bundled inside functions must starting point right something must called first run rest starting point main called parent process os ever lets program run 
p1341
aVmain function called practice c runtime write program without main _must_ entry point different operating systems allow specify different entry points program serve purpose main windows use winmain linux link without crt define _start function cannot return program without entry point like car without wheels: doesnt go anywhere 
p1342
aVask operating system run file loads memory jumps starting point _startetc point code call main exit linker responsible part write program without main function linker give error since couldnt find 
p1343
aVsimplest answer this: user program calls main function start application ever used command terminal know pass arguments command example: grep word myfile going covers terminal looks typed calls main method grep program passes word myfile second argument method simplification hope helps 
p1344
asS'21604946'
p1345
(lp1346
Vpointer pointer clarification following _pointer pointer_ work let quote relevant passage: int 5 j 6 k 7 int ip1 ip2 j set int ipp ip1 ipp points ip1 points ipp ip1 ipp 5 illustrate situation familiar boxandarrow notation like this: enter image description say ipp ip2 weve changed pointer pointed ipp ip1 contain copy ip2 ip1 points j: enter image description question is: second picture ipp still pointing ip1 ip2 
p1347
aVchanged value pointed ipp value ipp ipp still points ip1 value ipp ip1s value ip2s value point j this: ipp ip2 as: ip1 ip2 
p1348
aVipp hold value ie point _pointer pointer_ type object ipp ip2 ipp contains address variable pointer ip2 ip2 type _pointer pointer_ arrow ipp second pic point ip2 wiki operator dereference operator operates pointer variable returns lvalue variable equivalent value pointer address called dereferencing pointer applying operator ipp derefrence lvalue _pointer int_ type dereferenced lvalue ipp type _pointer int_ hold address int type data statement ipp ip1 ipp holding address ip1 ipp holding address pointing say ipp alias ip1 ipp ip1 alias ipp ip2 ipp ip2 points location ipp still pointing ip1 ipp ip2 actually copies contents ip2 address j ip1 ipp alias ip1 effect making pointers ip1 ip2 pointing object j second figure arrow ip1 ip2 pointing j ipp still pointing ip1 modification done change value ipp 
p1349
aVadd dereference operator pointer redirect pointer pointedto object examples: int 0 int p nb pointer declaration also uses dereference operator context p expression uses pointedto object p expression uses pointer object p therefore: ipp ip2 change pointer ipp points ipp therefore ipp still points ip1 afterwards 
p1350
aV ipp ip1 later assignment changed value ipp still points ip1 ipp ie ip1 change fact ipp points ip1 
p1351
aVnotice assignments: ipp ip1 results ipp point ip1 ipp point ip2 change similar manner ipp ip2 clearly instead changing value address pointed ipp folowing ipp ip2 replacing value stored ip1 ipp ip1 means ipp ip1 ipp ip2 j ipp ip2 essentially ip1 ip2 
p1352
aVforget second pointing analogy pointer really contains memory address address operator ie returns address memory object operator gives object pointer refers ie given pointer containing address returns object memory address ipp ip2 ipp get object address held ipp ip1 assign ip1 value stored ip2 address j simply \u005c address \u005c value 
p1353
aVyoud want ipp point ip2 youd say ipp ip2 however would leave ip1 still pointing 
p1354
aVsay ipp ip2 youre saying object pointed ipp point direction memory ip2 pointing youre saying ipp point ip2 
p1355
aVbeginning set ipp ip1 dereference ipp ip1 becomes 1 ipp ip1 hence proved 
p1356
aV question is: second picture ipp still point ip1 ip2 placed nice pictures im going try make nice ascii art: like @robertsbarnes said answer: _forget pointers_ points think terms memory basically int means contains address variable int contains address variable contains address variable use pointers algebra access values addresses: foo means address foo foo means value address contained foo pointers dealing memory best way actually make tangible show pointers algebra memory heres programs memory simplified purpose example: name: j ip1 ip2 ipp addr: 0 1 2 3 4 mem : initial code: int 5 j 6 int ip1 ip2 j heres memory looks like: name: j ip1 ip2 addr: 0 1 2 3 mem : 5 6 0 1 see ip1 ip2 gets addresses j ipp still exists dont forget addresses simply integers stored special type declare defined ipp as: int ipp ip1 heres memory: name: j ip1 ip2 ipp addr: 0 1 2 3 4 mem : 5 6 0 1 2 youre changing value pointed address stored ipp address stored ip1: ipp ip2 programs memory name: j ip1 ip2 ipp addr: 0 1 2 3 4 mem : 5 6 1 1 2 nb: int special type prefer always avoid declaring multiple pointers line think int x int x y notation misleading prefer write int x int y hth 
p1357
aVhope piece code help include iostream include stdioh using namespace std int main int 5 j 6 k 7 int ip1 ip2 j int ipp ip1 printfaddress value i: p\u005cn printfaddress value j: p\u005cn j printfvalue ip1: p\u005cn ip1 printfvalue ip2: p\u005cn ip2 printfvalue ipp: p\u005cn ipp printfaddress value ipp: p\u005cn ipp printfvalue address value ipp: d\u005cn ipp ipp ip2 printfvalue ipp: p\u005cn ipp printfaddress value ipp: p\u005cn ipp printfvalue address value ipp: d\u005cn ipp outputs: enter image description 
p1358
aVconsidere variable represented like this: type : name adress value variables represented like int : 5 j j 6 k k 5 int : ip1 ip1 ip1 ip1 j int : ipp ipp ip1 value ipp ip1 inctruction: ipp ip2 changes value addess ip1 value ip2 means ip1 changed: ip1 ip1 ip1 ip1 j ipp still: ipp ipp ip1 value ipp still ip1 means still points ip1 
p1359
aVpersonal opinion pictures arrows pointing way make pointers harder understand make seem like abstract mysterious entities like everything else computer pointers _numbers_ name pointer fancy way saying variable containing address therefore let stir things around explaining computer actually works int name value 5 stored memory like everything stored memory needs address wouldnt able find lets say ends address 0x12345678 buddy j value 6 ends assuming 32bit cpu int 4 bytes pointers 4 bytes variables stored physical memory like this: address data meaning 0x12345678 00 00 00 05 variable 0x1234567c 00 00 00 06 variable j want point variables create one pointer int int ip1 one int ip2 like everything computer pointer variables get allocated somewhere memory lets assume end next adjacent addresses memory immediately j set pointers contain addresses variables previously allocated: ip1i copy address ip1 ip2j happens lines is: address data meaning 0x12345680 12 34 56 78 variable ip1equal address 0x12345684 12 34 56 7c variable ip2equal address j got yet 4 byte chunks memory containing numbers theres mystical magical arrows anywhere sight fact looking memory dump cant tell whether address 0x12345680 contains int int difference program chooses use contents stored address task program actually tell cpu numbers add yet another level indirection int ipp ip1 get chunk memory: address data meaning 0x12345688 12 34 56 80 variable ipp pattern seem familiar yet another chunk 4 bytes containing number memory dump fictional little ram could manually check pointers point peek whats stored address ipp variable find contents 0x12345680 course address ip1 stored go address check contents find address finally go address find number 5 take contents ipp ipp get address pointer variable ip1 writing ippip2 copy ip2 ip1 equivalent ip1ip2 either case would get address data meaning 0x12345680 12 34 56 7c variable ip1 0x12345684 12 34 56 7c variable ip2 examples given big endian cpu 
p1360
aVlike beginner questions c tag question answered going back first principles: pointer kind value variable contains value operator turns variable pointer operator turns pointer variable technically say lvalue instead variable feel clear describe mutable storage locations variables variables: int 5 j 6 int ip1 ip2 j variable ip1 _contains_ pointer operator turns pointer pointer value assigned ip1 ip1 _contains_ pointer variable ip2 _contains_ pointer operator turns j pointer pointer assigned ip2 ip2 _contains_ pointer j int ipp ip1 variable ipp contains pointer operator turns variable ip1 pointer pointer value assigned ipp ipp contains pointer ip1 lets sum story far: contains 5 j contains 6 ip1 contains pointer ip2 contains pointer j ipp contains pointer ip1 say ipp ip2 operator turns pointer back variable fetch value ipp pointer ip1 turn variable variable ip1 course therefore simply another way saying ip1 ip2 fetch value ip2 pointer j assign pointer value ip1 ip1 pointer j changed one thing: value ip1: contains 5 j contains 6 ip1 contains pointer j ip2 contains pointer j ipp contains pointer ip1 ipp still point ip1 ip2 variable changes assign count assignments cannot changes variables assignments start assigning j ip1 ip2 ipp assign ipp weve seen means assign ip1 since didnt assign ipp second time didnt change wanted change ipp youll actually assign ipp: ipp ip2 instance 
p1361
aVchanging pointer ipp means 1 ipp varaiable namego inside 2 inside ipp address ip1 3 ipp go adress inside ip1 ip1 ippieip1 ip2 ip2 contain address jso ip1 content replace contain ip2ie address j changing ipp content thats 
p1362
aVipp ip2 implies: assign ip2 variable pointed ipp equivalent to: ip1 ip2 want address ip2 stored ipp simply do: ipp ip2 ipp points ip2 
p1363
asS'8284940'
p1364
(lp1365
Vsingle line comments ansic im used mark single line comment java visual studio surprised exist ansic using comment quite annoying way mark single line comment using ansic 
p1366
aVsorry looks like ansic comment used 
p1367
aVcould also write macro: define commentx int main commenthi return 0 nothing obvious ansi c youre correct noting style valid ansi c 89 
p1368
aVansic current c99 standard allows 
p1369
aVwell ansi c c99 allows comments starting extending end line previously published standard c89c90 comments werent described many compilers accepted extra anyway yet another option commenting: 0 endif construction usually used commenting inactive code 0 comment endif 
p1370
asS'16316823'
p1371
(lp1372
Vconfusion different file modes open say binary file want append end following ways seem work filevar fopenfilename wb filevar fopenfilename rb read documentation im clear difference two methods opening file w overwrite file doesnt exist already append end file havent tried using seems thing r question: exactly difference three ways opening file r w 
p1373
aVr starts beginning file create new file doesnt exists w truncates existing file zero length file exists otherwise creates new file starts end file file exists otherwise creates new file _access modes r w opens file read write mode difference:_ r w read write file r truncate delete content file well doesn\u2019t create new file file doesn\u2019t exits w truncate content file well create new file file doesn\u2019t exists 
p1374
aVlike website says: r open file reading amp writing file must exist w open file reading amp writing file exists truncate file remove contents open file reading amp writing reading allowed location write end file ie append 
p1375
asS'2395465'
p1376
(lp1377
Vcreate file linux using c trying create write file c linux ubuntu code: int fd2 open tmptestsvg o_rdwro_creat fd2 1 files created xr mode create open command prompt xr 1 michael michael 55788 20100306 21:57 testtxt xr 1 michael michael 9703 20100306 22:41 testsvg 
p1378
aVneed threeargument form open specify o_creat omit third argument open uses whatever value happens stack third argument expected seldom coherent set permissions example appears decimal 12 octal 014 stack third argument permissions file modified umask value int fd2 opentmptestsvg o_rdwr o_creat s_irusr s_irgrp s_iroth note create file without write permissions anyone else process still able write current process seldom need use execute bits files created program unless writing compiler svg files normally executables s_xxxx flags come sysstath fcntlh \u2014 use either header get information open declared fcntlh note fixed file name absence protective options o_excl make even revised open call somewhat unsafe 
p1379
aVgive access permissions third parameter: int fd2 opentmptestsvg o_rdwro_creat 0777 originally 777 see comments fd2 1 use file descriptor closefd2 read write execute permissions given user group others modify 3rd parameter according use 
p1380
asS'330793'
p1381
(lp1382
Vinitialize struct accordance c programming language standards want initialize struct element split declaration initialization have: typedef struct my_type boolean flag short int value double stuff my_type void functionvoid my_type true 15 0123 way declare initialize local variable my_type accordance c programming language standards c89 c90 c99 c11 etc anything better least working update ended static initialization element set every subelement according needs 
p1383
aV void functionvoid my_type aflag true avalue 15 astuff 0123 
p1384
aVyouve almost got my_type true150123 quick search struct initialize c 
p1385
aVmytype true 15 0123 would fine c99 
p1386
aVcompound literal according page works c99 also counts ansi c my_type my_type flag true value 123 stuff 0456 my_type value 234 stuff 1234 flag false designations initializers optional could also write: my_type true 123 0456 my_type false 234 1234 
p1387
aVansi c99 use designated initializer initialize structure: my_type flag true value 123 stuff 0456 edit: members initialized zero: omitted field members implicitly initialized objects static storage duration 
p1388
aVsee youve already received answer ansi c 99 ill throw bone ansi c 89 ansi c 89 allows initialize struct way: typedef struct item int float b char name item int mainvoid item item 5 22 george return 0 important thing remember moment initialize even one object variable struct variables initialized default value dont initialize values struct variables contain garbage values good luck 
p1389
aVron nuni said: typedef struct item int float b char name item int mainvoid item item 5 22 george return 0 important thing remember: moment initialize even one objectvariable struct variables initialized default value dont initialize values struct ie declare variable variablemembers contain garbage values declaration local declaration global static like case uninitialized variablemembers initialized automatically to: 0 integers floating point \u005c0 char course 0 char integer type null pointers 
p1390
aVms updated c99 my_type true150123 
p1391
aVfound another way initialize structs struct: typedef struct test int num char str test initialization: test tt num: 42 str: nice per gcc\u2019s documentation syntax obsolete since gcc 25 
p1392
aVdidnt like answers made dont know ansi c gcc 421 default mode never remember bracketing start subset data battle compiler error messages shuts readability first priority header: typedef unsigned char uchar struct fields uchar num uchar lbl35 actual c file 2 case struct fields labels 0package 1version 2apport 3architecture 4bugs 5descriptionmd5 6essential 7filename 8ghcpackage 9gstreamerversion 10homepage 11installedsize 12md5sum 13maintainer 14modaliases 15multiarch 16nppdescription 17nppfile 18nppname 19origin data may start life tabdelimited file searchreplace massage something else yes debian stuff one outside pair indicating array another pair struct inside commas putting things header isnt strictly necessary ive got 50 items struct want separate file keep mess code easier replace 
p1393
aVc programming language standard isoiec 9899:1999 commonly known c99 allows one use designated initializer initialize members structure union follows: my_type stuff 0456 flag true value 123 defined paragraph 7 section 678 initialization isoiec 9899:1999 standard as: designator form identifier current object defined shall structure union type identifier shall name member type note paragraph 9 section states that: except explicitly stated otherwise purposes subclause unnamed members objects structure union type participate initialization unnamed members structure objects indeterminate value even initialization gnu gcc implementation however omitted members initialized zero zerolike typeappropriate value stated section 627 designated initializers gcc documentation: omitted field members implicitly initialized objects static storage duration microsoft visual c compiler support designated initializers since version 2013 according official blog post c conformance roadmap roadmap paragraph initializing unions structs initializers msdn visual studio documentation suggests unnamed members initialized zerolike appropriate values similarly gnu gcc new isoiec 9899:2011 standard commonly known c11 superseded isoiec 9899:1999 retains designated initializers section 679 initialization also retains paragraph 9 unchanged 
p1394
asS'27339250'
p1395
(lp1396
Vc programming error: arguments function whatevers inside functions work arent compiler says error: arguments function whatevers inside beginner c forgive stupidness would also like know function include stdioh include stdlibh include mathh int x int y int multiply int x int y printf return xy getchar scanfd x scanfd y printf:\u005cn multiplyx y int add int x int y printf return xy getchar scanfd x scanfd y printf:\u005cn addx y int divide int x int y printf return xy getchar scanfd x scanfd y printf:\u005cn dividex y int subtractint x int y printf return xy getchar scanfd x scanfd y printf:\u005cn dividex y int powerint x int y printf powx y getchar scanfd x scanfd y printf:\u005cn powerx y main code int mainvoid int option switch option case 1: add break case 2: subtract break case 3: multiply break case 4: divide break case 5: power break getchar 
p1397
aVhavent passed parameters functions also intending use global variables dont use global names local variables like parameters functions eg: add12 subtract12 also part return doesnt get executed cuz returned immediately 
p1398
aVpass correct values functions calling eg call add call like : add5 4 remove void mainvoid work vote like answer 
p1399
aVprobably looking following code: include stdioh include mathh int multiply int x int y return xy int add int x int y return xy int divide int x int y return xy int subtractint x int y return xy int powerint x int y return powx y main code int mainvoid int option result x y printfenter numbers:\u005cn scanfddxy printf1 add\u005cn2 subtract\u005cn3 multiplu\u005cn4 divide\u005cn5 power\u005cnenter choice:\u005ct scanfdoption switch option case 1: result addxy break case 2: result subtractxy break case 3: result multiplyxy break case 4: result dividexy break case 5: result powerxy break printf\u005cnrequired result dresult getchar might want include condition code like division 0 shouldnt allowed et cetra 
p1400
asS'18914106'
p1401
(lp1402
Vuse using namespace std use using namespace std id like see explanation layman terms 
p1403
aVmake call using namespace some_namespace symbols namespace become visible without adding namespace prefix symbol may instance function class variable eg add using namespace std write cout instead std::cout calling operator cout defined namespace std somewhat dangerous namespaces meant used avoid name collisions writing using namespace spare code loose advantage better alternative use specific symbols thus making visible without namespace prefix eg: include iostream using std::cout int main cout world return 0 
p1404
aVusing namespace command std little something called library std stands standard write using namespace std bringing everything library class quite like using include command library pretty much big bunch classes headers help certain areas programming librarys give many functions solve complicated math problems librarys might help load images graphics computer screen many help things although librarys usually downloaded std library doesnt need downloaded comes c language std library actually contains classes functions help standard stuff like: logging text console making string variable hold unlimited letters etc probably explain bit using namespace command namespace c way put code scope code outside scope cannot see code inside namespace order code outside namespace see code inside namespace must use using namespace command class put inside namespace scope namespace mynamespace class myclass class stuff actually make namespacesi one must give name called mine mynamespace see want access classwhich inside namespace mynamespace would add using namespace mynamespace command top file 
p1405
aV using: going use namespace: use namespace std: std namespace features c standard library string vector declared write instruction compiler sees string know may referring std::string sees vector know may referring std::vector provided included compilation unit header files defined course _dont_ write compiler sees string vector know refering need explicitly tell std::string std::vector dont get compile error 
p1406
asS'15883743'
p1407
(lp1408
Vread file store variable c trying ready character character file store variable require first line file using \u005cn eof stop reading character require spaces stored also hear program getting warning compiling like comparison pointer integer run getting segmentation fault includestdioh includestringh void main file fp char ch char txt30 int len fpfopenhellotxtr chfgetcfp whilech eof ch\u005cn txtlench len chfgetcfp putstxt 
p1409
aVyoure comparing wrong thing try: ch \u005cn also spotted answers youre using len without initializing finally realize fgets well could rewrite thing to: fgetstxt sizeof txt fp 
p1410
aVlen initialised youre probably attempting write way beyond end txt fix simple initialise 0 declaration int len 0 addition error pointed cnicutar also check return value fopen using fp 
p1411
aV1 len initiated int len0 2 fgetc int fgetc file stream fgetc return int char define ch int int ch 3 addition _cnicutar_ remark condition checked : whilech eof ch\u005cn 4 add null terminator charachter end txt buffer finishing reading file add line loop txtlen\u005c0 btw read first line fscanf easier use following code fscanffp 29\u005cn txt \u005cn means fscanf read characters fp except \u005cn charachter stop reading gets charachter fscanf read characters fp till find \u005cn character save buffer txt null terminator charchter end 29\u005cn means fscanf read characters fp till find \u005cn character till reach 29 readed charchters save buffer txt null terminator charchter end 
p1412
aV includestdioh includestringh void main file fp char ch char txt30 int len 0 fpfopenhellotxtr iffp printfcannot open file\u005cn return chfgetcfp whilech eof ch \u005cn len 30 txtlen ch len chfgetcfp txtlen 0 putstxt 
p1413
aVprogram may help solve problem includestdioh int main file fp int ch char txt300 int len0 fpfopentenlinestxtr chfgetcfp txtlench len whilecheof ch\u005cn fclosefp putstxt return 0 
p1414
asS'2251452'
p1415
(lp1416
Vreturn value thread c iam new c would like play threads bit would like return value thread using pthread_exit code follows: include pthreadh include stdioh void mythread int ret 42 pthread_exitret int main pthread_t tid void status pthread_createtid null mythread null pthread_jointid status printfd\u005cnintstatus return 0 would expect program output 42\u005cn outputs random number print returned value edit: according first answers problem returning pointer local variable best practice returningstoring variables multiple threads global hash table thanks advance 
p1417
aVthink store number heap int ret variable stack destructed end execution function mythread void mythread int ret mallocsizeofint ret null ret 42 pthread_exitret dont forget free dont need : another solution return number value pointer like neil butterworth suggests 
p1418
aVyouve returned pointer local variable thats bad even threads arent involved usual way thread starts thread joins would pass pointer int location managed caller 4th parameter pthread_create becomes parameter threads entrypoint like use thread exit value indicate success: include pthreadh include stdioh int something_workedvoid thread operation might fail heres silly example void p malloc10 freep return p 1 : 0 void mythreadvoid result something_worked intresult 42 pthread_exitresult else pthread_exit0 int main pthread_t tid void status 0 int result pthread_createtid null mythread result pthread_jointid status status 0 printfd\u005cnresult else printfthread failed\u005cn return 0 absolutely use thread exit value structure youll dynamically allocate make sure whoever joins thread frees thats ideal though 
p1419
aVreturning reference _ret_ variable stack 
p1420
aVreturning address local variable longer exists thread function exits case call pthread_exit simply return value thread function void mythread return void 42 main: printfd\u005cnintstatus need return complicated value structure probably easiest allocate dynamically via malloc return pointer course code initiated thread responsible freeing memory 
p1421
aVquestion : best practice returningstoring variables multiple threads global hash table totally depends want return would use want return status thread say whether thread completed intended use pthread_exit use return statement return value thread function want information used processing use global data structure case need handle concurrency issues using appropriate synchronization primitives allocate dynamic memory preferrably structure want store data send via pthread_exit thread joins update another global structure way one main thread update global structure concurrency issues resolved need make sure free memory allocated different threads 
p1422
aVyoure uncomfortable returning addresses single variable eg integer value return even typecast void passing collect main typecast int value without throwing ugly warnings 
p1423
aVcorrect solution case tdata allocated main thread space thread place result include pthreadh include stdioh typedef struct thread_data int int b int result thread_data void mythreadvoid arg thread_data tdatathread_data arg int atdataa int btdatab int resultab tdataresultresult pthread_exitnull int main pthread_t tid thread_data tdata tdataa10 tdatab32 pthread_createtid null mythread void tdata pthread_jointid null printfd d d\u005cn tdataa tdatab tdataresult return 0 
p1424
aV includestdioh includepthreadh void myprintvoid x int k int x printf\u005cn thread created value k d\u005cnk k 11 pthread_exitvoid k int main pthread_t th1 int x 5 int y pthread_createth1nullmyprintvoidx pthread_jointh1voidy printf\u005cn exit value d\u005cny 
p1425
asS'16367190'
p1426
(lp1427
Vrun c program using command prompt run c program using command prompt win 7 codeblocks installed location c file different default location 
p1428
aV 1 compile link project 2 open command window 3 change directory executable created 4 run executable 
p1429
aVim windows guru pretty easy page here: c file text file codeblocks fancy texteditor text file click compile codeblocks invokes compiler program translates c instructions textfile binary run following command go main directory cd c:\u005c run dir b myfilec looking uncompiled c file looking binary: dir b myfileexe run program : c:\u005cpath_to_program\u005cprogramexe 
p1430
asS'4448661'
p1431
(lp1432
Vexact definition token problem catch real meaning term token terms software development define generically different meanings terms different contexts languages thanks 
p1433
aVtoken object value 
p1434
aVwikipedia disambiguation term refer computing section: 
p1435
aVone meaning terms software development authentication signature issued server defined time interval 
p1436
aVgoogle define:token get amongst others following two definitions seem applicable: individual instance type symbol word error contains three tokens r something serving sign something else combine two land somewhere near commonly meant talking tokens programming _a symbol representing something_ pretty vague yes used many different contexts one example: authentication system user logs system authenticated user instead repeating process every request token created represents fact user authenticated token used subsequent requests case _something_ fact user authenticated token represents fact 
p1437
aVtoken seen seal middle age courrier representig king duke bishop pope anything went riding realm realm needed authenticated true representative claim passing gates kingdom show letter specific seal showing medal special coin engraved like others token like one items 
p1438
aVtoken single element programming language 5 token categories : reserved words operators identifiers constants separators 
p1439
aVtokens smallest individual unit program suppose written lines c language c language awesome language c developed dennis ritchie atampt bell labs 1972 focus line find made alphabets az az blank spaces digits 09 special characters full stop case building blocks basic elements sentence tokens similar basically five types token programming 1 keyword 2 identifier 3 operator 4 separator 5 literals read tokens programming tokenshtml 
p1440
aVcompiler lexical analyzer scanner : reads input stream fuses characters source text tokens language token : sequence characters collective meaning character sequence forming token called lexeme _this example might help_ consider following assignment statement newvalue oldvalue rate 60 lexical analyzer generate following tokens token lexeme identifier newvalue assignop identifier oldvalue addop identifier rate mulop number 6 
p1441
aVtokens are: identifiers keywords literals operators punctuators cant consider white spaces comments tokens though act separators tokens 
p1442
asS'18806392'
p1443
(lp1444
Vtypedefstruct declarations difference two declarations someone could explain detail: typedef struct atom int element struct atom next typedef struct int element struct atom next atom 
p1445
aVnormal structure declaration struct atom int element struct atom next declaration creation object struct atom object struct atom int element struct atom next object creation object along structure declaration type definition struct atom type typedef struct atom int element struct atom next atom_t creating new type atom_t alias struct atom creation object atom_t object struct atom object ways allowed 
p1446
aVpurpose typedef give name type specification syntax is: typedef specification name youve done use name much like builtin types language declare variables first example specification everything starting struct atom theres name havent given new name type specification using name struct declaration defining new type want use name always precede struct keyword declare: struct atom declare new variables with: struct atom my_atom cant declare simply atom my_atom latter use typedef note one notable differences c c c declaring struct class type _does_ allow use variable declarations dont need typedef typedef still useful c complex type constructs function pointers probably look questions related sidebar explain nuances subject 
p1447
aVgeneral syntax typedef keyword be: typedef existing_data_type new_data_type typedef struct record char ename30 int ssn int deptno employee 
p1448
asS'724261'
p1449
(lp1450
Vunions versus structures c idea behind question understand deeper concepts using union using different way save memory question lets say structure struct strt float f char c int structure represented union union unin float f char c int allocate values structure members one another print gets printed case union doesnt happen overwriting done need find method store values fca using union print apply operations anything search technique anybody guide give idea 
p1451
aVthink misunderstand purpose union union name suggests defines structure members occupy memory space whereas struct places members separate memory single contiguous area union write: union foo fooc 3 fooa foof changed c f stored _at memory location_ thus member union different view memory happen struct members distinct separate way around behavior _because intentional_ 
p1452
aVunion contains set mutually exclusive data particular example store float _f_ char _c_ int _a_ union however memory allocated _largest item_ union items union share portion memory words writing one value union followed another cause first value overwritten need go back ask modelling: truly want values _f_ _c_ _a_ mutually exclusive ie one value exist consider using union conjunction enum value stored outside union indicating member union active one particular point time allow get memory benefits using union cost dangerous code anyone maintaining need aware values mutually exclusive ie indeed union _only consider option creating many unions memory conservation vital eg embedded cpus may even end saving memory need create enum variables stack take memory too_ want values simultaneously active interfere need use struct instead put first example use memory instantiate struct memory allocated sum members plus padding nearest word boundary _unless memory conservation paramount importance see previous example would favour approach_ edit: simple example use enums conjunction union: typedef union float f char c int floatcharintunion typedef enum usingfloat usingchar usingint unionselection int main floatcharintunion myunion unionselection selection myunionf 31415 selection usingfloat processunionmyunion selection myunionc selection usingchar processunionmyunion selection myuniona 22 selection usingint processunionmyunion selection void processunionfloatcharintunion myunion unionselection selection switch selection case usingfloat: process myunionf break case usingchar: process myunionc break case usingint: process myuniona break 
p1453
aVunions usually used one would stored instance given point time ie either store float char int instant save memory allocating extradistinct memory float int going use store char amount memory allocated largest type union union unin float f char c int use union want store something parts let sat may want model register union containing upper byte lower byte composite value store composite value union use members get pieces via members 
p1454
aVlook struct stores values would something like this: 012345678 ffffffffffffffff f: float stored cccc c: char stored aaaaaaaaaaaaaaaa a: int stored change value f actually changing bytes 03 change char actually changing byte 4 change int actually changing bytes 58 look union stores values would something like this: 0123 ffffffffffffffff f: float stored cccc c: char stored aaaaaaaaaaaaaaaa a: int stored change value f changing bytes 03 since c stored byte 0 change f also change c change c youre changing part f change youre changing c f thats overwriting happening pack 3 values one memory address youre saving space youre creating 3 different ways looking changing data dont really int float char union physical level youve got 32 bits could viewed int float char changing one _meant_ change others dont want change use struct gcc tells struct 9 bytes long union 4 saving space structs unions thing 
p1455
aVclassic example using union store data depending external marker int float char occupy place union consecutive need store structure youre looking union structure size largest thing union plus size type since outside union define typ_int 0 define typ_flt 1 define typ_str 2 typedef struct int type union data int float b char c tmytype static void printmytype tmytype x xtype typ_int printf d\u005cn xdataa return xtype typ_flt printf f\u005cn xdatab return xtype typ_str printf s\u005cn xdatac return printmytype function correctly detect whats stored structure unless lie print relevant value populate one do: xtype typ_int xdataa 7 xtype typ_str xdatac given x one thing time woe betide anyone tries: xtype typ_str xdataa 7 theyre asking trouble 
p1456
aVthink misunderstanding unions idea behind using unions toe save memory yes thats one reason get result equivalent structure equivalent looks similar source code completely different thing like apples airplanes unions low level construct allows see piece memory storing members use one time even use word member extremely misleading called views something members write: union abcunion int double b char c myabc saying: take piece memory big enough biggest among int char double lets call _myabc_ memory store either int double char store int store double int gone forever whats point two major uses unions discriminated storage thats pick piece memory give different meanings depending context sometimes context explicit keep variable indicates kind variable stored sometimes implicit based section code tell one must use either way code needs able figure wont able anything sensible variable typical explicit example would be: struct myvarianttype int typeindicator type1 int type2 double type3 char abcunion body example vb6s variants unions unlike complex b split representation sometimes useful need able see variable either whole combination parts easier explain example: union doublebyte struct unsigned char unsigned char b bytes short integer myvar heres short int unioned pair bytes view value either short int myvarinteger easily study individual bytes make part value myvarbytesa myvarbytesb note second use portable im pretty sure meaning guaranteed work across different machine architectures use absolutely essential kind tasks c designed os implementation 
p1457
asS'76246'
p1458
(lp1459
Vsetting file permissions bash script script working way thought would though would find scripts every one rwx permissions changed permissions xx5 binbash makes find inclusive file find perm 007 permissionsstat c file permissionspermissions:0:25 echo permissions file chmod permissions file done find perm 007 intentions least secure files 
p1460
aV007 show files permissions owner group permissiosn rwx might luck orwx match permissions file edit correctness: apparently youll need use perm orwx o inclusive filter would match files xwxwrrxrw rwx permissions changing leading character filter makes filter exclusive would match files rwx field 
p1461
aVapproach performance nightmare: create two processes every file one completely uselessly find already information easily print better solution: find perm orwx printf m p_\u005c0 2devnull read r d perms path pathpath_ echo perms path 2 printf s\u005c0 path done xargs 0 chmod orx 
p1462
aV chmod r ow remove write permissions _others_ every file safe way however update ctime every file including ones _others_ already didnt write access gnu chmod make show files needed updated c option: chmod cr ow mode changed 0777 rwxrwxrwx 0775 rwxrwxrx want remove w _others_ rwx do: find type l perm 7 exec chmod ow add vv gnu freebsd chmod see details especially since youre dealing world writeable files beware theres race condition someone bad intentions write access directories could replace file symlink file time find checks chmod executed remove write permissions file instead cause havoc think symlink tmp instance since youre using gnu stat syntax chances find gnu find note gnu find could display file attributes long gnu stat introduced dont need find type l perm 7 printf m p\u005cn exec chmod ow 
p1463
asS'39034450'
p1464
(lp1465
Vreturn type c specify return type compiler assumes implicit return type int tried return char worked fine gcc defined like include stdioh char funchar ch return ch int main char ch funa printfch : c\u005cnch program specify return type include stdioh char funchar ch int main char ch funa printfch : c\u005cnch worked fine means return char return int return type default 
p1466
aVactually cases specified return type second case function : char funchar ch specifies char return type specified second case return value function lead undefined behavior _note_ : general function declaration following structure : return_type function_name parameter list body function clearly declared return type function char see link information 
p1467
aVpointing seem goal return value misunderstood function declarations declaring function forced give body telling compiler somewhere full program function : char funchar ch int main char ch funa still valid c compile object file telling compiler function exists exists later quite helpful using library object files linked form final program unfortunately c compilers still smart enough infer exactly intention write int main char ch funa try best guess defaulting mostly wrong type fun stop guessing would wrong one practical example would funcc char funchar ch return ch compile cc c func compile funo object file mainc include stdioh char funchar ch fun exist func mainc way yo tell function exists int main char ch funa printfch : c\u005cnch compile cc c mainc compile maino object file link two files cc funo maino o main link two object file program main return statement return statement two goal set value send caller stop execution flow current function return caller execution flow function prototype declare function would return seems quite extra code one return statement per function would make sure keeping promise two return statement function returning different type inferred type function returning int computer store char char big return struct instead 
p1468
asS'779910'
p1469
(lp1470
Vuse char argv char argv c im learning c wondering one use main method difference edit: one common use 
p1471
aVuse either two forms c arrays pointers interchangeable function parameter lists see pointer_interchangeability 
p1472
aVdoesnt really make difference latter readable given array char pointers like second version says implicitly converted double char pointer like first version however 
p1473
aVdoesnt make difference use char argv shows fixed size array variable length strings usually char 
p1474
aVchar \u2192\u3000pointer character pointer char argv means array character pointers use pointer instead array used 
p1475
aVcould use either depends want use char argv mostly equivalent char argv forms pointer pointers char difference char argv informing compiler value argv wont change though values points still actually im wrong theyre completely equivalent see litb answer charargvinc780147780147 really depends want use could use either case: echowithpointerarithmeticc include stdioh int mainint argc char argv argc 0 printfs argv printf\u005cn return 0 echowithoutpointerarithmeticc include stdioh int mainint argc char argv int i1 iargc printfs argvi printf\u005cn return 0 common doesnt matter experienced c programmer reading code see interchangeable right conditions like experienced english speaker reads theyre equally easily important learn read recognize similar youll reading code write youll need equally comfortable 
p1476
aVyoull need varying dynamic number strings char might easier work youre number string fixed though char var would preferred 
p1477
aVlearning c recommend really try understand _differences_ arrays pointers first instead _common_ things area parameters arrays confusing rules clear going first declare parameter list treated special situations things dont make sense function parameter c functions parameters arrays parameters arrays parameters second maybe immediately clear becomes clear consider size array dimension part type c array whose dimension size isnt given incomplete type would create function takes array byvalue receives copy could one size addition arrays become large c tries fast possible c reasons arrayvalues existent want get value array get instead pointer first element array herein actually already lies solution instead drawing array parameter invalid upfront c compiler transform type respective parameter pointer remember important parameter wont array instead pointer respective element type try pass array passed instead pointer arrays first element excursion: functions parameters completion think help better understand matter lets look state affairs try function parameter indeed first wont make sense parameter function huh want variable place course compiler happens transform function function pointer trying pass function pass pointer respective function instead following analogous array example: void fvoid gvoid void fvoid gvoid note parentheses around g needed otherwise would specify function returning void instead pointer function returning void back arrays said beginning arrays incomplete type happens dont give size yet since already figured array parameter existant instead array parameter pointer arrays size doesnt matter means compiler translate following thing: int mainint c char argv int mainint c char argv int mainint c char argv1 int mainint c char argv42 course doesnt make much sense able put size thrown away reason c99 came new meaning numbers allows things appear brackets: says: argv nonnull pointer pointing least 5 chars allows cpu preload memory int mainint c char argvstatic 5 says: argv constant pointer pointing char int mainint c char argvconst says previous one int mainint c char const argv last two lines say wont able change argv within function become const pointer c compilers support c99 features though features make clear array isnt actually one pointer word warning note said true got array parameter function work local arrays array wont pointer _behave_ pointer explained earlier array converted pointer value read confused pointers one classic example following: char c10 char c c work typedef char array10 array pc c work without typedef parens needed higher precedence analogous function example char array10 c 
p1478
aVsee special merit using either approach instead use convention line rest code 
p1479
aVknow outdated learning c programming language anything major dont use commandline options using command line arguments dont use either declare main function int main want user program able drag file onto program change outcome program want handle commandline optionshelp thing goes program name terminal command prompt use whichever makes sense otherwise use int main end wanting add commandline options easily edit later 
p1480
aVdeclare char argv many equivalent ways declaring comes closest intuitive meaning: array strings 
p1481
asS'19429138'
p1482
(lp1483
Vappend end file c im trying append contents file myfiletxt end second file myfile2txt c copy contents cant find way append heres code: file pfile file pfile2 char buffer256 pfilefopenmyfiletxt r pfile2fopenmyfile2txt r ifpfilenull perrorerror opening file else whilefeofpfile iffgetsbuffer 100 pfile null fseekpfile2 100 seek_end fprintfpfile2 buffer fclosepfile fclosepfile2 dont think im using fseek correctly im trying call fseek put pointer end file write location pointer instead beginning file right approach 
p1484
aVopen append: pfile2 fopenmyfile2txt write pfile2 need fseek 
p1485
aVfollowing documentation fopen: open writing file created exist stream positioned end file subsequent writes file always end cur rent end file irrespective intervening fseek3 similar pfile2fopenmyfile2txt stream positioned end append automatically do: file pfile file pfile2 char buffer256 pfilefopenmyfiletxt r pfile2fopenmyfile2txt ifpfilenull perrorerror opening file else whilefgetsbuffer sizeofbuffer pfile fprintfpfile2 buffer fclosepfile fclosepfile2 
p1486
asS'17397069'
p1487
(lp1488
Vunset readonly variable bash unset readonly variable bash readonly pi314 unset pi bash: pi: readonly variable possible 
p1489
aVreadonly command makes final permanent shell process terminates need change variable dont mark readonly 
p1490
aVcant manual page unset: name remove corresponding variable function options supplied v option given name refers shell variable readonly variables may unset f specifed name refers shell function function definition removed unset variable function removed environment passed subsequent commands random seconds lineno histcmd funcname groups dirstack unset lose special properties even subsequently reset exit status true unless name readonly 
p1491
aVaccording man page: unset fv name readonly variables may unset yet exported variable use exec @ restart shell course lose unexported variables well seems start new shell without exec loses readonly property shell 
p1492
aVcurrent shell wish assign new value fork new shell new meaning considered read readonly pi314 echo pi pi400 echo pi unset pi echo pi 314 400 
p1493
aVactually unset readonly variable must warn hacky method adding answer information recommendation use risk tested ubuntu 1304 bash 4245 method involves knowing bit bash source code amp inherited readonly pi314 unset pi bash: unset: pi: cannot unset: readonly variable cat eof sudo gdb attach call unbind_variablepi detach eof echo pi 
p1494
aVtried gdb hack want unset tmout disable auto logout machine tmout set read im allowed use sudo since bash process dont need sudo however syntax didnt quite work machine im work though put bashrc file: disable stupid autologout unset tmout devnull 21 ne 0 gdb eof devnull 21 attach call unbind_variabletmout detach quit eof fi 
p1495
aVspecifically wrt tmout variable another option gdb available copy bash home directory patch tmout string binary something else instance xmoux run extra layer shell timed 
p1496
aVchange read correct answer try change readonly poor practice imagine script 50000 lines relies pi programmer reads code sees readonly pi3141592 somewhere pile lines code change insane take forever trying figure problem correct thing declare readonly first place ever needs changed 
p1497
asS'4635794'
p1498
(lp1499
Vrun c program ubuntu want run c programs ubuntu 1010 college lab gave advice change os use replace xp ubuntu request college lab student daily practices c programming problems run c programs ubuntu 1010 please help meplease one give solution topic please fast thank 
p1500
aVpage help get started: one might also helpful: 
p1501
aV gcc o g myprogram myprogramc myprogram 
p1502
aV 1 open terminal window 2 compile source code eg youre using gcc compiler need type something like: gcc my_sourcec o my_app 3 run executable eg: my_app 
p1503
aVinstall c compiler write first code : explained testingyourfirstcandcprogramhtml 
p1504
aVanswer slightly different others: gcc ansi pedantic w wall omyprog myprogc myprog extra flags ansi pedantic w wall _incredibly_ useful following: w wall turns many many useful warnings warning messages often first hint program serious error needs immediate attention without flags compiler would give program without letting know potential problems ansi pedantic makes gcc conform strictly c standard extra strictness means less chance errors going past compiler undetected 
p1505
asS'40356368'
p1506
(lp1507
Vstorage class default global variable gcc compiler c gcc compiler default storage class global variables let share code example: int void f statements main set statements correct say variable would static extern 
p1508
aVfollowing cases variables declared outside function: static int variablewithfilescope exported visible current file int globalvariablethatisexported exported forward declaration variable defined extern int globalvariablethatisdefinedsomewhereelse defined standard applicable c compilers 
p1509
aVcode _static storage duration_ _external linkage_ _storage duration_ refers lifetime variables storage _static storage duration_ means variable exists entire lifetime program _linkage_ refers relationship names objects _external linkage_ means instances name external linkage denote object int match declaration extern int another translation unit keyword static used different contexts storage duration specifier linkage specifier clear ask whether variable static instead variables storage duration linkage considered 
p1510
asS'13122250'
p1511
(lp1512
Vcgi c file open created cgi file c html file user select file heshe wants upload problem select file value file name file directory cannot read file access file form actioncgibinpaperloadcgi methodget pretitle: input typetext nametitlebrpre preauthor: input typetext nameauthorbrpre prefile: input typefile namefilebrpre preinput typesubmit valueupload paperpre form c cgi code void getparamconst char name char value256 char pos1 strstrdata name pos1 pos1 strlenname pos1 make sure expect pos1 pos1 pos1 pos1 convert single ascii character store valueination value chartohexpos11 16 tohexpos12 pos1 3 else pos1 store space valueination value pos1 else value pos1 otherwise store character valueination value \u005c0 return strcpyvalue undefine param found use default parameter return main code check correct id data getenvquery_string getparamtitlepaperauthor_name getparamauthorpaperpaper_title getparamfilepaperpaper_file_name paper_file fopenpaperpaper_file_name r paper_file continue read reach end file whilefeofpaper_file freadpaperpaper_contentbufsiz 1 paper_file close file fclosepaper_file else fprintfstderr unable open file paperpaper_file_name exit1 even use post method problem still exists issue parse input html problem try fread main code change type html file text try give path file manually syntax 
p1513
aVdont need directory information file content attached post request need grab suggest use cgic qdecoder care process least understand parsing request headers maybe apply logic application qdecoder upload file example: 
p1514
asS'24284293'
p1515
(lp1516
Vrecommended way track array outofbound accesswrite c program consider writing implementation notsoobvious algorithm c example let recursive quicksort found k n kings c programming: modern approach 2nd edition book available consist two following definitions: void quicksortint int low int high int middle low high return middle splita low high quicksorta low middle 1 quicksorta middle 1 high int splitint int low int high int part_element alow low high part_element ahigh high low high break alow ahigh low high alow part_element low low high break ahigh alow ahigh part_element return high loops optimized removing low high tests: part_element ahigh high low high break alow ahigh ahigh part_element alow part_element low low high break ahigh alow alow part_element recommended way make sure every access write array allocated stack actually valid ie provoking undefined behaviour already tried to: manually debug gdb actual data pass source code static analysis tools like split cppcheck valgrind toolexpsgcheck switch example five elements array 8 1 2 3 4: define n 5 int mainvoid int 8 1 2 3 4 quicksorta 0 n 1 printfafter sort: 0 n printf d ai putchar\u005cn return 0 result certainly implemention dependent: sort: 1 1 2 4 8 1\u005c gdb gdb p low 1 3 gdb p high 2 4 gdb p alow 3 1 gdb p part_element 4 8 gdb 47 low gdb 46 alow part_element gdb 47 low gdb 46 alow part_element gdb p low 5 5 gdb p high 6 4 gdb bt full 0 split a0x7fffffffe140 low5 high4 qsortc:46 part_element 8 1 0x00000000004005df quicksort a0x7fffffffe140 low0 high4 qsortc:30 middle value optimized 2 0x0000000000400656 main qsortc:14 4 1 2 1 8 value optimized see low variable went outside boundary: gdb p low 5 5 2\u005c static analysis tools splint retvalint exportlocal qsortc splint 312 07 feb 2011 finished checking warnings cppcheck qsortc checking qsortc 3\u005c valgrind toolexpsgcheck valgrind toolexpsgcheck aout 5480 expsgcheck stack global array overrun detector 5480 note: experimentalclass valgrind tool 5480 copyright c 20032012 gnu gpld openworks ltd et al 5480 using valgrind381 libvex rerun h copyright info 5480 command: aout 5480 5480 invalid read size 4 5480 0x4005a0: split qsortc:46 5480 0x4005de: quicksort qsortc:30 5480 0x400655: main qsortc:14 5480 address 0x7ff000114 expected vs actual: 5480 expected: stack array size 20 frame 2 back 5480 actual: unknown 5480 actual: 0 expected 5480 sort: 1 1 2 4 8 5480 5480 error summary: 1 errors 1 contexts suppressed: 0 0 location 0x4005a0: split qsortc:46 matching place found gdb manually 
p1517
aV recommended way make sure every access write array allocated stack actually valid ie provoking undefined behaviour use clang linux options fsanitizeaddressand fsanitizeundefined also available gcc: clang option fsanitizeundefined example: include stdlibh define n 5 int mainint argc char argv int 8 1 2 3 4 int r 0 int end atoiargv1 int 0 end r ai return r clang fnoomitframepointer fsanitizeundefined g out_boundaryc o out_boundary_clang out_boundary_clang 5 out_boundary_clang 6 out_boundaryc:12:10: runtime error: index 5 bounds type int 5 illegal instruction core dumped analyze core file program terminated signal 4 illegal instruction 0 main argc2 argv0x7fff3a1c28c8 out_boundaryc:12 12 r ai gdb p 1 5 clang option fsanitizeaddress quote: tool detect following types bugs: outofbounds accesses heap stack globals useafterfree useafterreturn extent doublefree invalid free memory leaks experimental clang fnoomitframepointer fsanitizeaddress g out_boundaryc o out_boundary_clang then: out_boundary_clang 6 21 asan_symbolizepy 9634error: addresssanitizer: stackbufferoverflow address 0x7fff91bb2ad4 pc 0x459c67 bp 0x7fff91bb2910 sp 0x7fff91bb2908 read size 4 0x7fff91bb2ad4 thread t0 0 0x459c66 main out_boundaryc:12 1 0x3a1d81ed1c __libc_start_main :0 2 0x4594ac _start :0 address 0x7fff91bb2ad4 located stack thread t0 offset 244 frame 0 0x45957f main out_boundaryc:6 frame 8 objects: 32 36 96 100 160 168 224 244 288 292 352 356 r 416 420 end 480 484 i1 hint: may false positive program uses custom stack unwind mechanism swapcontext longjmp c exceptions supported shadow bytes around buggy address: 0x10007236e500: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10007236e510: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10007236e520: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10007236e530: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1 0x10007236e540: 04 f4 f4 f4 f2 f2 f2 f2 04 f4 f4 f4 f2 f2 f2 f2 0x10007236e550: 00 f4 f4 f4 f2 f2 f2 f2 00 0004f4 f2 f2 f2 f2 0x10007236e560: 04 f4 f4 f4 f2 f2 f2 f2 04 f4 f4 f4 f2 f2 f2 f2 0x10007236e570: 04 f4 f4 f4 f2 f2 f2 f2 04 f4 f4 f4 f3 f3 f3 f3 0x10007236e580: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10007236e590: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10007236e5a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 shadow byte legend one shadow byte represents 8 application bytes: addressable: 00 partially addressable: 01 02 03 04 05 06 07 heap left redzone: fa heap right redzone: fb freed heap region: fd stack left redzone: f1 stack mid redzone: f2 stack right redzone: f3 stack partial redzone: f4 stack return: f5 stack use scope: f8 global redzone: f9 global init order: f6 poisoned user: f7 asan internal: fe 9634aborting use options useful links: 
p1518
asS'4025768'
p1519
(lp1520
Vpeople find difficult c pointers number questions posted clear people pretty fundemental issues getting heads around pointers pointer arithmetic im curious know theyve never really caused major problems although first learned back neolithic order write better answers questions id like know people find difficult youre struggling pointers recently suddenly got aspects pointers caused problems 
p1521
aVgreat article supporting notion pointers hard joel spolskys site perils javaschools disclaimer javahater _per se_ 
p1522
aVproper understanding pointers requires knowledge underlying machines architecture many programmers today dont know machine works people know drive car dont know anything engine 
p1523
aVthink requires solid foundation probably machine level introduction machine code assembly represent items data structure ram takes little time homework problem solving practice thinking person knows high level languages first nothing wrong carpenter uses ax person needs split atom uses something else need people carpenters people study atoms person knows high level language given 2 minute introduction pointers hard expect understand pointer arithmetics pointers pointers array pointers variable size strings array array characters etc lowlevel solid foundation help lot 
p1524
aVmain difficulty pointers least didnt start c started java whole notion pointers really foreign couple classes college expected know c taught basics c use pointers basic sense even every time find reading c code look pointer syntax limited experience1 year real world 4 college pointers confuse ive never really use anything classroom setting sympathize students starting cs java instead c c said learned pointers neolithic age probably using ever since us newer people notion allocating memory pointer arithmetic really foreign languages abstracted away ps reading spolsky essay description javaschools nothing like went college cornell 0509 took structures functional programming sml operating systems c algorithms pen paper whole slew classes werent taught java however intro classes electives done java theres value reinventing wheel trying something higher leveled implementing hashtable pointers 
p1525
aVsuspect people going bit deep answers understanding scheduling actual cpu operations assemblylevel memory management isnt really required teaching found following holes students understanding common source problems: 1 heap vs stack storage simply stunning many people understand even general sense 2 stack frames general concept dedicated section stack local variables along reason stack details stashing return location exception handler details previous registers safely left till someone tries build compiler 3 memory memory memory casting changes versions operators much room compiler gives particular chunk memory know youre dealing problem people talk primitive variable x _really_ students able understand simplified drawing chunk memory generally local variables section stack current scope generally giving explicit fictional addresses various locations helped guess summary im saying want understand pointers understand variables actually modern architectures 
p1526
aVblame quality reference materials people teaching personally concepts c _especially_ pointers plain _taught_ badly keep threatening write c book titled _the last thing world needs another book c programming language_ dont time patience hang throw random quotes standard people theres also fact c initially designed _assumed_ understood machine architecture pretty detailed level way avoid daytoday work memory tight processors slow understand wrote affected performance 
p1527
aVdidnt get pointers read description kampr point pointers didnt make sense read whole bunch stuff people said dont learn pointers confusing hurt head give aneurysms shied away long time created unnecessary air difficultconcept otherwise mostly thought earth would want variable go hoops get value wanted assign stuff strange things get values go whole point variable something store value thought someone wanted make complicated beyond _so pointer use operator get value kind goofy variable that_ thought pointless pun intended reason complicated didnt understand pointer _address_ something explain address something contains address something else manipulate address useful things think might clear confusion class required using pointers accessmodify ports pc using pointer arithmetic address different memory locations looking complicated ccode modified arguments disabused idea pointers well pointless 
p1528
aVlooking back four things really helped finally understand pointers prior could use fully understand knew followed forms would get results desired fully understand forms realize exactly asked think useful corollary 1 writing routine took pointer integer modified integer gave necessary forms upon build mental models pointers work 2 onedimensional dynamic memory allocation figuring 1d memory allocation made understand concept pointer 3 twodimensional dynamic memory allocation figuring 2d memory allocation reinforced concept also taught pointer requires storage must taken account 4 differences stack variables global variables heap memory figuring differences taught types memory pointers pointrefer items required imagining going lower level building mental model satisfied every case could think throwing took time effort well worth convinced understand pointers build mental model work implemented back original question based previous list several items difficulty grasping originally 1 would one use pointer 2 different yet similar arrays 3 understanding pointer information stored 4 understanding pointer pointing 
p1529
aVproblem always primarily selftaught use pointer wrap head around syntax constructing pointer need know circumstances pointer used one mindset 
p1530
aVfirst started working biggest problem syntax int ip int ip int ip but: int ip1 ip2 second one isnt pointer int ip1 ip2 pointer part declaration belongs variable type dereferencing thing uses similar notation: ip 4 sets value thing pointed ip 4 x ip hey thats 4 x ip ahh theres 4 except actually need get pointer use ampersand int ip x hooray consistency apparently jerks prove clever lot library developers use pointerstopointerstopointers expect array things well pass pointer void fooippparr call need address array pointers pointers pointers ints: fooippparr six months maintain code spend time trying figure means rewriting ground yeah probably got syntax wrong since ive done anything c kinda miss im bit massochist 
p1531
aVpointers difficult indirection 
p1532
aVpointers along aspects lowlevel work require user take away magic high level programmers like magic 
p1533
aVstart saying c c first programming languages learned started c c school lot went back c fluent first thing confused pointers learning c simple: char ch char str100 scanfc ch str confusion mostly rooted introduced using reference variable arguments pointers properly introduced remember skipped writing first examples _c_ _for_ _dummies_ simple never get first program write work likely confusing ch actually meant well str didnt need became familiar next remember confused dynamic allocation realized point pointers data wasnt extremely useful without dynamic allocation type wrote something like: char x null y char z100 x z try dynamically allocate space didnt work wasnt sure would work didnt know else might work later learned malloc new really seemed like magical memory generators knew nothing might work time later taught recursion id learned class asked worked hood separate variables stored professor said stack lots things became clear heard term implemented software stacks heard others refer stack long forgotten around time also realized using multidimensional arrays c get confusing knew worked easy get tangled decided try work around using whenever could think issue mostly syntactic especially passing returning functions since writing c school next year two got lot experience using pointers data structures new set troubles mixing pointers would multiple levels pointers things like node ptr always tripping id dereference pointer wrong number times eventually resort figuring many needed trial error point learned programs heap worked sort good enough longer kept night remember reading look bytes pointer malloc certain system returns see much data actually allocated realized code malloc could ask memory os memory part executable files decent working idea malloc works really useful soon took assembly class didnt teach much pointers programmers probably think get think assembly code might translated though always tried write efficient code better idea also took couple classes write _lisp_ writing lisp wasnt concerned efficiency c little idea code might translated compiled know seemed like using lots local named symbols variables made things lot easier point wrote avl tree rotation code little bit lisp hard time writing c pointer issues realized aversion thought excess local variables hindered ability write several programs c also took compilers class class flipped ahead advances material learned _static_ _single_ _assignment_ ssa dead variables isnt important except taught decent compiler decent job dealing variables longer used already knew variables including pointers correct types good names would help keep things straight head also knew avoiding efficiency reasons even stupid less microoptimization minded professors told knowing good bit memory layout program helped lot thinking code means symbolically hardware helps using local pointers correct type helps lot often write code looks like: int foostruct frog f int x int y struct leg g fleft_leg struct toe gbig_toe processt screw pointer type clear compiler error problem did: int foostruct frog f int x int y processfleft_legbig_toe got pointer type wrong compiler error would whole lot difficult figure would tempted resort trial error changes frustration probably make things worse 
p1534
aVdealing pointers people get confused widely one two camps ive array crowd crowd straight doesnt know translate pointer notation array notation doesnt even know even related four ways access elements array: 1 array notation indexing array name 2 array notation indexing pointer name 3 pointer notation pointer name 4 pointer notation array name int vals5 10 20 30 40 50 int ptr ptr vals array element pointer notation number vals notation vals0 0 10 ptr 0 ptr0 vals 0 vals1 1 20 ptr 1 ptr1 vals 1 vals2 2 30 ptr 2 ptr2 vals 2 vals3 3 40 ptr 3 ptr3 vals 3 vals4 4 50 ptr 4 ptr4 vals 4 idea accessing arrays via pointers _seems_ pretty simple straightforward ton complicated clever things done way leave experienced cc programmers befuddled let alone inexperienced newbies reference pointer pointer pointer crowd explains difference ill citing stealing code : small example difficult see exactly author wanted came across something like this: function prototype void funcint rpint mean seriously int int main int nvar2 int pvarnvar funcpvar return 0 lesser extent something like this: function prototype void funcint ppint int main int nvar2 int pvarnvar funcpvar return 0 end day really solve gibberish nothing seen syntax ptrtoptr reftoptr advantages one afraid usage one programmers personal preferences use reftoptr say syntax cleaner use ptrtoptr say ptrtoptr syntax makes clearer reading complexity seeming bold seeming interchangeability references often another caveat pointers error newcomers makes understanding pointers hard also important understand completions sake pointers references illegal c c confusing reasons take lvaluervalue semantics previous answer remarked many times youll hotshot programmers think clever using awesome_varlol_im_so_clever us probably guilty writing atrocities times good code certainly maintainable well answer turned longer hoped 
p1535
aVupon time 8 bit microprocessors everyone wrote assembly processors included type indirect addressing used jump tables kernels higher level languages came along add thin layer abstraction called pointers years gotten away hardware necessarily bad thing called higher level languages reason concentrate want instead details done better 
p1536
aVpointer moment working telephony programs c write axe10 exchange emulator using protocol analyser understood classic c everything hinged knowing pointers tried writing code without hey prepointer cut slack failed utterly key understanding amp address operator understood meant address understanding meant contents address pointed came bit later whenever wrote read code always repeated amp meant meant eventually came use intuitively shame forced vb java pointer knowledge sharp glad postpointer dont ask use library requires understand __p though 
p1537
aVpointers way dealing difference handle object object ok necessarily objects know mean well mind point probably deal difference two modern highlevel language becomes distinction copyby value copybyreference either way concept often difficult programmers grasp however pointed syntax handling problem c ugly inconsistent confusing eventually really attempt understand pointer make sense start dealing pointers pointers ad nauseum gets really confusing well people another important thing remember pointers theyre dangerous c master programmers language assumes know heck youre thereby gives power really mess things types programs still need written c programs language provides better abstraction difference object handle suggest use indeed many modern c applications often case required pointer arithmetic encapsulated abstracted dont want developers pointer arithmetic place want centralized well tested api pointer arithmetic lowest level making changes code must done great care extensive testing 
p1538
aVnonanswer: use cdecl cdecl figure out: eisbaw@leno: cdecl explain int fooconst void 3 declare foo pointer function pointer const void returning pointer array 3 int 
p1539
aVprogrammed c like 2 years converted java5 years never looked back however recently use native stuff found amazement hadnt forgotten anything pointers even find easy use sharp contrast experienced 7 years ago first tried grasp concept guess understanding liking matter programming maturity : pointers like riding bike figure work theres forgetting hard grasp whole pointer idea educational believe understood every programmer regardless programs language pointers 
p1540
aVheres pointerarray example gave pause assume two arrays: uint8_t source16 initialization values uint8_t destination16 goal copy uint8_t contents source destination using memcpy guess following accomplish goal: memcpydestination source sizeofsource memcpydestination source sizeofsource memcpydestination0 source sizeofsource memcpydestination source sizeofsource memcpydestination source sizeofsource memcpydestination0 source sizeofsource memcpydestination source0 sizeofsource memcpydestination source0 sizeofsource memcpydestination0 source0 sizeofsource answer spoiler alert destination ampdestination ampdestination0 value ampdestination different _type_ two still value goes permutations source aside personally prefer first version 
p1541
aVthings harder understand youre grounded knowledge thats underneath taught cs got lot easier started students programming simple machine simulated decimal computer decimal opcodes whose memory consisted decimal registers decimal addresses would put short programs example add series numbers get total would single step watch happening could hold enter key watch run fast im sure almost everyone wonders useful get basic forget like knowing program playing toy computer puts place concepts without cant program ideas computation stepbystep process using small number basic primitives build programs concept memory variables places numbers stored address name variable distinct number contains distinction time enter program time runs liken learning program crossing series speed bumps simple programs loops subroutines arrays sequential io pointers data structure much easier learn reference computer really underneath finally getting c pointers confusing though kampr good job explaining way learned c know read right left like see int p head say p points int c invented one step assembly language thats like close ground pointers like anything else harder understand dont grounding 
p1542
aVadd extra dimension code without significant change syntax think this: int 5 theres one thing change: write 6 results obvious people consider: int some_int two things relevant different times: actual value pointer value behind pointer change a: some_other_int some_int still around somewhere value also change thing points to: 6 theres conceptual gap 6 local side effects 6 could affect bunch things places point concept indirection inherently tricky immediate local thing indirect thing might confuses people 
p1543
aVpersonally understand pointer even post graduation first job thing knowing need linked list binary trees passing arrays functions situation even first job started give interviews understand pointer concept deep tremendous use potential started reading k amp r writing test program whole goal jobdriven time found pointers really bad difficult taught good way unfortunately learn c graduation teacher aware pointer even assignments using less pointers graduate level use pointer really upto creating binary trees linked list thinking dont need proper understanding pointers work kill idea learning 
p1544
aVpointers hah pointer head give memory address actual values whatever reference magic learn assembly wouldnt much trouble learning pointers works come guys even java everything reference 
p1545
aVseems many students problem concept indirection especially meet concept indirection first time remember back student 100 students course handful people really understood pointers concept indirection something often use real life therefore hard concept grasp initially 
p1546
aVrecently pointer click moment surprised finding confusing everyone talked much assumed dark magic going way got imagine defined variables given memory space compile timeon stack want program could handle large data files audio images wouldnt want fixed amount memory potential structures wait runtime assign certain amount memory holding dataon heap data memory dont want copying data around memory bus every time want run operation say want apply filter image data pointer starts front data assigned image function runs across data changing place didnt know would probably end making duplicates data ran operation least thats way see moment 
p1547
aVthink one reason c pointers difficult conflate several concepts really equivalent yet implemented using pointers people hard time disentangling concepts c pointers used amoung things: define recursive data structures c youd define linked list integers like this: struct node int value struct node next pointer way define recursive data structure c concept really nothing lowlevel detail memory addresses consider following equivalent haskell doesnt require use pointers: data list list int list null pretty straightforward list either empty formed value rest list iterate strings arrays heres might apply function foo every character string c: char c c world c \u005c0 c fooc despite also using pointer iterator example little common previous one creating iterator increment different concept defining recursive data structure neither concept especially tied idea memory address achieve polymorphism actual function signature found glib typedef struct g_list glist void g_list_foreach glist list void funcvoid data void user_data void user_data whoa thats quite mouthful voids declare function iterates list contain kind thing applying function member compare map declared haskell: map::abab thats much straightforward: map function takes function converts b applies list yield list bs like c function g_list_foreach map doesnt need know anything definition types applied sum up: think c pointers would lot less confusing people first learned recursive data structures iterators polymorphism etc separate concepts learned _how pointers used implement ideas c_ rather mashing concepts together single subject pointers 
p1548
aVspeaking c newbie here: pointer system took digest necessarily concept c syntax relative java things found confusing are: 1 variable declaration: a1 vs a1 vs new a1 apparently function declaration variable declaration languages theres basically one way declare variable 2 ampersand used different ways int ampa memory address otoh void fint ampa passedbyreference parameter although may seem trivial confusing new users came java javas language uniform use operators 3 arraypointer relationship one thing thats tad bit frustrating comprehend pointer int pointer int int n array int int new int5 make things messier pointers array interchangeable cases pointers cannot passed array parameters sums basic frustrations cc pointers imo greatly compounded fact cc languagespecific quirks 
p1549
aVmain problem people understand need pointers clear stack heap good start 16bit assembler x86 tiny memory mode helped many people get idea stack heap address byte: modern programmers sometimes cant tell many bytes need address 32 bit space get idea pointers second moment notation: declare pointer get address amp easy understand people last thing saw storage problem: understand heap stack cant get idea static 
p1550
asS'57483'
p1551
(lp1552
Vdifferences pointer variable reference variable c know references syntactic sugar code easier read write differences summary answers links below: 1 pointer reassigned number times reference cannot reseated binding 2 pointers point nowhere null whereas reference always refer object 3 cant take address reference like pointers 4 theres reference arithmetics take address object pointed reference pointer arithmetics obj 5 clarify misconception: _the c standard careful avoid dictating compiler must implement references every c compiler implements references pointers declaration as:_ int ri _if optimized away entirely_ _allocates amount storage pointer places address storage_ _so pointer reference occupy amount memory_ general rule use references function parameters return types define useful selfdocumenting interfaces use pointers implement algorithms data structures interesting read: alltime favorite c faq lite references vs pointers introduction references references const 
p1553
aVapart syntactic sugar reference const pointer pointer const thing const pointer must establish refers declare reference variable cannot change later 
p1554
aV 1 pointer reassigned: int x 5 int y 6 int p p x p y p 10 assertx 5 asserty 10 reference cannot must assigned initialization: int x 5 int y 6 int r x 2 pointer memory address size stack 4 bytes x86 whereas reference shares memory address original variable also takes space stack since reference address original variable safe think reference another name variable note: pointer points stack heap ditto reference claim statement pointer must point stack pointer variable holds memory address variable stack since reference space stack since address variable references stack vs heap int x 0 int r x int p x int p2 r assertp p2 3 pointers pointers pointers offering extra levels indirection whereas references offer one level indirection int x 0 int y 0 int p x int q y int pp p pp qpp q pp 4 asserty 4 assertx 0 4 pointer assigned nullptr directly whereas reference cannot try hard enough know make address reference nullptr likewise try hard enough reference pointer reference contain nullptr int p nullptr int r nullptr compiling error 5 pointers iterate array use go next item pointer pointing 4 go 5th element matter size object pointer points 6 pointer needs dereferenced access memory location points whereas reference used directly pointer classstruct uses access members whereas reference uses 7 pointer variable holds memory address regardless reference implemented reference memory address item references 8 references cannot stuffed array whereas pointers mentioned user @litb 9 const references bound temporaries pointers cannot without indirection: const int x int12 legal c int y int12 illegal dereference temporary makes const safer use argument lists forth 
p1555
aVreference never null 
p1556
aVcontrary popular opinion possible reference null int p null int r p r 1 crash youre lucky granted much harder reference manage youll tear hair trying find edit: clarifications technically invalid reference null reference c doesnt support null references concept might find languages kinds invalid references well actual error dereferencing null pointer prior assignment reference im aware compilers generate errors condition error propagates point along code thats makes problem insidious time dereference null pointer crash right spot doesnt take much debugging figure example short contrived heres realworld example class myclass virtual void dosomethingintintintintint void fooconst myclass bar bardosomethingalonglistofparameters crash occurs obvious myclass getinstance somecondition return null myclass p getinstance foop edit: thoughts want reiterate way get null reference malformed code youre getting undefined behavior never makes sense check null reference example try ifbarnull compiler might optimize statement existence valid reference never null compilers view comparison always false essence undefined behavior proper way stay trouble avoid dereferencing null pointer create reference heres automated way accomplish templatetypename reft p p null throw std::invalid_argumentstd::stringnull reference return p myclass p getinstance foorefp 
p1557
aVwant really pedantic one thing reference cant pointer: extend lifetime temporary object c bind const reference temporary object lifetime object becomes lifetime reference std::string s1 123 std::string s2 456 std::string s3_copy s1 s2 const std::string s3_reference s1 s2 example s3_copy copies temporary object result concatenation whereas s3_reference essence becomes temporary object really reference temporary object lifetime reference try without const fail compile cannot bind nonconst reference temporary object take address matter 
p1558
aVforgot important part: memberaccess pointers uses memberaccess references uses foobar _clearly_ superior foobar way vi emacs 
p1559
aVuse references unless need either these: null pointers used sentinel value often cheap way avoid function overloading use bool arithmetic pointer example p offset 
p1560
aVanother interesting use references supply default argument userdefined type: class udt public: udt : val_d33 udtint val : val_dval virtual udt private: int val_d class udt_derived : public udt public: udt_derived : udt virtual udt_derived class behavior public: behavior const udt udt udt int main behavior b take default udt u88 behavior cu udt_derived ud behavior dud return 1 default flavor uses bind const reference temporary aspect references 
p1561
aVdoesnt matter much space takes since cant actually see side effect without executing code whatever space would take hand one major difference references pointers temporaries assigned const references live const reference goes scope example: class scope_test public: scope_test printfscope_test done\u005cn const scope_test test scope_test printfin scope\u005cn print: scope scope_test done language mechanism allows scopeguard work 
p1562
aVactually reference really like pointer compiler keeps references variables associating name memory address thats job translate variable name memory address compiling create reference tell compiler assign another name pointer variable thats references cannot point null variable cannot pointers variables contain address variable null important thing pointer value reference variable referencing explanation real code: int 0 int b creating another variable points adding another name memory content holding value memory two names b addressed using either name void incrementint n n n 1 int incrementa calling function compiler usually generates memory spaces arguments copied function signature defines spaces created gives name used spaces declaring parameter reference tells compiler use input variable memory space instead allocating new memory space method call may seem strange say function directly manipulating variable declared calling scope remember executing compiled code scope plain flat memory function code could manipulate variables may cases compiler may able know reference compiling like using extern variable reference may may implemented pointer underlying code examples gave likely implemented pointer 
p1563
aV whats c reference _for c programmers_ _reference_ thought _constant pointer_ confused pointer constant value automatic indirection ie compiler apply operator references must initialized nonnull value compilation fail neither possible get address reference address operator return address referenced value instead possible arithmetics references c programmers might dislike c references longer obvious indirection happens argument gets passed value pointer without looking function signatures c programmers might dislike using pointers considered unsafe although references arent really safer constant pointers except trivial cases lack convenience automatic indirection carry different semantic connotation consider following statement _c faq_ even though reference often implemented using address underlying assembly language please _not_ think reference funny looking pointer object reference _is_ object pointer object copy object _is_ object reference _really_ object could dangling references unmanaged languages impossible references safer pointers generally isnt way reliably alias values across scope boundaries consider c references useful coming c background c references may look like somewhat silly concept one still use instead pointers possible: automatic indirection _is_ convenient references become especially useful dealing raii \u005c perceived safety advantage rather make writing idiomatic code less awkward raii one central concepts c interacts nontrivially copying semantics passing objects reference avoids issues copying involved references present language youd use pointers instead cumbersome use thus violating language design principle bestpractice solution easier alternatives 
p1564
aValso reference parameter function inlined may handled differently pointer void incrementint ptrint ptrint void incrementint refint refint void incptrtest int testptr0 incrementtestptr void increftest int testref0 incrementtestref many compilers inlining pointer version one actually force write memory taking address explicitly however leave reference register optimal course functions inlined pointer reference generate code always better pass intrinsics value reference modified returned function 
p1565
aVanother difference pointers void type means pointer anything references void forbidden int void p ok void p forbidden cant say im really happy particular difference would much prefer would allowed meaning reference anything address otherwise behavior references would allow define equivalents c library functions like memcpy using references 
p1566
aVreferences pointers used indirectly access another value two important differences references pointers first reference always refers object: error define reference without initializing behavior assignment second important difference: assigning reference changes object reference bound rebind reference another object initialized reference always refers underlying object consider two program fragments first assign one pointer another: int ival 1024 ival2 2048 int pi ival pi2 ival2 pi pi2 pi points ival2 assignment ival object addressed pi remains unchanged assignment changes value pi making point different object consider similar program assigns two references: int ri ival ri2 ival2 ri ri2 assigns ival2 ival assignment changes ival value referenced ri reference assignment two references still refer original objects value objects well 
p1567
aVone fundamental difference pointers references didnt see anyone mentioned: references enable passbyreference semantics function arguments pointers although visible first not: provide passbyvalue semantics nicely described article regards amprzej 
p1568
aVreference alias another variable whereas pointer holds memory address variable references generally used function parameters passed object copy object void funint int b common usage references int 0 int b b alias common use 
p1569
aVreference another name given memory immutable pointer automatically dereferenced usage basically boils to: int j internally becomes int const j 
p1570
aVprogram might help comprehending answer question simple program reference j pointer ptr pointing variable x includeiostream using namespace std int main int ptr0 x9 pointer variable declaration ptrx pointer variable x int jx reference declaration reference variable x cout x x endl cout x x endl cout j j endl cout j j endl cout ptr ptr endl cout ptr ptr endl cout ptr ptr endl getch run program look output youll understand also spare 10 minutes watch video: 
p1571
aVreferences similar pointers specifically crafted helpful optimizing compilers references designed substantially easier compiler trace reference aliases variables two major features important: reference arithmetic reassigning references allow compiler figure references alias variables compile time references allowed refer variables memory addresses compiler chooses put registers take address local variable hard compiler put register example: void maybemodifyint x may modify x way void hurtthecompilersoptimizershort size int array function designed something particularly troublesome optimizers constantly call maybemodify array0 adding array1 array2arraysize1 theres real reason demonstrate power references int 2 intsize maybemodifyarray0 arrayi array1 optimizing compiler may realize accessing a0 a1 quite bunch would love optimize algorithm to: void hurtthecompilersoptimizershort size int array thing instead accessing array1 time access store result register much faster arithmetic register int a0 a0 register int a1 a1 access a1 int 2 intsize maybemodifya0 give maybemodify reference register arrayi a1 use saved register value a0 a0 store modified a0 back array make optimization needs prove nothing change array1 call rather easy never less 2 arrayi never refer array1 maybemodify given a0 reference aliasing array0 reference arithmetic compiler prove maybemodify never gets address x proven nothing changes array1 also prove ways future call could readwrite a0 temporary register copy a0 often trivial prove many cases obvious reference never stored permanent structure like class instance thing pointers void maybemodifyint x may modify x way void hurtthecompilersoptimizershort size int array operation pointers making optimization trickier int 2 intsize maybemodifyarray0 arrayi array1 behavior much harder prove maybemodify ever modify array1 already gave pointer cat bag much difficult proof: static analysis maybemodify prove never writes ampx 1 also prove never saves pointer refer array0 tricky modern compilers getting better better static analysis always nice help use references course barring clever optimizations compilers indeed turn references pointers needed 
p1572
aVreference points place object _now_ applications use managed memory may saw last example using net clr could create object reference short term heap next look shifted physical memory longterm heap wont see happen done garbage collector separate thread usually take place one application clock cycle next cannot get address guarenteed valid use future time pointed elsewhere may even exist integer pointer held register 
p1573
aVbased written makes clear: address locates variable within memory call reference variable 5th paragraph page 63 variable stores reference another variable call pointer 3rd paragraph page 64 simply remember reference stands memory location pointer reference container maybe use several times better remember reference whats refer almost pointer pointer object supported pointer arithmetic makes pointer similar array look following statement int tom0 int alias_tom tom alias_tom understood alias variable different typedef alias type tom also ok forget terminology statement create reference tom 
p1574
aVrisk adding confusion want throw input im sure mostly depends compiler implements references case gcc idea reference point variable stack actually correct take example: include iostream int mainint argc char argv create string heap std::string str_ptr new std::stringthis string dereference string heap assign reference std::string str_ref str_ptr even compiler warning least gcc lets try print value std::cout str_ref std::endl works lets print compare actual memory addresses std::cout str_ptr : str_ref std::endl exactly remember free memory heap delete str_ptr outputs this: string 0xbb2070 : 0xbb2070 notice even memory addresses exactly meaning reference successfully pointing variable heap really want get freaky also works: int mainint argc char argv actual new declaration let immediately dereference assign reference std::string str_ref new std::stringthis string works least gcc std::cout str_ref prints fine however pointer heap allocation right free space ignorantly created delete str_ref works taking memory address reference storing deleting pointer specify address whereas pointer implicitly sort like calling delete str_ptr also compiles runs fine outputs this: string therefore reference pointer hood storing memory address address pointing irrelevant think would happen called std::cout ltlt str_ref calling delete ampstr_ref well obviously compiles fine causes segmentation fault runtime longer pointing valid variable essentially broken reference still exists falls scope useless words reference nothing pointer pointer mechanics abstracted away making safer easier use accidental pointer math mixing etc assuming dont try nonsense like examples regardless compiler handles references always kind pointer hood reference must refer specific variable specific memory address work expected getting around hence term reference major rule thats important remember references must defined time declaration exception reference header case must defined constructor object contained constructed late define remember examples examples demonstrating reference would never want use reference ways proper usage reference plenty answers already hit nail head 
p1575
aVsemantic difference may appear esoteric familiar studying computer languages abstract even academic fashion highestlevel idea references transparent aliases computer may use address make work youre supposed worry that: youre supposed think another name existing object syntax reflects stricter pointers compiler reliably warn create dangling reference create dangling pointer beyond course practical differences pointers references syntax use obviously different cannot reseat references references nothingness pointers references 
p1576
aVmaybe metaphors help context desktop screenspace reference requires specify actual window pointer requires location piece space screen assure contain zero instances window type 
p1577
aVreference pointer possible c reverse possible means pointer reference isnt possible reference pointer provides cleaner syntax modify pointer look example: includeiostream using namespace std void swapchar str1 char str2 char temp str1 str1 str2 str2 temp int main char str1 hi char str2 swapstr1 str2 coutstr1 str1endl coutstr2 str2endl return 0 consider c version program c use pointer pointer multiple indirection leads confusion program may look complicated includestdioh swaps strings swapping pointers void swap1char str1_ptr char str2_ptr char temp str1_ptr str1_ptr str2_ptr str2_ptr temp int main char str1 hi char str2 swap1str1 str2 printfstr1 str2 str1 str2 return 0 visit following information reference pointer: _c: reference pointer _pointertopointer referencetopointer said pointer reference isnt possible try following program: include iostream using namespace std int main int x 10 int ptr x int ptr1 ptr 
p1578
aVreferences pointers used change local variables one function inside another function also used save copying big objects passed arguments functions returned functions get efficiency gain despite similarities following differences references pointers references less powerful pointers 1 reference created cannot later made reference another object cannot reseated often done pointers 2 references cannot null pointers often made null indicate pointing valid thing 3 reference must initialized declared restriction pointers _due limitations references c cannot used implementing data structures like linked list tree etc java references don\u2019t restrictions used implement data structures references powerful java main reason java doesn\u2019t need pointers_ references safer easier use: 1 safer: since references must initialized wild references like wild pointers unlikely exist still possible references don\u2019t refer valid location 2 easier use: references don\u2019t need dereferencing operator access value used like normal variables \u2018amp\u2019 operator needed time declaration also members object reference accessed dot operator \u2018\u2019 unlike pointers arrow operator needed access members _together reasons places like copy constructor argument pointer cannot used reference must used pass argument copy constructor similarly references must used overloading operators like _ 
p1579
aVdifference nonconstant pointer variablenot confused pointer constant may changed time program execution requires pointer semantics usedamp operators references set upon initialization onlythats set constructor initializer list somehow else use ordinary value accessing semantics basically references introduced allow support operators overloading read old book somebody stated thread pointer set 0 whatever value want 0null nullptr means pointer initialized nothing error dereference null pointer actually pointer may contain value doesnt point correct memory location references turn try allow user initialize reference something cannot referenced due fact always provide rvalue correct type although lot ways make reference variable initialized wrong memory location better dig deep details machine level pointer reference work uniformly via pointers lets say essential references syntactic sugar rvalue references different naturally stackheap objects 
p1580
aV like pointer reference alias object usually implemented hold machine address object impose performance overhead compared pointers differs pointer that: \u2022 access reference exactly syntax name object \u2022 reference always refers object initialized \u2022 \u2018\u2018null reference\u2019\u2019 may assume reference refers object main use references specifying arguments return values functions general overloaded operators particular example: templateclass class vector t\u2217 elem public: operatorint return elemi return reference element const operatorint const return elemi return reference const element void push_backconst pass element added reference void fconst vectordouble v double d1 v1 copy value double referred voperator1 d1 v2 7 place 7 double referred result voperator2 vpush_backd1 give push_back reference d1 wor k 
p1581
aV difference pointer reference pointer initialized 0 reference fact reference must also refer object pointer null pointer: int p 0 can\u2019t int p 0 also int p5 fact properly must declared defined object first make reference object correct implementation previous code be: int x 0 int y 5 int p x int p1 y another important point make declaration pointer without initialization however thing done case reference must make reference always variable object however use pointer risky generally check pointer actually pointing something case reference check necessary know already referencing object declaration mandatory another difference pointer point another object however reference always referencing object let\u2019s take example: int 6 b 5 int rf cout rf endl result get 6 rf referencing value rf b cout endl result 5 value b stored address former value erased another point: template like stl template kind class template always return reference pointer make easy reading assigning new value using operator : std ::vectorintv10 initialize vector 10 elements v5 5 writing value 5 6 element vector returned type operator pointer reference write v55 making reference overwrite element using assignment 
p1582
asS'20752551'
p1583
(lp1584
Vworking union structs c say following types: typedef struct typea int type char12 id typea typedef struct typeb int type int value typeb want use create union types int access type int without needing know whether typea typeb stored union value int lets determine actually stored cant get right syntax though union: typedef union member int type struct typea struct typeb b member union accessed via: typedef struct wrapper union member member struct wrapper next wrapper questions: 1 w pointer allocated wrapper struct accessing using wmemberaid gives request member id something structure union 2 assign pointer already mallocd typeab wmember directly union need malloced specially thanks 
p1585
aV 1 defined member field pointer use wmembertype instead wmembertype 2 malloc union type allocate union youll get structure sizeof equal largest element union try copy structures union pointers youll mess alignment 
p1586
aV 1 use wmembertype 2 need allocate union specifically one note may point misunderstanding union holds either int typea typeb particular cannot rely int type union tell struct union holds edit respond question comments: probably want something like this: struct typea char data30 whatever struct typeb double x y whatever struct some_info int type set accordingly union struct typea struct typeb b data access some_info_objectdataa some_info_objectdatab 
p1587
aVwmembertype wmembertype wmember pointer dont know top head whether c let assign typea typeb member \u005c somehow doubt always member would consider recomposing structs remove int tag instead declare one struct includes tag union typea typeb structs ideally shouldnt need concerned fact theyre union 
p1588
aVmight want check code question: union structs common first member commonfirstmember essentially want im using inner struct contained example thats common two types struct cast gain access common elements types 
p1589
asS'1990932'
p1590
(lp1591
Vtwo main functions cc write program c c two main functions 
p1592
aVprogram 1 entry pointwhich main fact generally one function given name c 
p1593
aVmain defines entry point program must one main functionentry point program frankly speaking question doesnt make much sense 
p1594
aVprograms single main thats compiler linker generate executable start somewhere sensible basically two options: 1 main interpret command line arguments decide actual main call drawback going executable programs 2 create library shared code compile main file library youll end two executables 
p1595
aVmean main function mean first function execute program starts one one first want application different things start write main function reads command line example decides function call 
p1596
aVyes however platform specific 
p1597
aVcannot one main function c language standard c language main function special function defined entry point program cannot one copy function create c language language matter unless specify different signatures case main think got choice 
p1598
aVspecial architecture case cell processor main program main processor 64bit powerpc processors element called ppe one many main program 8 different coprocessor 32bit synergistic processing element called spe 
p1599
aVtwo functions called main _name_ special way reserved whats special _function_ happens name function global write main function namespace second main function namespace kuppusamy int main return 0 int main kuppusamy::main first main function special notice return explicitly 
p1600
aVnothe main entry point programsince u cant two entry points cant two main 
p1601
aVwrite itll compile wont link unless linker noncomformant 
p1602
aVidiom dispatch value argv0 hardlinks posix dont even lose diskspace 
p1603
aVone static resides different source file dont see problem 
p1604
aVmight answer query void main func1 define main func1 void main printfinside 2nd main 
p1605
aVc c cnet introduce trick use 2 mains one application implemented application scenario requirement implemented successfully reference proof 
p1606
asS'1666353'
p1607
(lp1608
Vtypedef define c wonder typedef define cquestionstaggedc show questions tagged c 
p1609
aVdefine preprocessor token: compiler never see typedef compiler token: preprocessor care use one achieve effect better use proper one needs define my_type int typedef int my_type things get hairy using proper tool makes right define fx_type void int typedef void stdfxint void fx_typstdfx fx ok void fx_deffx_type fx error 
p1610
aVafaik typedef helps setup alias existing data type eg typedef char chr define preprocessor directive used define macros general pattern subsitutions eg define max 100 substitutes occurences max 100 
p1611
aVtypedef keyword creates alias type define preprocessor instruction creates text replacement event prior compilation compiler gets code original defined word longer define mostly used macros global constants 
p1612
aVtypedef obeys scoping rules like variables whereas define stays valid end file matching undef also things done typedef cannot done define examples: typedef int int_p1 int_p1 b c b c int pointers define int_p2 int int_p2 b c first pointer typedef int a1010 a10 b c create three 10int arrays typedef int func_p int func_p fp func_p pointer function takes int returns int 
p1613
aVexample: define intptr int intptr b preprocessing line expands int b hopefully see problem type int b declared plain int associated declarator type specifier contrast typedef int intptr intptr b case b type int whole classes typedefs cannot emulated preprocessor macro pointers functions arrays: typedef int callbackvoid typedef int obnoxiousfuncvoid20 callback acallbackfunc acallbackfunc pointer function returning int obnoxiousfunc anobnoxiousfunc anobnoxiousfunc pointer function returning pointer 20element array pointers int try preprocessor macro 
p1614
aVdifferent although often used implement custom data types assuming question pmg mentioned define handled preprocessor like cutand paste operation compiler sees code typedef interpreted compiler one main differences least comes defining data types typedef allows specific type checking example define deftype int typedef int tdtype deftype x tdtype y compiler sees variable x int variable y data type called tdtype happens size int wrote function took parameter type deftype caller could pass normal int compiler wouldnt know difference function instead took parameter type tdtype compiler would ensure variable proper type used function calls also debuggers ability handle typedefs much useful custom types listed underlying primitive types would define used instead 
p1615
aVpreprocessor macros defines lexical replacement tool la search replace entirely agnostic programming language understanding youre trying think glorified copypaste mechanic occasionally thats useful use care typedefs c language feature lets create aliases types extremely useful make complicated compound types like structs function pointers readable handlable c even situations _must_ typedef type 3: always prefer language features preprocessor macros thats possible always use typedefs types constant values constants way compiler actually interact meaningfully remember compiler friend tell much possible preprocessor macros exact opposite _hiding_ semantics compiler 
p1616
aVdefine uslibraryteas059328vvs8029aspx defines macros typedef saying differences: define define constants used compile time constants used ifdef check code compiled specialize certain code according compile parameters also use define declare miniature findandreplace macro functions typedef used give aliases types could probably define well safer findandreplace nature define constants besides use forward declaration typedef allows declare type used isnt yet linked file youre writing 
p1617
aVeveryone said arent answers indicate typedef advantageous define let put plus point define : code extremely big scattered across many files better use define helps readability simply preprocess code see actual type definition variable place declaration 
p1618
asS'14086830'
p1619
(lp1620
Vpython calling method class im punching way weight please bare python amateurim php developer trade ive hardly touched language im trying call method classsounds simple enough im utterly baffled self refers correct procedure call method inside class outside class could someone _explain_ call move method variable right ive tried researching several learn python sites searches stackoverflow avail help appreciated following class works scotts python script accessed terminal gui urwid function im working scott westons missile launcher python script im trying hook php webserver class missiledevice: inita 85 83 66 67 0 0 4 0 initb 85 83 66 67 0 64 2 0 cmdfill 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 stop 0 0 0 0 0 0 left 0 1 0 0 0 0 right 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 leftup 0 1 0 1 0 0 rightup 0 0 1 1 0 0 leftdown 0 1 0 0 1 0 rightdown 0 0 1 0 1 0 fire 0 0 0 0 0 1 def __init__self battery: try: selfdevusbdevice0x1130 0x0202 battery selfdevopen selfdevhandlereset except nomissileserror e: raise nomissileserror def moveself direction: selfdevhandlecontrolmsg0x21 0x09 selfinita 0x02 0x01 selfdevhandlecontrolmsg0x21 0x09 selfinitb 0x02 0x01 selfdevhandlecontrolmsg0x21 0x09 directionselfcmdfill 0x02 0x01 
p1621
aVfirst argument methods usually called self refers instance method called lets say have: class aobject: def fooself: print foo def barself an_argument: print bar an_argument doing: afoo prints foo abararg prints bar arg theres nothing special called self could following: class bobject: def fooself: print foo def barthis_object: this_objectfoo doing: b b bbar prints foo specific case: dangerous_device missiledevicesome_battery dangerous_devicemovedangerous_deviceright suggested comments missiledeviceright could appropriate could declare constants module level though could do: dangerous_devicemoveright however going depend want code organized 
p1622
aV could someone explain call move method variable right mymissile missiledevicemybattery looks like need battery dont know figure mymissilemovemissiledeviceright programmed language classes besides python sort thing class foo: bar baz probably unfamiliar python class factory objects object variables defined scope attached _class_ instances returned class refer bar call foobar also access class attributes instances class like foobar im utterly baffled self refers class foo: def quuxself: print self print selfbar bar baz fooquux unbound method fooquux foobar baz f foo fbar baz f __main__foo instance 0x0286a058 fquux bound method fooquux __main__foo instance 0x0286a058 fquux __main__foo instance 0x0286a058 baz acecss attribute python object interpreter notice looked attribute class function return bound method instead function arrange instance passed first argument 
p1623
aVlets say shiny foo class well 3 options: 1 want use method attribute class inside definition class: class fooobject: attribute1 1 class attribute dont use self declaration def __init__self: selfattribute2 2 instance attribute accessible via first parameter method usually called self contain nothing instance def set_attribute3self value: selfattribute3 value def sum_1and2self: return selfattribute1 selfattribute2 2 want use method attribute class outside definition class def get_legendary_attribute1: return fooattribute1 def get_legendary_attribute2: return fooattribute2 def get_legendary_attribute1_fromcls: return clsattribute1 get_legendary_attribute1 1 get_legendary_attribute2 attributeerror: type object foo attribute attribute2 get_legendary_attribute1_fromfoo 1 3 want use method attribute instantiated class: f foo fattribute1 1 fattribute2 2 fattribute3 attributeerror: foo object attribute attribute3 fset_attribute33 fattribute3 3 
p1624
asS'19088284'
p1625
(lp1626
Vinclude stdioh really c program new student c programming coding simple programs world style programs put includestdioh top sure means exactly googled found stdioh file commands preprocessor preprocessor thought write code compile code transforms form computer read run somebody explain usage command 
p1627
aVsimplest explanation perhaps program calls uses many functions whose code part program eg write printf code print something compiler know call stdioh place information printf resides update: rather prototype printf function name return type parameters reside stdioh required compilation phase actual code printf included linking phase comes compilation include statement basically inserts function prototypes actual compilation hence name preprocessor update 2: since question focused include statement op also asked writing definition functions another important aspect written like note angular brackets include stdioh preprocessor assumes standard library header looks system folders first compiler installed instead programmer defines function place h file current working directory would use note quotes include stdioh following behavior portable across platforms 
p1628
aVlooks stdioh file effectively copypastes place include statements file contains socalled function prototypes functions printf scanf compiler knows parameters return values 
p1629
aVtells compiler use functions structures macros etc file sdtioh represents part glibcor whatever standart c library got compiler also adds record output executable tolink list linked standart c library 
p1630
asS'252780'
p1631
(lp1632
Vtypedef struct often c seen many programs consisting structures like one typedef struct int char k elem elem user needed often specific reason applicable area 
p1633
aVusing typedef avoids write struct every time declare variable type: struct elem int char k elem user compile error struct elem user correct 
p1634
aVgreg hewgill said typedef means longer write struct place saves keystrokes also make code cleaner since provides smidgen abstraction stuff like typedef struct int x y point point point_newint x int y point ax x ay y return becomes cleaner dont need see struct keyword place looks really type called point language typedef case guess also note example mine omitted naming struct actually naming also useful want provide opaque type youd code like header instance: typedef struct point point point point_newint x int y provide struct declaration implementation file: struct point int x y point point_newint x int y point p ifp mallocsizeof p null px x py y return p latter case cannot return point value since declaration hidden users header file technique used widely gtk update note also highlyregarded c projects use typedef hide struct considered bad idea linux kernel probably wellknown project see chapter 5 linux kernel codingstyle document 
p1635
aVname optionally give struct called _tag name_ noted type get type requires struct prefix gtk aside im sure tagname used anything like commonly typedef struct type c recognised omit struct keyword use tagname type name too: struct mystruct int following legal c: mystruct obj obji 7 
p1636
aVold article dan saks c language rules naming structs little eccentric theyre pretty harmless however extended classes c rules open little cracks bugs crawl c name appearing struct tag tag name type name given definition declarations x error c p error c errors c must write struct x ok struct p ok names unions enumerations also tags rather types c tags distinct names functions types variables enumeration constants c compilers maintain tags symbol table thats conceptually physically separate table holds names thus possible c program tag another name spelling scope example struct valid declaration declares variable type struct may good practice c compilers must accept never seen rationale c designed way always thought mistake many programmers including truly prefer think struct names type names define alias tag using typedef example defining struct typedef struct lets use place struct x p program cannot use name type variable function enumeration constant: error good tag name struct union enum definition optional many programmers fold struct definition typedef dispense tag altogether in: typedef struct linked article also discussion c behavior requireing typedef cause subtle name hiding problems prevent problems good idea typedef classes structs c even though first glance appears unnecessary c typedef name hiding become error compiler tells rather hidden source potential problems 
p1637
aVone good reason always typedef enums structs results problem: enum enumdef first_item second_item struct structdef enum enuumdef myenum unsigned int myvar mystruct notice typo enumdef struct enuumdef compiles without error warning depending literal interpretation c standard correct problem created new empty enumeration definition within struct intended using previous definition enumdef typdef similar kind typos would resulted compiler errors using unknown type: typedef first_item second_item enumdef typedef struct enuumdef myenum compiler error unknown type unsigned int myvar structdef strructdef mystruct compiler error unknown type would advocate always typedefing structs enumerations save typing pun intended safer 
p1638
aVc language structunionenum macro instruction processed c language preprocessor mistake preprocessor treat include : struct int struct b struct int int j struct b expended something like : struct b struct int int int j compile time evolve stack something like: b: int ai int int j also dificult selfreferent structs c preprocessor round déclaration loop cant terminate typedef type specifier means c compiler process like want optimise assembler code implementation also dont expend member type par stupidly like préprocessor structs use complex reference construction algorithm construction like : typedef struct anticipated declaration member declaration typedef struct implemented declaration b member declaration permited fully functional implementation give also access compilator type conversion remove bugging effects execution thread leave application field initialisation functions mean c typedefs near c class lonely structs 
p1639
aVdont think forward declarations even possible typedef use struct enum union allows forward declarations dependencies knows bidirectional style: use typedef c makes quite bit sense almost necessary dealing templates require multiple andor variable parameters typedef helps keep naming straight c programming language use typedef often serves purpose obfuscate data structure usage since struct 6 enum 4 union 5 number keystrokes used declare data type almost use aliasing struct data type union struct using straight forward nontypdefed declaration lets know right away type notice linux written strict avoidance aliasing nonsense typedef brings result minimalist clean style 
p1640
aVamazing many people get wrong please dont typedef structs c needlessly pollutes global namespace typically polluted already large c programs also typedefd structs without tag name major cause needless imposition ordering relationships among header files consider: ifndef foo_h define foo_h 1 define foo_def 0xdeadbabe struct bar forward declaration defined barh struct foo struct bar bar endif definition using typedefs possible compiland unit include fooh get foo_def definition doesnt attempt dereference bar member foo struct need include barh file also since namespaces different tag names member names possible write readable code as: struct foo foo printffoobar p foobar since namespaces separate conflict naming variables coincident struct tag name maintain code remove typedefd structs 
p1641
aVlinux kernel coding style great pros cons mostly cons using typedef please dont use things like vps_t _mistake_ use typedef structures pointers see vps_t source mean contrast says struct virtual_container actually tell lots people think typedefs help readability useful for: totally opaque objects typedef actively used _hide_ object example: pte_t etc opaque objects access using proper accessor functions note opaqueness accessor functions good reason things like pte_t etc really absolutely _zero_ portably accessible information b clear integer types abstraction _helps_ avoid confusion whether int long u8u16u32 perfectly fine typedefs although fit category d better note needs _reason_ something unsigned long theres reason typedef unsigned long myflags_t clear reason certain circumstances might unsigned int configurations might unsigned long means go ahead use typedef c use sparse literally create _new_ type typechecking d new types identical standard c99 types certain exceptional circumstances although would take short amount time eyes brain become accustomed standard types like uint32_t people object use anyway therefore linuxspecific u8u16u32u64 types signed equivalents identical standard types permitted although mandatory new code editing existing code already uses one set types conform existing choices code e types safe use userspace certain structures visible userspace cannot require c99 types cannot use u32 form thus use __u32 similar types structures shared userspace maybe cases rule basically never ever use typedef unless clearly match one rules general pointer struct elements reasonably directly accessed _never_ typedef 
p1642
aVturns prons cons useful source information seminal book expert c programming chapter 3 libcombookreaderphp138815expert_c_programming:_deep_c_secretspdf briefly c multiple namespaces: tags types member names identifiers typedef introduces alias type locates tag namespace namely typedef struct tag members type defines two things one tag tag namespace one type type namespace type mytype struct tag mytagtype declarations like struct type mytype tag mytagtype illegal addition declaration like this: typedef type type_ptr define pointer type declare: type_ptr var1 var2 struct tag mytagtype1 mytagtype2 var1var2 mytagtype1 pointers type mytagtype2 mentioned book mentions typedefing structs useful saves programmer writing word struct however objection like many c programmers although sometimes turns obfuscate names thats advisable large code bases like kernel want implement polymorphism c helps lot look details implementingpolymorphisminchtml example: typedef struct mywriter_t mypipe super myqueue relative uint32_t flags mywriter do: void my_writer_funcmypipe mywriter self mywriter uint32_t myflags selfflags access outer member flags inner struct mypipe casting less confusing cast whole type struct mywriter_ every time want perform functionality cases brief referencing big deal especially heavily employ technique code finally last aspect typedefed types inability extend contrast macros example have: define x char10 typedef char y10 declare unsigned x x unsigned y y really care structs apply storage specifiers volatile const 
p1643
aVtypedef provide codependent set data structures cannot typdef: struct bar struct foo struct foo struct bar b struct bar struct foo f course always add: typedef struct foo foo_t typedef struct bar bar_t exactly point 
p1644
aVc programming language keyword typedef used declare new name objectstructarrayfunctionenum typefor example use structs c often declare struct outside main functionfor example: struct complex int real_part img_part complex main struct kompleks number number type struct type numberreal_part 3 numberimg_part 1 printfnumber: dd \u005cnnumberreal_part numberimg_part time decide use struct type need keyword struct something nametypedef simply rename type use new name program every time wantso code be: typedef struct complexint real_part img_part complex complex new name structure want use without keyword like first example struct complex number main complex number number type first example numberreal_part 1 numberimgpart 5 printfd d \u005cn numberreal_part numberimg_part local objectstructarrayvaluable used entire program simply give name using typedef 
p1645
aVturns c99 typedef required outdated lot tools ala hackrank use c99 pure c implementation typedef required im saying change maybe two c options requirement changed us studing interviews site would sol 
p1646
asS'2452365'
p1647
(lp1648
Vprogramming language need keywords example c: int break 1 int 2 compiler problems deducing break variables need keywords want programs readable want overcomplicate job already complex compilers today importantly language lot powerful keywords reserved special actions language think useful higher level rather dying trying implement loop unambiguous way 
p1649
aVseveral reasons: keywords may seem unambiguous samples place would use variable break variable writing parser would much harder error prone little gain using keyword function procedure name library may undesired possibly security relevant side effects 
p1650
aVcomputer comes across statement like: while1 condition break actually break treat 1 language would become ambiguous certain cases youd create smart parser infer subtle syntax thats unnecessary extra work 
p1651
aVcompiler would problems write something like this: whiles return5 loop call function named want return value 5 current function want call function named return often simplifies things constructs special meaning simply special names used unambiguously refer 
p1652
aVspeaking c already complicated grammar allowing use keywords variable names example make even complicated 
p1653
aVnecessary fortran didnt reserve words things like: eq else else endif complete legal makes language hard _compiler_ parse often almost impossible person read spot errors example consider classic fortran say fortran 77 havent used recently least hope theyve fixed things like recent standards fortran loop looks like this: 10 110 without sidebyside probably see youd miss different: 10 110 unfortunately latter isnt loop simple assignment value 110 variable named 10 yes also allows spaces name since fortran also supports implicit undeclared variables perfectly legal compilers would even accept without warning 
p1654
aVdont pl1 famously keywords every keyword begin also used variable name allowing means write really obscure code: dobegin print:callgoto reserving statement keywords language isnt usually loss set names modest every langauge ive ever seen except pl1 : apl also famously keywords set 200 amazing iconic symbols write complicated operators domino operator dont ask square box calculator divide sign middle case langauge designers simply used icons instead keywords consequence apl reputation write language bottom line: requirement tends make programs lot readable keywords reserved identifiers small set known programmers langauges insisted keywords start special punctuation character like allow possible identifiers used isnt worth extra trouble type clutter page pretty easy stay away identifiers match keywords keyword set small 
p1655
aVothers said makes compiler parsing source code easier would like say bit more: also make source code readable consider example: 0 10 end second second variables others think kind code readable : 
p1656
aVguess look weird impossible write parser eg int break 1 true code change break break break readable code 
p1657
aVsince tagged c original c language default variable defined type int means foo would declare variable type int lets say break compiler know whether want declare variable named break use keyword break 
p1658
aVwant keep little sanity points weve got: void myfunctionbool funcp myfunction whiletrue 
p1659
aVdepending language definition compiler may may need keywords know try apply precedence rules fail example: void returnint iprintfdi public int fooint ifa 2return a12 return 3 happens greater 2 language specification may require compiler fail language specification may require compiler use return function language specification may require compiler return define language dosnt use keywords even define language alowes replace symbols since short keywords themselfes problem compiler specification complete error free work problem pebcad programs using feature language hard read keep track symbol definitions 
p1660
aVfwiw tcl doesnt reserved words variables functions named break etc interpretation token totally dependent context token represent command one context variable another literal string another 
p1661
aVmany cases would possible compiler interprete keywords normal identifiers like example: int break 1 int 2 matter fact wrote compiler simple assemblylike toy language warns user cases sometimes syntax defined way keywords identifiers ambiguous: int break break treat expression statement obvious reason editors emphasize keywords code readable humans allowing keywords treated identifiers would make code highlighting harder would also lead bad readability code 
p1662
asS'9135587'
p1663
(lp1664
Vpure variables surprised find code compiles: pure string foo somepurefunction123 pure mentioned context functions online documentation pure variables different immutable const ones 
p1665
aVattribute effect case known issue dmd quite number similar cases attributes rejected dont effect well 
p1666
asS'37136552'
p1667
(lp1668
Vmeaning pass reference c c confused meaning pass reference c c c references guess pass reference means passing pointer call pass pointer c pointers references stuff like iterators lies close pass reference mean 
p1669
aVpass reference call reference term type parameter passing calling function idea older c necessarily done using c references doesnt builtin mechanism use pointers 
p1670
aVreference general instance referencing something else thus wider sense also pointer considered one possible implementation reference references c called references apart referencing something offer features passbyreference used general distinguish passbyvalue whether via pointer via reference often minor detail however c references imho clear purpose function parameter eg: int fooint passbyreference int fooconst int pratically passbyvalue avoiding copy parameter hand references compared pointers obvious call site passbyvalue passbyreference eg int x int y foox could passbyvalue passbyreference int z foox obviously passbyreference pointer 
p1671
aV c references reference _variables_ refer objects using pointers therefore pointers references abstract point view call pass pointer _can_ call _pass pointer_ reference general term pointer often preferable use general term want discuss abstractions want ignore implementation details would call pass reference reason call variable integer rather int32_t c pointers references stuff like iterators lies close pass reference mean depends context often means function argument reference variable may also refer pointer iterator reference wrapper anything referes object reference abstract concept exists beyond c c beyond programming term ambiguous reference variables context convention isnt universal determines meaning 
p1672
aVcolloquial usage pass reference means callee modifies arguments affects caller argument seen callee _refers_ value seen caller phrase used independent actual programming language calls things pointers references whatever c _callbyreference_ done references _or_ pointers c _callbyreference_ achieved passing pointer call value: void foo int x x copy whatever argument foo called x 42 int main int 0 foo point 0 call reference c style: void foo int x x still copy foos argument copy refers value seen caller x 42 int main int 0 foo point 42 strictly speaking passbyreference c either pass variable byvalue pass pointer variable _byvalue_ 
p1673
aVpass something reference youre working address value variable directly use reference parameter youre getting address variable pass manipulate ever want variable passed change change reference function easier way work large amounts data really saves memory etc 
p1674
aVimagine paint house value: bring copy house painter much effort maybe rails reference: give house address painter come paint 
p1675
aVc two concepts 1\u005c call value copy values passed actual values change outside function 2\u005c call reference actual values address actual operands passed change values globally c two concepts 1\u005c pass value c actual values change scope values function 2\u005c pass reference actual values address actual operands passed change values globally means values gets changed affect whole program pass reference address operands passed thats called pass reference pointer 
p1676
aVc reference variables pass reference using pointers wikipedia definition callbyreference evaluation also referred passbyreference function receives implicit reference variable used argument rather copy value term type parameter passing mentioned thomas yes since c older c also idea older c however c pointers references used passing functioncall address call reference actually working way differences reference created cannot later made reference another object cannot reseated often done pointers references cannot null pointers often made null indicate pointing valid thing reference must initialized declared restriction pointers differences use call reference instead call pointer reduce possibility null pointer error kind problems 
p1677
aVlets clear confusion c references guess pass reference means passing pointer call pass pointer _every argument passing c passbyvalue_ even pointer argument copy contains points prefer _the value_ \u005c memory address change variable points pointer since copy whatever affect pointer caller level c pointers references stuff like iterators lies close pass reference mean means argument alias variable caller level copy allows us change hope helped 
p1678
aVadd answers referencing mean reference address compiler may use method reference variable 
p1679
asS'1464253'
p1680
(lp1681
Vglobal environment variables shell script set global environment variable bash script stuff like binbash foobar binbash export foobar vars seem stay local context whereas id like keep using script finished executing 
p1682
aV foobar export foo 
p1683
aVrun script myscriptsh run script current shell environment export governs variables available new processes say foo1 export bar2 runscriptsh bar available environment runscriptsh foo 
p1684
aV_run_ shell script done subshell cannot affect parent shells environment want source script doing: setfoosh executes context _current_ shell _sub_ shell bash man page: filename arguments source filename arguments read execute commands filename current shell environment return exit status last command executed filename filename contain slash file names path used find directory containing filename file searched path need executable bash posix mode current directory searched file found path sourcepath option shopt builtin command turned path searched arguments supplied become positional parameters filename executed otherwise positional parameters unchanged return status status last command exited within script 0 commands executed false filename found cannot read 
p1685
aV binbash export foobar binbash foobar export foo _man export:_ shell shall give export attribute variables corresponding specified names shall cause environment subsequently executed commands name variable followed word value variable shall set word 
p1686
aVsource myscriptsh also feasible description linux command source: source unix command evaluates file following command list commands executed current context 
p1687
asS'1439907'
p1688
(lp1689
Vdifferences else else trying discern difference else else use homework assignment ton instances running code error due knowing differences someone please define use 
p1690
aVstatement follows sort structure: condition executed condition true else condition executed condition false condition true else executed condition condition false portion block absolutely mandatory else allows say ok previous condition true condition true else says none conditions true multiple else blocks one block one zero else blocks 
p1691
aVelse else constructs help branch code basically employ whenever want make decision example would sunny ill go outside otherwise ill stay inside code ignoring extra stuff sunny gooutside else stayinside use else statements want add additional conditions extending previous example sunny ill go outside stormy ill go basement otherwise ill stay inside code sunny gooutside else stormy godownstairs else stayinside edit section: write multiple ifs conditions following example written least two ways: sunny warm go outside sunny cold nothing sunny warm gooutside else cold donothing sunny warm gooutside else sunny cold donothing 
p1692
aVelse used conjunction else break logic less zero myint 0 something else myint 0 myint 10 else 0 10 something else else others something 
p1693
aVsyntax statement ifcondition something executed condition true else otherthing otherwise part executed basically else part construct _something_ _otherthing_ often compound statements enclosed else part fact optional else combination two ifs _otherthing_ ifcondition1 something else ifcondition2 otherthing else totallydifferenthing 
p1694
aVifelseifelse written nested ifelse logically speaking equivalent: doa else b dob else c doc else dox as: doa else b dob else c doc else dox result ultimately _one_ doa dob doc dox evaluated 
p1695
aVtheres else following: condition statement block or: condition statement block else statement block first case statement block executed condition true different 0 second case condition true first statement block executed otherwise second statement block executed write else thats else statement second statement statement might problems try this: condition condition statement block else statement block problem want else refer first actually referring second one fix doing: condition condition statement block else statement block 
p1696
aVbasic decision orders programming language helps decide flow actions program gonna telling compiler question question condition parenthesis condition thingstodo else part addition structure tell compiler condition false condition thingstodo else thingstodoinothercase combine form else first condition false want another question decide condition thingstodo else condition2 thingstodointhesecondcase else thingstodoinothercase 
p1697
aV numoptions 1 return else numoptions 2 return else else return else 
p1698
aVstatement uses results logical expression decide one two code blocks executed code logical expression code block 1 else code block 2 logical expression true statements code block 1 executed false statements code block 2 case multiple similar tests done instance testing number less zero equal zero zero second test placed first statement else code block logical expression 1 code block 1 else logical expression 2 code block 2 else code block 3 case code block 1 executed logical expression 1 true code block 2 logical expression 1 false logical expression 2 true code block 3 logical expressions false obviously repeated another statement first statement code block 3 else statement simply reformatted version code logical expression 1 code block 1 else logical expression 2 code block 2 else code block 3 
p1699
aVmean exactly mean english condition true something else otherwise another condition true something else else fails note _else if_ construct specifically _if_ _else_ syntax allows place else together convention nest deeper example: x else y else syntactically identical to: x else y else syntax cases is: statmentstatmentblock else statmentstatmentblock _if_ statment syntax alone supports use _else if_ 
p1700
aVdead simple pseudocode explanation: example ifcondition_is_true do_this now_do_this_regardless_of_whether_condition_was_true_or_false ifelse example ifcondition_is_true do_this else do_this_if_condition_was_false now_do_this_regardless_of_whether_condition_was_true_or_false ifelseifelse example ifcondition_is_true do_this else ifdifferent_condition_is_true do_this_only_if_first_condition_was_false_and_different_condition_was_true else do_this_only_if_neither_condition_was_true now_do_this_regardless_of_whether_condition_was_true_or_false 
p1701
aVthink helps think else word otherwise would read like this: something true stuff otherwise thing true stuff otherwise stuff : 
p1702
aV confused read c spec else kind confused read books else everything ok : 
p1703
aV condition thingstodo else condition2 thingstodointhesecondcase else thingstodoinothercase 
p1704
aVelse used test conditions take case else case compiler check cases wether true false one block execute else part executed case else compiler stop flow program got false value read whole programso better performance use else importance according situation take example foor ordering menu use else suit well user check one also give error use stringbuilder resultnew stringbuilder resultappendselected items: ifpizzaischecked resultappend\u005cnpizza 100rs totalamount100 ifcoffeischecked resultappend\u005cncoffe 50rs totalamount50 ifburgerischecked resultappend\u005cnburger 120rs totalamount120 resultappend\u005cntotal: totalamountrs displaying message toast toastmaketextgetapplicationcontext resulttostring toastlength_longshow else case time 12 greeting good morning else time 22 greeting good day else greeting good evening satisfy one condition case multiple conditions satisfied 
p1705
aVthink else pair satisfies two actions one given condition ex: rains take umbrella else go without umbrella two actions go umbrella go without umbrella two actions bound one condition ie raining consider scenario multiple conditions actions bound together ex: hungry broke enjoy meal kfc else hungry broke try compromise else hungry want hangout cafe try startbucks else anything dont ask hunger food got bigger things worry else statement string together actions falls else conditions 
p1706
asS'18446686'
p1707
(lp1708
Vmain function c ive learning c programming selftaught fashion weeks questions concerning main function 1 functions must declared function prototype later defintion dont declare main function prototype first 2 use int main instead void main 3 return 0 exactly main function would happen wrote program ending main function return 1 example 
p1709
aV1 false create defintion function 2 know main function correctly terminate 3the except shell writed 1 instead 0 
p1710
aV 1 need either definition prototype order properly call function main must never called function _must not_ declared 2 c standard says operating systems pass return value calling program usually shell compilers accept void main nonstandard extension usually means always return zero os 3 convention nonzero return value signals error occurred shell scripts programs use find program terminated successfully 
p1711
aV 1 functions must declared function prototype later definition dont declare main function prototype first true simple example: void foo definition int main foo return 0 one function called definition isnt seen yet declaration required never happen main since starup program 2 use int main instead void main standard says precise true hosted environment usually case c99 51221 _program startup_ function called program startup named main implementation declares prototype function shall defined return type int parameters: int mainvoid two parameters referred argc argv though names may used local function declared: int mainint argc char argv equivalent implementationdefined manner 3 return 0 exactly main function would happen wrote program ending main function return 1 example return value indicates result program usually 0 indicates success values indicates different kinds failure 
p1712
aV1 necessarily definition also serves declaration secondly valid signatures main anyway normally wont call main within code unless youre writing entry ioccc 2 short answer: language definition says longer answer: program indicates success failure host environment individual implementation free support additional signatures main must document additional signatures compiler documentation list void main legal signature shouldnt use 3 convention least nix systems c first used status 0 indicates success nonzero status indicates something success exactly value corresponds status implementation 
p1713
aVfunctions need necessarily declared first prototype declaration needed need use function defined main type int _by definition_ meaning value returned main conventional convention generally accepted 0 considered success 0 kind failure 
p1714
aV1the main function implicitly called c library recognizing inbuilt keyword main dont need declare prototype main function 2this sure think depends type editor used turbo c void main accepted whereas devcpp main return value 3return 0 simply exits program exit status 0 words return value determines exit status main thread 
p1715
aVfree chose return type main write code calls main code calling main already existed even thought learning c written folks providing _c runtime startup code_ usually linked automatically executable without knowing code often resides file called crt0o created crt0c even assembler crt0s expects use return value indicating success 0 failure nonzero plus possibly information like whether code terminated due signal one bits unix history wont repeat : 
p1716
aVsimply put essence questions traditions conformance toolchains operating systems etc know way procedure called main must called first user code spaceprogram specifically: 1 conformance said need declare toolchains operating systems know already main also conformance functions like exit 2 main time returns operating system result back usually non zero means error u using scripts programs calling program eg main function check successful 3 return something else zero means error actually interpret value want said os result additional info: main actually first function written called start program actually operating systems tool chains facilitate calls main setup environment initialization whatever know directly writing code deal think embedded systems usually low level functions called setup cpu main clock interrupts stack etc tool chains like iar actually enable execute code main called hope helped : 
p1717
asS'204476'
p1718
(lp1719
Vmain return c c correct efficient way define main function c c \u2014 int main void main \u2014 int main return 1 return 0 _there numerous duplicates question including:_ valid signatures cs main function return type main function difference void main int main mains signature c proper declaration main styles main functions c return type main method c int main vs void main c related: c \u2014 int mainint argc char argv c \u2014 int mainint argc char argv char envp third argument main portable must int main function return value compilers type main function c c left user define int main compile legal definitions main c14 
p1720
aVreturn value main indicate program exited normal exit generally represented 0 return value main abnormal termination usually signalled nonzero return standard nonzero codes interpreted also noted others void main explicitly prohibited c standard shouldnt used valid c main signatures are: int main int mainint argc char argv equivalent int mainint argc char argv also worth noting c int main left without return value point defaults returning 0 also true c99 program whether return 0 omitted open debate range valid c program main signatures much greater also efficiency issue main function entered left marking program start termination according c standard c case different reentering main allowed probably avoided 
p1721
aVreturn 0 success nonzero error standard used unix dos scripting find happened program 
p1722
aVbasically depends execution environment os c implies run unix like os expects program return small 1 byte cant remember integer indicate success failure probably use int mainint argc char argv 
p1723
aVstandard says main return int void supposed work take look question doesintmaincompile 
p1724
aVbelieve main return either exit_success exit_failure defined stdlibh 
p1725
aVimpression standard specifies main doesnt need return value successful return os based zero one could either success failure another therefore absence return cue compiler insert successful return however usually return 0 
p1726
aVkeep mind thateven though youre returning int oses windows truncate returned value single byte 0255 
p1727
aVaccepted answer appears targetted c thought id add answer pertains c differs ways isoiec 9899:1989 c90: main declared either: int mainvoid int mainint argc char argv equivalent example int mainint argc char argv equivalent second one int return type omitted default implementation permits main declared ways makes program implementation defined longer strictly conforming standard defines 3 values returning strictly conforming rely implementation defined behaviour: 0 exit_success successful termination exit_failure unsuccessful termination values nonstandard implementation defined main must explicit return statement end avoid undefined behaviour finally nothing wrong standards point view calling main program isoiec 9899:1999 c99: c99 everything except: int return type may omitted may omit return statement main main finished implicit return 0 
p1728
aVreally issues related efficiency returning integer process probably avoid call process many times return value becomes issue call process many times find way put logic directly inside caller dll file without allocate specific process call multiple process allocations bring relevant efficiency problem case detail want know returning 0 less efficient returning 1 could depend compiler cases generically assuming read source local field constant embedded code function result etc requires exactly number clock cycles 
p1729
aVreturn depends want executable example using program command line shell need return 0 success non zero failure would able use program shells conditional processing depending outcome code also assign nonzero value per interpretation example critical errors different program exit points could terminate program different exit values available calling shell decide inspecting value returned code intended use shells returned value bother anybody might omitted personally use signature int main void return 0 
p1730
aVreturn value used operating system check program closed return value 0 usually means ok operating systems ones think anyway also checked call process see program exited finished properly programming convention 
p1731
aVreturn value main shows program exited return value zero means execution successful nonzero value represent something went bad execution 
p1732
aVmain c89 kampr c unspecified return types default int return 1 return 0 1 write return statement int main closing return 0 default 2 return 0 return 1 received environment variable os using environment variable worry return value main see _how get main function returned aout echo way see environment variable receives last one byte return value main writing script take care return value main otherwise dont unix dos scripting return 0 success nonzero error usually returned standard used unix dos scripting find happened program controlling whole flow 
p1733
aVreturning 0 tell programmer program successfully finished job 
p1734
aVvoid main forbidden c90 main return value used return 0 
p1735
aV standard c \u2014 hosted environment hosted environment thats normal one c11 standard isoiec 9899:2011 says: 51221 program startup function called program startup named main implementation declares prototype function shall defined return type int parameters: int mainvoid two parameters referred argc argv though names may used local function declared: int mainint argc char argv equivalent10 implementationdefined manner declared parameters main function shall obey following constraints: value argc shall nonnegative argvargc shall null pointer value argc greater zero array members argv0 argvargc1 inclusive shall contain pointers strings given implementationdefined values host environment prior program startup intent supply program information determined prior program startup elsewhere hosted environment host environment capable supplying strings letters uppercase lowercase implementation shall ensure strings received lowercase value argc greater zero string pointed argv0 represents program name argv00 shall null character program name available host environment value argc greater one strings pointed argv1 argvargc1 represent program parameters parameters argc argv strings pointed argv array shall modifiable program retain laststored values program startup program termination 10 thus int replaced typedef name defined int type argv written char argv program termination c99 c11 value returned main transmitted environment implementationdefined way 51223 program termination 1 return type main function type compatible int return initial call main function equivalent calling exit function value returned main function argument11 reaching terminates main function returns value 0 return type compatible int termination status returned host environment unspecified 11 accordance 624 lifetimes objects automatic storage duration declared main ended former case even would latter note 0 mandated success use exit_failure exit_success stdlibh prefer 0 well established 1 see also exit codes greater 255 \u2014 possible than255possible c89 hence microsoft c statement happens main function returns specify return value therefore leads undefined behaviour 72244 exit function ¶5 finally control returned host environment value status zero exit_success implementationdefined form status _successful termination_ returned value status exit_failure implementationdefined form status _unsuccessful termination_ returned otherwise status returned implementation defined standard c \u2014 hosted environment c11 standard isoiec 14882:2011 says: 361 main function basicstartmain ¶1 program shall contain global function called main designated start program ¶2 implementation shall predefine main function function shall overloaded shall return type type int otherwise type implementation defined implementations shall allow following definitions main: int main int mainint argc char argv latter form argc shall number arguments passed program environment program run argc nonzero arguments shall supplied argv0 argvargc1 pointers initial characters nullterminated multibyte strings ntmbss 1752142 argv0 shall pointer initial character ntmbs represents name used invoke program value argc shall nonnegative value argvargc shall 0 note: recommended optional parameters added argv \u2014end note ¶3 function main shall used within program linkage 35 main implementationdefined ¶5 return statement main effect leaving main function destroying objects automatic storage duration calling std::exit return value argument control reaches end main without encountering return statement effect executing return 0 c standard explicitly says main function shall return type type int otherwise type implementation defined requires two signatures c standard supported options void main directly allowed c standard though theres nothing stop nonstandard implementation allowing alternatives note c forbids user calling main c standard theres paragraph §185 start termination c11 standard identical paragraph §72244 exit function c11 standard quoted apart footnote simply documents exit_success exit_failure defined cstdlib standard c \u2014 common extension classically unix systems support third variant: int mainint argc char argv char envp third argument nullterminated list pointers strings environment variable name equals sign value possibly empty use still get environment via extern char environ long time header declared posix standard requires declared unistdh recognized c standard common extension documented annex j: j51 environment arguments ¶1 hosted environment main function receives third argument char envp points nullterminated array pointers char points string provides information environment execution program 51221 microsoft c microsoft vs 2010 uslibrary6wd819wh28vvs10029aspx compiler interesting web site says: declaration syntax main int main optionally int mainint argc char argv char envp alternatively main wmain functions declared returning void return value declare main wmain returning void cannot return exit code parent process operating system using return statement return exit code main wmain declared void must use exit function clear happens exit code returned parent os program void main exit \u2014 ms web site silent interestingly ms prescribe twoargument version main c c standards require prescribes three argument form third argument char envp pointer list environment variables microsoft page also lists alternatives \u2014 wmain takes wide character strings microsoft visual studio 2005 version page uslibrary6wd819wh28vvs8029aspx list void main alternative versions uslibrary6wd819wh28vvs9029aspx microsoft visual studio 2008 onwards standard c \u2014 freestanding environment noted early requirements apply hosted environments working freestanding environment alternative hosted environment standard much less say freestanding environment function called program startup need called main constraints return type standard says: 512 execution environments two execution environments defined: freestanding hosted cases program startup occurs designated c function called execution environment objects static storage duration shall initialized set initial values program startup manner timing initialization otherwise unspecified program termination returns control execution environment 5121 freestanding environment freestanding environment c program execution may take place without benefit operating system name type function called program startup implementationdefined library facilities available freestanding program minimal set required clause 4 implementationdefined effect program termination freestanding environment implementationdefined crossreference clause 4 conformance refers this: ¶5 _strictly conforming program_ shall use features language library specified international standard3 shall produce output dependent unspecified undefined implementation defined behavior shall exceed minimum implementation limit ¶6 two forms conforming implementation _hosted_ _freestanding_ _conforming hosted implementation_ shall accept strictly conforming program _conforming freestanding implementation_ shall accept strictly conforming program use features specified library clause clause 7 confined contents standard headers floath iso646h limitsh stdalignh stdargh stdboolh stddefh stdinth stdnoreturnh conforming implementation may extensions including additional library functions provided alter behavior strictly conforming program4 ¶7 _conforming program_ one acceptable conforming implementation5 3 strictly conforming program use conditional features see 61083 provided use guarded appropriate conditional inclusion preprocessing directive using related macro example: ifdef __stdc_iec_559__ fe_upward defined fesetroundfe_upward endif 4 implies conforming implementation reserves identifiers explicitly reserved international standard 5 strictly conforming programs intended maximally portable among conforming implementations conforming programs may depend upon nonportable features conforming implementation noticeable header required freestanding environment actually defines functions stdargh even may \u2014 often \u2014 macros standard c \u2014 freestanding environment c standard recognizes hosted freestanding environment c standard quotes isoiec 14882:2011 14 implementation compliance introcompliance ¶7 two kinds implementations defined: _hosted implementation_ _freestanding implementation_ hosted implementation international standard defines set available libraries freestanding implementation one execution may take place without benefit operating system implementationdefined set libraries includes certain languagesupport libraries 17613 ¶8 conforming implementation may extensions including additional library functions provided alter behavior wellformed program implementations required diagnose programs use extensions illformed according international standard done however compile execute programs ¶9 implementation shall include documentation identifies conditionallysupported constructs support defines localespecific characteristics3 3 documentation also defines implementationdefined behavior see 19 17613 freestanding implementations compliance two kinds implementations defined: hosted freestanding 14 hosted implementation international standard describes set available headers freestanding implementation implementationdefined set headers set shall include least headers shown table 16 supplied version header cstdlib shall declare least functions abort atexit at_quick_exit exit quick_exit 185 headers listed table shall meet requirements hosted implementation table 16 \u2014 c headers freestanding implementations subclause headers ciso646 182 types cstddef 183 implementation properties cfloat limits climits 184 integer types cstdint 185 start termination cstdlib 186 dynamic memory management new 187 type identification typeinfo 188 exception handling exception 189 initializer lists initializer_list 1810 runtime support cstdalign cstdarg cstdbool 209 type traits type_traits 29 atomics atomic 
p1736
aVsmall demonstration usage return codes using various tools linux terminal provides one use return code example error handling process completed imagine following text file myfile present: example order check grep works execute grep command process created didnt break returns code 0 255 example: grep order myfile echo 0 get 0 grep match returned exit code 0 usual value exiting success lets check something inside text file thus match found: grep foo myfile echo 1 since grep failed match token foo content file return code 1 usual case failure occurs stated plenty values choose following bash script simply type linux terminal although basic give idea error handling: grep foo myfile check check eq 0 echo match found check ne 0 echo match found match found second line nothing printed terminal since foo made grep return 1 check return code grep equal 0 second conditional statement echoes message last line since true due check 1 see calling process sometimes essential see returned return value main 
p1737
aVnote c c standards define two kinds implementations: freestanding hosted c90 hosted environment allowed forms 1: int main void int main int argc char argv main void main int argc char argv etc similar forms implicit int comments: former two explicitly stated allowed forms others implicitly allowed c90 allowed implicit int return type function parameters form allowed c90 freestanding environment form name main allowed 2 c99 hosted environment allowed forms 3: int main void int main int argc char argv implementationdefined manner comments: c99 removed implicit int main longer valid strange ambiguous sentence implementationdefined manner introduced either interpreted parameters int main may vary main implementationdefined form compilers chosen interpret standard latter way arguably one cannot easily state strictly conforming citing standard since ambiguous however allow completely wild forms main probably intention new sentence c99 rationale normative implies sentence refers additional parameters int main 4 yet section hosted environment program termination goes arguing case main return int 5 although section normative main declared definitely implies main might declared completely implementationdefined way even hosted systems c99 freestanding environment form name main allowed 6 c11 hosted environment allowed forms 7: int main void int main int argc char argv implementationdefined manner c11 freestanding environment form name main allowed 8 note int main never listed valid form hosted implementation c versions c unlike c void different meanings former obsolescent feature may removed language see c11 future language directions: 6116 function declarators use function declarators empty parentheses prototypeformat parameter type declarators obsolescent feature c03 hosted environment allowed forms 9: int main int main int argc char argv comments: note empty parenthesis first form c c different case c means function takes parameters c means may take parameter c03 freestanding environment name function called startup implementationdefined named main must follow stated forms 10: implementationdefined name int main int main int argc char argv c11 hosted environment allowed forms 11: int main int main int argc char argv comments: text standard changed meaning c11 freestanding environment name function called startup implementationdefined named main must follow stated forms 12: implementationdefined name int main int main int argc char argv references 1 ansi x31591989 2122 hosted environment program startup function called program startup named main implementation declares prototype function shall defined return type int parameters: int mainvoid two parameters referred argc argv though names may used local function declared: int mainint argc char argv 2 ansi x31591989 2121 freestanding environment: freestanding environment c program execution may take place without benefit operating system name type function called program startup implementationdefined 3 iso 9899:1999 5122 hosted environment 51221 program startup function called program startup named main implementation declares prototype function shall defined return type int parameters: int mainvoid two parameters referred argc argv though names may used local function declared: int mainint argc char argv equivalent9 implementationdefined manner 4 rationale international standard \u2014 programming languages \u2014 c revision 510 5122 hosted environment 51221 program startup behavior arguments main interaction exit main atexit see §72042 codified curb unwanted variety representation argv strings meaning values returned main specification argc argv arguments main recognizes extensive prior practice argvargc required null pointer provide redundant check end list also basis common practice main function may portably declared either zero two arguments number functions\u2019 arguments must match exactly invocation definition special case simply recognizes widespread practice leaving arguments main program access program argument strings many implementations support two arguments main practice neither blessed forbidden standard program defines main three arguments strictly conforming see §j51 5 iso 9899:1999 5122 hosted environment 51223 program termination return type main function type compatible int return initial call main function equivalent calling exit function value returned main function argument11 reaching terminates main function returns value 0 return type compatible int termination status returned host environment unspecified 6 iso 9899:1999 5121 freestanding environment freestanding environment c program execution may take place without benefit operating system name type function called program startup implementationdefined 7 iso 9899:2011 5122 hosted environment 51221 program startup section identical c99 one cited 8 iso 9899:1999 5121 freestanding environment section identical c99 one cited 9 iso 14882:2003 361 main function implementation shall predefine main function function shall overloaded shall return type type int otherwise type implementationdefined implementations shall allow following definitions main: int main int mainint argc char argv 10 iso 14882:2003 361 main function implementationdefined whether program freestanding environment required define main function 11 iso 14882:2011 361 main function implementation shall predefine main function function shall overloaded shall return type type int otherwise type implementationdefined implementations shall allow \u2014 function returning int \u2014 function int pointer pointer char returning int type main 835 12 iso 14882:2011 361 main function section identical c03 one cited 
p1738
asS'1461432'
p1739
(lp1740
Varray decaying decaying array relation array pointers 
p1741
aVarray rots pointed actually want pass array somewhere pointer passed instead hell would pass whole array people say poor array decayed pointer 
p1742
aVsaid arrays decay pointers c array declared int numbers 5 cannot repointed ie cant say numbers 0x5a5aff23 importantly term decay signifies loss type dimension numbers decay int losing dimension information count 5 type int 5 look cases decay doesnt happen arraynotdecayingintoapointer youre passing array value youre really copying pointer pointer arrays first element copied parameter whose type also pointer array elements type works due arrays decaying nature decayed sizeof longer gives complete arrays size essentially becomes pointer preferred among reasons pass reference pointer three ways pass array1: void by_valueconst array const array means void by_pointerconst arrayu void by_referenceconst arrayu last two give proper sizeof info first one wont since array argument decayed assigned parameter 1 constant u known compiletime 
p1743
aVarrays basically pointers cc quite convert array: const int 2 3 5 7 11 pointer works without casting therefore happen unexpectedly cases: const int p lose ability sizeof operator count elements array: assert sizeofp sizeofa sizes equal lost ability referred decay details check article array decay 
p1744
aVarray decaying means array passed parameter function treated identically decays pointer void do_somethingint array dont know big array decayed pointer printfi\u005cn sizeofarray always prints 4 32bit machine int main int argc char argv int a10 int b20 int c printfi\u005cn sizeofa prints 40 32bit machine printfi\u005cn sizeofb prints 80 32bit machine printfi\u005cn sizeofc prints 4 32bit machine do_somethinga do_somethingb do_somethingc two complications exceptions first dealing multidimensional arrays c c first dimension lost arrays layed contiguously memory compiler must know first dimension able calculate offsets block memory void do_somethingint array10 dont know big first dimension int mainint argc char argv int a510 int b2010 do_somethinga do_somethingb return 0 second c use templates deduce size arrays microsoft uses c versions secure crt functions like strcpy_s use similar trick reliably get number elements array usefulccsnippet470221470221 
p1745
aVarrays c value wherever value object expected object array address first element used instead type pointer type array elements function parameters passed value arrays exception pass array function decays pointer sic compare array something else decays pointer sic void fooint arr function foo expects value array c arrays value foo gets instead address first element array int arr5 int ip arr1 arr ip something comparison arr value becomes pointer becomes pointer int pointer compared variable ip array indexing syntax used seeing arr decayed pointer arr42 arr 42 arr0 42 times array doesnt decay pointer operand sizeof operator amp operator address operator string literal used initialize character array 
p1746
aVheres standard says c99 63213 operands lvalues arrays function designators: except operand sizeof operator unary amp operator string literal used initialize array expression type \u2018\u2018array type\u2019\u2019 converted expression type \u2018\u2018pointer type\u2019\u2019 points initial element array object lvalue means pretty much anytime array name used expression automatically converted pointer 1st item array note function names act similar way function pointers used far less much specialized way doesnt cause nearly much confusion automatic conversion array names pointers c standard 42 arraytopointer conversion loosens conversion requirement emphasis mine: lvalue rvalue type \u201carray n t\u201d \u201carray unknown bound t\u201d converted rvalue type \u201cpointer t\u201d conversion doesnt _have_ happen like pretty much always c lets functions overload templates match array type also c avoid using array parameters function prototypesdefinitions opinion im sure theres general agreement cause confusion fiction anyway use pointer parameters confusion might go away entirely least parameter declaration isnt lying 
p1747
aVdecay refers implicit conversion expression array type pointer type contexts compiler sees array expression converts type expression nelement array pointer sets value expression address first element array exceptions rule array operand either sizeof operators array string literal used initializer declaration assume following code: char a80 strcpya test expression type 80element array char expression test type 16element array char c c string literals arrays const char however call strcpy neither expression operand sizeof types implicitly converted pointer char values set address first element strcpy receives arrays pointers seen prototype: char strcpychar dest const char src thing array pointer example: char a80 char ptr_to_first_element char ptr_to_array80 ptr_to_first_element ptr_to_array _value_ base address however different types treated differently shown below: ai ptr_to_first_elementi ptr_to_arrayi ptr_to_arrayi ptr_to_arrayi remember expression ai interpreted ai works array type converted pointer type ai ptr_to_first_elementi work expression ptr_to_arrayi interpreted ai expressions ptr_to_arrayi ptr_to_arrayi may lead compiler warnings errors depending context theyll definitely wrong thing youre expecting evaluate ai sizeof sizeof ptr_to_array 80 array operand sizeof converted pointer type sizeof ptr_to_first_element sizeof char 1 sizeof ptr_to_first_element sizeof char whatever pointer size platform ptr_to_first_element simple pointer char 
p1748
asS'724617'
p1749
(lp1750
Vexamples union c im looking union examples understand union works hopefully see kind hack people union feel free share union hack explanation course : 
p1751
aVheres little one use every day: struct tagvariant union struct __tagvariant vartype vt word wreserved1 word wreserved2 word wreserved3 union long lval vt_i4 byte bval vt_ui1 short ival vt_i2 float fltval vt_r4 double dblval vt_r8 variant_bool boolval vt_bool _variant_bool bool obsolete scode scode vt_error cy cyval vt_cy date date vt_date bstr bstrval vt_bstr iunknown punkval vt_unknown idispatch pdispval vt_dispatch safearray parray vt_array byte pbval vt_byrefvt_ui1 short pival vt_byrefvt_i2 long plval vt_byrefvt_i4 float pfltval vt_byrefvt_r4 double pdblval vt_byrefvt_r8 variant_bool pboolval vt_byrefvt_bool scode pscode vt_byrefvt_error cy pcyval vt_byrefvt_cy date pdate vt_byrefvt_date bstr pbstrval vt_byrefvt_bstr iunknown ppunkval vt_byrefvt_unknown idispatch ppdispval vt_byrefvt_dispatch safearray pparray vt_byrefvt_array variant pvarval vt_byrefvt_variant pvoid byref generic byref char cval vt_i1 ushort uival vt_ui2 ulong ulval vt_ui4 int intval vt_int uint uintval vt_uint decimal pdecval vt_byrefvt_decimal char pcval vt_byrefvt_i1 ushort puival vt_byrefvt_ui2 ulong pulval vt_byrefvt_ui4 int pintval vt_byrefvt_int uint puintval vt_byrefvt_uint __variant_name_3 __variant_name_2 decimal decval __variant_name_1 definition ole automation variant data type see lots possible types lots rules around types use different situations depending capabilities intended client code types supported languages types vt_byref used languages vbscript pass parameters reference default means code cares variant structure details c called code doesnt vb carefully dereference variant parameter required byref types also used return values functions also support array types using weirdly misnamed safearray type difficult use c array strings pass vbscript cannot used except print size actually read values array data needs type vt_byref vt_bstr 
p1752
aVcoincidentally used one stackoverflow answer bitfieldstructure724415724415 could treat word made 6 bit fields two 16 bit unsigned integers years ago also used one first arm c compiler instructions days 32 bit different layouts depending exact instruction union represent arm instruction containing set structs appropriate bitfields specific instruction type 
p1753
aVone classic represent value unknown type core simplistic virtual machine: typedef enum integer string real pointer type typedef struct type type union int integer char string float real void pointer x value using write code handles values without knowing exact type instance implement stack since old prec11 c inner union must given field name outer struct c let union anonymous picking name hard tend go something singlelettered since almost never referenced isolation thus always clear context going code set value integer might look like this: value value_new_integerint v value v vtype integer vxinteger v return v use fact structs returned directly treated almost like values primitive type assign structs 
p1754
aV struct inputevent enum eventtype eventkeypressed eventkeypressrepeated eventkeyreleased eventmousepressed eventmousemoved eventmousereleased type union unsigned int keycode struct int x int y unsigned int buttoncode std::vectorinputevent inputqueue union hack simply make vector objects im sure could made cleanbut works kiss 
p1755
aVplease avoid hacks union cause portability headaches endianness alignment issues legitimate use union store different data types place preferably tag know type see example 1800 information dont use union convert data types eg integer several bytes use shift masking instead portability 
p1756
aV define dword unsigned int define word unsigned short define byte unsigned char typedef union _dword_part_ dword dwword struct word dwmsb word dwlsb hw struct byte bymsb byte bymsbl byte bylsbh byte bylsb b dword_part easy way access words parts done change endianness platform also handled easily 
p1757
aVunions also commonly used lexical analysis parsing stage language processors like compilers interpreters one im editing right union char c int string double d expression e expressionlist el fpos_t fp union used associate semantic values tokens lexical analyzer productions parser practice quite common grammar generators like _yacc_ provides explicit support union hold values one time instance one point input file youve either read character constant stored c integer stored floating point number stored d grammar generator provides considerable assistance determining values stored one time depending rule processed 
p1758
aVuse unions packed messages work cc pass around structure union data member access correct path based id field structure worked find somebody wrote structure file limited largest data used file even thought theres file version nobody ever changed useful inmemory work avoid blindly writing disk network 
p1759
asS'10468128'
p1760
(lp1761
Vmake array structs c im trying make array structs struct represents celestial body problem im working class dont much experience structs decided try use instead whole bunch arrays however keep running numerous different errors even though ive tried implement techniques ive seen various threads stackoverflow array structs c initialize array structs initializearrayofstructs however applicable wasnt able completely copy way forewarning show im trying wont able reply commentsquestionsanswers several hours need go bed since ive awake far long im truly sorry im really tired busy day worked problem several hours information read far: dont need dynamic knowdefine size everything beforehand also need global array _gasp_ global variables im accessing several different methods defined arguments ie glut methods im defining struct header: struct body double p3position double v3velocity double a3acceleration double radius double mass list global variables im defining define interior struct one array struct basically im unclear fogged speak line stuff above: struct body bodiesn know n something ive legitimately defined ie define n 1 use array several different methods easiest least space consuming one simplified form main initialize variables structs set variables certain modify way: int b fora 0 n forb 0 b 3 b bodiesapb 0 bodiesavb 0 bodiesaab 0 bodiesamass 0 bodiesaradius 10 current error im facing nbodyc:32:13: error: array type incomplete element type line 32 im making array structs thank help deign give promise get back latest 12 hours one last clarification header mean space int mainvoid c file 
p1762
aVmove struct body bodiesn struct body double p3position double v3velocity double a3acceleration double radius double mass rest looks fine 
p1763
aV includestdioh define n 3 struct body double p3position double v3velocity double a3acceleration double radius double mass struct body bodiesn int main int b fora 0 n forb 0 b 3 b bodiesapb 0 bodiesavb 0 bodiesaab 0 bodiesamass 0 bodiesaradius 10 return 0 works fine question much clear way match layout source code 
p1764
aVerror means compiler able find definition type struct declaration array structs since youre saying definition struct header file error nbodyc check youre including correctly header file check includes make sure definition struct done declaring variable type 
p1765
aVput togetger using malloc: int mainint argc char argv typedef struct char firstname char lastname int day int month int year student int numstudents3 int x student students mallocnumstudents sizeof students x 0 x numstudents x studentsxfirstnamecharmallocsizeofchar scanfsstudentsxfirstname studentsxlastnamecharmallocsizeofchar scanfsstudentsxlastname scanfdstudentsxday scanfdstudentsxmonth scanfdstudentsxyear x 0 x numstudents x printffirst name: surname: day: d month: d year: d\u005cnstudentsxfirstnamestudentsxlastnamestudentsxdaystudentsxmonthstudentsxyear return exit_success 
p1766
aVthink could write way also student understand struggle bit late response ok includestdioh define n 3 struct double p3position double v3velocity double a3acceleration double radius double mass bodiesn 
p1767
asS'18415904'
p1768
(lp1769
Vmode_t 0644 mean  define copymode 0644 creatargv2copymode two lines code copyc file dont know means please give example 
p1770
aVmeans that: files owner read write 6 users group files owner read first 4 users read second 4 see 
p1771
aV3x3 bit flags mode: owning user read write execute group read write execute read write execute triple encodes nicely octal digit rwx oct meaning 001 01 execute 010 02 write 011 03 write execute 100 04 read 101 05 read execute 110 06 read write 111 07 read write execute 0644 is: owning user: read write group: read other: read note c initial 0 indicates octal notation like 0x indicates hexadecimal notation every time write plain zero c actually _octal_ zero fun fact might also written: rwrr whereas full permissions 0777 also written: rwxrwxrwx octal number passed creat corresponds directly via octal encoding bitpattern file permissions displayed ls l 
p1772
asS'23905299'
p1773
(lp1774
Vstatic storage class c declare static variable function manner: static int i4 custom code works supposed ie maintains variable value across function calls declare follows: static int i4 custom code maintaining value across calls works like local variable mean static variable anymore inside function reason behind behaviour similar situation occurs extern keyword 
p1775
aVinitialization first code assignment second code second code remain value across function calls well assigned another value 4 void foo static int remains value last call i4 assigned 4 custom code 
p1776
aVsaves value across function calls assign variable like this: static int i4 assigned like this: static int i4 means: create variable assign 4 every time function runs small demo: ideone 
p1777
aV second code statement overwriting value seems work like local variable though 
p1778
aVinitialization assignment different first step initializing assigning second assigning variable static initialization done assignment may multiple time reason first case value persistent bn different calls 
p1779
asS'2748995'
p1780
(lp1781
Vc struct memory layout c background newbie low level language like c c structs memory laid compiler default compiler reorder data fields pad additional bits fields implicitly specify special attribute override behavior exact layout afaik c reorder align memory layout struct default heard theres little exceptions hard find cs memory layout behavior reorderedaligned 
p1782
aVstart reading data structure alignment wikipedia article better understanding data alignment wikipedia article data alignment means putting data memory offset equal multiple word size increases systems performance due way cpu handles memory align data may necessary insert meaningless bytes end last data structure start next data structure padding 6548 structurepacking pragmas structure_002dpackingpragmashtml gcc documentation: compatibility microsoft windows compilers gcc supports set pragma directives change maximum alignment members structures zerowidth bitfields unions classes subsequently defined n value always required small power two specifies new alignment bytes 1 pragma packn simply sets new alignment 2 pragma pack sets alignment one effect compilation started see also command line option fpack struct see code gen options 3 pragma packpushn pushes current alignment setting internal stack optionally sets new alignment 4 pragma packpop restores alignment setting one saved top internal stack removes stack entry note enter code herepragma packn influence internal stack thus possible pragma packpush followed multiple pragma packn instances finalized single pragma packpop targets eg i386 powerpc support ms_struct pragma lays structure documented __attribute__ ms_struct 1 pragma ms_struct turns layout structures declared 2 pragma ms_struct turns layout structures declared 3 pragma ms_struct reset goes back default layout 
p1783
aVc compiler allowed dictate alignment every primitive type typically alignment size type entirely implementationspecific padding bytes introduced every object properly aligned reordering allowed possibly every remotely modern compiler implements pragma pack allows control padding leaves programmer comply abi strictly nonstandard though c99 §6721: 12 nonbitfield member structure union object aligned implementation defined manner appropriate type 13 within structure object nonbitfield members units bitfields reside addresses increase order declared pointer structure object suitably converted points initial member member bitfield unit resides vice versa may unnamed padding within structure object beginning 
p1784
aVc structures laid nearly exactly specify code similar cs structlayoutsequential difference member alignment never reorders data members structure change size structure inserting pad bytes middle structure reason make sure members starts boundary usually 4 8 bytes example: struct mystruct int short int b char c size structure usually 12 bytes 4 member compilers default make member size largest structure char take 4 bytes instead one important note sizeofmystruct::c still 1 sizeofmystruct 12 hard predict structure paddedaligned compiler default explained default paddingalignment also sometimes called packed method altering behavior compiler dependent nothing language specifying handled msvc would use pragma pack1 turn alignment 1 says align everything 1 byte boundaries gcc would use __attribute__packed structure definition consult documentation compiler see default change behavior 
p1785
aVimplementationspecific practice rule absence pragma pack like is: struct members stored order declared required c99 standard mentioned earlier necessary padding added struct member ensure correct alignment primitive type requires alignment sizeoft bytes given following struct: struct st char ch1 short char ch2 long long ll int ch1 offset 0 padding byte inserted align offset 2 ch2 offset 4 immediately 3 padding bytes inserted align ll offset 8 offset 16 right ll 4 padding bytes added end overall struct multiple 8 bytes checked 64bit system: 32bit systems may allow structs 4byte alignment sizeofst 24 reduced 16 bytes rearranging members avoid padding: struct st long long ll @ 0 int @ 8 short @ 12 char ch1 @ 14 char ch2 @ 15 st 
p1786
asS'37879642'
p1787
(lp1788
Vconstexpr static template function: g error warning clang consider following snippet: include iostream template int constexpr int f return fi1 template constexpr int f0 return 1 int main std::cout f5 return 0 code compiles nicely g clang nice add static template function specialization: template constexpr static int f0 return 1 g 61 reacts error: 11 : error: explicit template specialization cannot storage class clang 38 too: 11 : error: explicit specialization extraneous inconsistent storage class static look like agreement nice add static keyword also template function general case: g 61: 11 : error: explicit template specialization cannot storage class clang 38 compiles warning: 11 : warning: explicit specialization cannot storage class clang result returns correct answer bug clang case make sense throw error 
p1789
aVsimple dclstc1 far back c98: _storageclassspecifier_ thread_local shall specified explicit specialization 1473 explicit instantiation 1472 directive 
p1790
asS'31380268'
p1791
(lp1792
Vdeclare structures inside main outside main case 1: structure declared outside main working fine includestdioh includeconioh struct prod int priceusold int main struct prod pa int billamtstruct prod int bill printfenter values \u005cn scanfddppricepusold billbillamtp printfbilldbill getch int billamtstruct prod int b bipriceiusold return b case 2: declared inside main giving error error type main::prod linkage used declare function int billamtmain::prod linkage fpermissive includestdioh includeconioh int main struct prod int priceusold struct prod pa int billamtstruct prod int bill printfenter values \u005cn scanfddppricepusold billbillamtp printfbilldbill getch int billamtstruct prod int b bipriceiusold return b 
p1793
aV_scoping_ define structure inside main function defined scope main function billamt function cant know 
p1794
aV _where declare structures inside main outside main_ 1 first thing think meant define declare 2 second _rule_ define wherever want _scope_ definition define structure inside main scope limited main function cannot see definition hence cannot make use structure definition define structure global scope ie outside main function matter definition available globally functions _see_ make use structure definition 
p1795
aVstructure like array main difference array hold type values structure different types values need implement structure globallyby globally mean used function define outside main want use structure main function define inside happy coding : 
p1796
asS'9749943'
p1797
(lp1798
Vmake structure extern define typedef im trying implement tree algorithms c declared extern struct header file completely independent b_tree_dsh plan import file source files want use struct must declare using extern header problem thhat want define typedef well compiler gives error multiple storage classes typedef extern struct node struct node left struct node right int key contains value node actual problem follow still cant fix recently learnt use multiple source files header files make code portable hierarchical order tired creating tree program using principal files b_tree_dsh contain _declaration_ datastructure node tree called various functions implementing different functionality tree may different source files typedef struct node struct node left struct node right int key contains value node try adding extern typedef extern struct node gives error multiple storage class miss get error multiple definitions source files traverseh contains declaration traverse function void traverse_print node p also get error unknown identifier node traversec contains definition function include stdioh include b_tree_dsh include traverseh void traverse_printnode p ifpleft null traverse_printpleft pright null traverse_printpright printf \u005cndpkey finally mainc include stdioh include traverseh void main input node p printf\u005cninput tree input_tree p printf\u005cn\u005cnthe tree traversing \u005cn traverse_printp void input_tree node p int int c node temp printf\u005cn enter key value p: scanfd pkey printf \u005cn\u005cnin relation node value din printf left child yn: c getchar y assign new memory temp node mallocsizeofnode input_treetemp printf \u005cn\u005cnin relation node value dpkey printf \u005cndoes right child yn: c getchar y assign new memory temp node mallocsizeofnode input_treetemp first attempt practice please suggest structuring program good try something else 
p1799
aVcant make struct extern define includeguard protected header include header everywhere need edit squarerootoftwentythree use therms following way structure type definition describes members part structure contains struct keyword followed optional identifier structure tag braceenclosed list members structure declaration form structure definition except declaration braceenclosed list members definition exactly meant 
p1800
aVheader file declare nodeh like ifndef node_h define node_h ifdef __cplusplus extern c endif typedef struct node struct node left struct node right int key contains value node ifdef __cplusplus endif endif node_h include header file c program use like node newnode null 
p1801
aVc structures linkage objects functions write this: header file nodeh typedef struct node_ node extern node root_node provide implementation somewhere: source file include nodeh node root_node 
p1802
asS'24469866'
p1803
(lp1804
Vrun c program windows command prompt using vim editor wrote following simple code c saved helloworldc : include stdioh int mainvoid printfhello world\u005cn command prompt wrote: start chrome helloworldc caused browser open file print world instead displayed code written save c file also wondering display result c program inline command prompt fairly new searching internet could find answers supposed vim learned supposed gedit command box display result inline work one comes windows please help thank taking time read answer 
p1805
aV@ernest friedmanhill already said normally compile program however alternatives one alternative tiny c compiler allow run program without compiling tcc run helloworldc exactly want tiny c compiler way run c code source without compiling first alternatives csl: ch: picoc: cint: hope helps 
p1806
asS'1951269'
p1807
(lp1808
Vc: union practically used example alignment type guaranteed union max_align looking even simpler example union used practically explain friend 
p1809
aVmean something like union long long unsigned char bsizeoflong long long_long_to_single_bytes added: recently used aix machine transform 64bit machine indentifier bytearray std::string gethardwareuuidvoid ifdef aix struct xutsname m aix specific struct hold 64bit machine id unamexb aix specific call get 64bit machine id long_long_to_single_bytesa mlongnid return converttohexstringlong_long_to_single_bytesb sizeoflong long else windows linux solaris get 6byte ethernet mac address somehow put mac_buf return converttohexstringmac_buf 6 endif 
p1810
aVexample: using different socket types want comon type refer 
p1811
aV struct cat_info int legs int taillen struct fish_info bool hasspikes union fish_info fish cat_info cat animal_data struct animal char name int animal_type animal_data data 
p1812
aVanother example more: save castings typedef union long int_v float float_v int_float void foofloat v int_float ifloat_v v printfsignd expd fractiond iint_v311 iint_v220xff128 iint_v1221 instead of: void foofloat v long longv printfsignd expd fractiond i311 i220xff128 i1221 
p1813
aVusually use unions parsing text use something like this: typedef enum datatype integer float_point string datatype typedef union datavalue int v_int float v_float char v_string datavalue typedef struct datanode datatype type datavalue value datanode void myfunct long long temp datanode inputdata inputdatatype read_some_inputtemp switchinputdatatype case integer: inputdatavaluev_int inttemp break case float_point: inputdatavaluev_float floattemp break case string: inputdatavaluev_string chartemp break void printdatanodedatanode ptr printfi switchptrtype case integer: printfinteger value d ptrvaluev_int break case float_point: printffloat value f ptrvaluev_float break case string: printfstring value ptrvaluev_string break want see unions used heavily check code using flex example see splint 
p1814
aVaccessing registers io ports bytewise well bitwise mapping particular port memory see example below: typedef union unsigned int struct unsigned bit0 : 1 bit1 : 1 bit2 : 1 bit3 : 1 bit4 : 1 bit5 : 1 bit6 : 1 bit7 : 1 bit8 : 1 bit9 : 1 bit10 : 1 bit11 : 1 bit12 : 1 bit13 : 1 bit14 : 1 bit15 : 1 bits ioreg define porta ioreg 0x3b unsigned int portaaread bytewise int j portabitsbit0read bitwise portabitsbit0 1write operation 
p1815
aVive typically used unions want different views data eg 32bit colour value want 32bit val redgreenblue alpha components struct rgba unsigned char r unsigned char g unsigned char b unsigned char union unsigned int val rgba components colorval32 nb could also achieve thing bitmasking shifting ie define getrval val0xff000000 24 find union approach elegant 
p1816
aVconvenience use unions let use class store xyzw rgba values ifndef vertex4dh define vertex4dh struct vertex4d union double x double r union double y double g union double z double b union double w double vertex4ddouble x0 double y0double z0double w0 : xx yyzzww endif 
p1817
aVunions useful different kinds messages case dont know intermediate levels exact type sender receiver need parse message actual message levels really need know size possibly sender andor receiver info 
p1818
aVmany examples unions found x11xlibh others ip stacks bsd netinetiph instance general rule protocol implementations use union construct 
p1819
aVive used sometimes unions way define type structure typedef enum analog boolean unknown typevalue_t define union typedef struct typevalue_t typevalue structure access correct type data according type union float paramanalog char parambool value_t could declare arrays different kind values storing less efficiently data make polimorph operations like: void printvalue value_t value switch valuetypevalue case bool: printfbolean: c\u005cn valueparamboolt:f break case analog: printfanalog: f\u005cn valueparamanalog break case unknown: printferror value unknown\u005cn break 
p1820
aVanother example union could useful idea found document discussing c optimizations beginquote unions also used save space eg first nonunion approach: void f3bool useint y int a1000 f1a call function expects array int parameter else float b1000 f2b call function expects array float parameter possible use memory area b live ranges overlap save lot cpucache space joining b union: void f3bool useint union int a1000 float b1000 y f1a call function expects array int parameter else f2b call function expects array float parameter using union safe programming practice course get warning compiler uses b overlap use method big objects take lot cache space endqoute 
p1821
aVunions also useful type punning select places techniques floatingpoint comparison softwarecompaperscomparingfloatscomparingfloatshtm algorithms 
p1822
aVwindows world unions commonly used implement tagged variants net one standard way passing data com objects idea union type provide single natural interface passing arbitrary data two objects com object could pass variant eg type variant uslibraryms221627aspx _variant_t uslibraryx295h94e\u005cvs80\u005caspx could contain either double float int whatever deal com objects windows c code youll see variant types place variants safearrays bstrs oh boost variant 
p1823
aV reading serialized data needs coerced specific types returning semantic values lex yacc yylval implementing polymorphic type especially one reads dsl general language implementing dispatcher specifically calls functions intended take different types 
p1824
aVrecently think saw union used vector programming programming used intel mmx technology hardware ibms cell broadband engine vector may correspond 128 bit register commonly used simd 128bit registers store 4 singleprecisionfloating points registervariable easy way construct convert extract individual elements vector use union typedef union vector4f vec processorspecific builtin type struct humanfriendly access transformations etc float x float y float z float w struct humanfriendly access color processing lighting etc float r float g float b float float arr4 yet another convenience access vector4f int main vector4f position normal color humanfriendly access positionx 123f positiony 2f positionz 3f positionw 1f computer friendly access some_processor_specific_operationpositionvecnormalveccolorvec return 0 take path playstation 3 multicore programming graphics programming good chance youll face stuffs 
p1825
aVsdl uses union representing events: 
p1826
aVknow im bit late party practical example variant datatype vbscript believe implemented union following code simplified example taken article otherwise found struct tagvariant union vartype vt word wreserved1 word wreserved2 word wreserved3 union long lval byte bval short ival float fltval double dblval variant_bool boolval date date bstr bstrval safearray parray variant pvarval actual implementation article states found _oaidlh_ c header file 
p1827
asS'15915869'
p1828
(lp1829
Vproblems using mainint argcchar argv  includestdioh includestringh int mainint argcchar argv char string printfs\u005cnargv1 printfs\u005cnargv2 printfs\u005cnargv3 strcatargv1string printfargv1 s\u005cnargv1 printfargv2 s\u005cnargv2 printfargv3 s\u005cnargv3 return 0 use strcat add something end argv1argv2 lost strlenargv2 changes 0 use strcat argv3 change 
p1830
aVarent supposed modify argv effects undefined 
p1831
aVremember strings c zero terminated arrays characters suppose original four arguments one two three four four arguments stored memory one\u005c0two\u005c0three\u005c0four\u005c0 appended argv1 strcat add \u005c0 also memory content becomes: one\u005c0two\u005c0hree\u005c0four\u005c0 verify argv2 points \u005c0 char hence empty string argv3 still points correctly remains intact 
p1832
aVcannot append stuff directly argv argv allocated serialized space memory hold original size understand happening imagine argv something like this: char buffer program\u005c0one\u005c0two\u005c0three\u005c0 char argv4 buffer0 buffer10 buffer14 buffer18 see write something one overwrite two break whole thing serialized memory workaround copy argv bigger buffer safely make modifications instance: char buf1024 strcpybuf argv1 strcatbuf string printfargv1 s\u005cn buf 
p1833
asS'1127396'
p1834
(lp1835
Vstruct constructor c struct constructor c trying solve problem getting syntax 
p1836
aV struct teststruct int id teststruct : id42 
p1837
aVc difference class struct members base classes private default classes whereas public default structs structs constructors syntax classes 
p1838
aVyes structure like class defaults public: class definition inheriting: struct foo int bar foovoid : bar0 considering question would suggest read tutorials questions faster complete 
p1839
aVyes structures classes c except structures members public default whereas classes members private default anything class able structure struct foo foo initialize foo 
p1840
aVyes structure union cannot class struct example unsigned int mtest example unions allow constructors structs make constructor union though question relates nontrivial constructors unions nontrivialconstructor 
p1841
aVc declaredefine structure like class constructorsdestructors structures variablesfunctions defined difference default scope variablesfunctions defined difference mostly able imitate functionality class using structs 
p1842
aV struct havesome int fun havesome fun 69 id rather initialize inside constructor dont need keep order 
p1843
aVyes possible constructor structure one example: includeiostreamh struct int x ax100 int main struct a1 getch 
p1844
aVanswers technically answer askers question thought id point case might encounter problems declare struct like this: typedef struct int x foo foo problems trying declare constructor course havent actually declared struct named foo youve created anonymous struct assigned alias foo also means able use foo scoping operator cpp file: fooh: typedef struct int x void myfuncint y foo foocpp: work struct foo never declared void foo::myfuncint y something fix must either this: struct foo int x foo this: typedef struct foo int x foo foo latter creates struct called foo gives alias foo dont use struct keyword referencing 
p1845
aVanswers mention struct basically treated class c allows constructor used initialise struct default values constructor takes sz b arguments initializes variables default values struct blocknode unsigned int bsize bool free unsigned char bptr blocknode next blocknode prev blocknodeunsigned int sz unsigned char b bool f true blocknode p 0 blocknode n 0 : bsizesz freef bptrb prevp nextn usage: unsigned char bptr new unsigned char1024 blocknode fblock new blocknode1024 btpr 
p1846
aVc struct amp class equal except structsdefault member access specifier public amp class private reason struct c c superset c must backward compatible legacy c types example language user tries include c header file legacych c code amp contains struct test int xy members struct test accessible like c 
p1847
aVnote one interesting difference least ms c compiler: plain vanilla struct like struct mystruct int id double x double y mystruct somewhere else might initialize array objects like this: mystruct _pointlist 1 10 10 2 10 20 3 20 10 however soon add userdefined constructor mystruct ones discussed youd get error like this: mystruct : types user defined constructors aggregate file line : error c2552: _pointlist : nonaggregates cannot initialized initializer list thats least one difference struct class kind initialization may good oo practice appears place legacy winsdk c code support know 
p1848
aVc struct c class one difference default struct members public class members private c program constructor struct include iostream using namespace std struct public: default also public hello::hello coutcalling constructorendl hello::hello coutcalling destructorendl int main obj creating obj calling constructor destructor return 0 
p1849
asS'1675351'
p1850
(lp1851
Vtypedef struct vs struct definitions im beginner c programming wondering whats difference using typedef defining structure versus using typedef seems like theres really difference accomplish struct mystruct int one int two vs typedef struct int one int two mystruct 
p1852
aVtypedef constructs used give data type new name case mostly done order make code cleaner: struct mystruct blah vs mystruct blah 
p1853
aVc c declare struct variables like: struct mystruct myvariable order able use mystruct myvariable instead typedef struct: typedef struct mystruct somestruct somestruct myvariable combine struct definition typedefs single statement declares anonymous struct typedefs typedef struct mystruct 
p1854
aVdifference comes use struct first way do: struct mystruct aname second way allows remove keyword struct mystruct aname 
p1855
aVuse struct without typedef youll always tor write struct mystruct myvar illegal tor write mystruct myvar use typedef dont need struct prefix anymore 
p1856
aVlatter example omit struct keyword using structure everywhere code write : mystruct instead struct mystruct save typing might readable matter taste 
p1857
aVcommon idiom using both: typedef struct x int x x different definitions make discussion clearer split sentence: struct int x typedef struct first line defining identifier within struct name space c sense use define variables function arguments newly defined type defining type argument struct s: void f struct argument struct required second line adds type alias global name space thus allows write: void f argument struct keyword longer needed note since identifier name spaces different defining structs global spaces error redefining identifier rather creating different identifier different place make difference clearer: typedef struct int x void correct void error: symbol already defined alias struct define function name struct identifiers kept different spaces cannot define function name typedef identifiers collide c slightly different rules locate symbol changed subtly c still keeps two different identifier spaces unlike c define symbol within class identifier space required provide structclass keyword: c struct int x defined class void f correct: struct optional changes search rules identifiers defined compiler search global identifier table found search within class identifiers code presented behaves way: typedef struct int x void correct void error: symbol already defined alias struct definition function second line struct cannot resolved automatically compiler create object define argument type must fall back including struct keyword: previous code int main struct 
p1858
aVc type specifier keywords structures unions enumerations mandatory ie always prefix types name _tag_ struct union enum referring type get rid keywords using typedef form information hiding actual type object longer visible declaring therefore recommended see eg linux kernel coding style guide actually _want_ hide information save keystrokes example use typedef would opaque type ever used corresponding accessor functionsmacros 
p1859
aVanother difference pointed giving struct name ie struct mystruct also enables provide forward declarations struct file could write: struct mystruct void doitstruct mystruct ptr without access definition recommend combine two examples: typedef struct mystruct int one int two mystruct gives convenience concise typedef name still allows use full struct name need 
p1860
aVfollowing code creates anonymous struct alias mystruct: typedef struct int one int two mystruct cant refer without alias dont specify identifier structure 
p1861
aVcant use forward declaration typedef struct struct anonymous type dont actual name forward declare typedef struct int one int two mystruct forward declaration like wont work: struct mystruct forward declaration fails void blahmystruct pstruct error c2371: mystruct : redefinition different basic types 
p1862
aVstruct typedef two different things struct keyword used define refer structure type example this: struct foo int n creates new type called struct foo name foo _tag_ meaningful immediately preceded struct keyword tags identifiers distinct _name spaces_ similar much restricted c concept namespaces typedef spite name define new type merely creates new name existing type example given: typedef int my_int my_int new name int my_int int _exactly_ type similarly given struct definition write: typedef struct foo foo type already name struct foo typedef declaration gives type new name foo syntax allows combine struct typedef single declaration: typedef struct bar int n bar common idiom refer structure type either struct bar bar note typedef name doesnt become visible end declaration structure contains pointer use struct version refer it: typedef struct node int data struct node next cant use node next node programmers use distinct identifiers struct tag typedef name opinion theres good reason using name perfectly legal makes clearer theyre type must use different identifiers least use consistent convention: typedef struct node_s node personally prefer omit typedef refer type struct bar typedef save little typing hides fact structure type want type opaque good thing client code going referring member n name opaque visibly structure opinion makes sense refer structure plenty smart programmers disagree point prepared read understand code written either way c different rules given declaration struct blah refer type blah even without typedef using typedef might make c code little clike think thats good thing 
p1863
aVsee clarification order c c define types differently c originally nothing additional set includes top c problem virtually cc developers today universities longer teaching fundamentals b people dont understand difference definition declaration reason declarations definitions exist linker calculate address offsets fields structure people get away code actually written incorrectly compiler able determine addressing problem arises someone tries something advance like queue linked list piggying backing os structure declaration begins struct definition begins typedef struct forward declaration label defined label people dont know use forward declaration label define label wrong: struct mystruct int field_1 theyve used forward declaration label structure compiler aware isnt actual defined type compiler calculate addressing isnt intended used reasons show momentarily people use form declaration must always put struct practicly every reference isnt offical new type instead structure reference declared defined way only: typedef struct field_1 mystruct actual type used use mystruct without prepend word struct want pointer variable structure include secondary label: typedef struct field_1 mystructmystructp pointer variable structure custom forward declaration heres fancy stuff forward declaration works want create type refers like linked list queue element use forward declaration compiler doesnt consider structure defined gets semicolon end declared point typedef struct mystructelement mystructelement nextse field_1 mystruct compiler knows although doesnt know whole type yet still reference using forward reference please declare typedef structures correctly theres actually reason 
p1864
asS'4698600'
p1865
(lp1866
Vwhats syntactically proper way declare c struct ive seen c structs declared several different ways anything different example: struct foo short int b float c typedef struct short d int e float f bar typedef struct _baz short int b float c baz int main int argc char const argv struct foo bar b baz c return 0 
p1867
aVlargely matter personal preference like give new types name starting capital letter omit struct usually write typedef struct foo means cannot write struct foo exception struct contains pointer type eg typedef struct node struct node next node case need also declare struct node type since typedef scope within struct definition note names may im sure underscore convention originated guess older c compilers couldnt handle typedef struct x x 
p1868
aVwell obvious difference demonstrated main: struct foo bar b baz c first declaration untypedefed struct needs struct keyword use second typedefed anonymous struct use typedef name third combines first second: example uses baz conveniently short could easily use struct _baz effect update: larsmans answer thesyntacticallyproperwaytodeclareacstruct46986184698618 mentions common case use least struct x make linked list second case wouldnt possible unless abandon sanity use void instead struct anonymous typedef doesnt happen struct defined giving way make typesafe pointer struct type first version works fine use third generally preferred experience give rep subtle difference namespace placement c struct tags placed separate namespace names typedef names arent following legal: struct test contents struct test test contents following would ambiguous name test is: typedef struct contents test test test contents typedef makes name shorter always plus puts namespace variables functions usually isnt issue subtle difference beyond simple shortening 
p1869
aVuses syntactically correct prefer following usage forward declare structs typedefs typedef struct foo foo declare struct struct foo short int b foo next observe easily allows use typedef already inside declaration struct even struct reference mutually 
p1870
aVconfusion comes declarations fact declaring three c constructs need keep mind difference between: 1\u005c typedef declaration 2\u005c struct definition 3\u005c struct declaration different c constructs different things combine one compound construct want lets look declaration turn struct foo short int b float c using basic struct definition syntax defining foo c _type_ later used declare variables type using following syntax: foo myfoo declare struct variable type foo next declaration bit like previous syntax declares c type uses typedef syntax lets break components using previous basic declaration typedef foo bar declare bar variable type alias foo bar mybar ssemantically as: foo mybar replace foo previous syntax voila typedef struct short d int e float f bar typedef struct _baz short int b float c baz syntax equivalent following sequence declarations struct _baz short int b float c typedef _baz baz declare baz alias _baz baz mybaz as: _baz mybaz 
p1871
asS'21238896'
p1872
(lp1873
Vcallbyvalue vs callbyreference revisited let first say know title suspects im asking question answered around internet many times research indeed yet cant find satisfying answer question end comes java call value c call reference using pointers consider method call java passing references c passing pointers end cases able make changes visible caller also cases im passing address object function fact im copying ie making call value c passing pointer dont simply verify circumstance running following code: include iostream void modify int int 5 int main int b int b std::cout std::endl modifyi std::cout std::endl return 0 print two times address enough justify call reference property swap function would like know heart makes call reference call reference thank advance 
p1874
aV question end comes java call value c call reference using pointers c really callbyvalue callbyreference byreference behavior see c side effect fact youre passing pointer: pointer copied value cant compare situations java doesnt pointers 
p1875
aVexample give inappropriate use call reference function modify void modify int int 5 declare local variable stack goes scope address meaningless assigning address effect points makes call reference work modify value points function example: void modify int int 5 therefore main function call like: int b 2 int b std::cout std::endl print 2 modifyi std::cout std::endl prints 5 
p1876
asS'15646973'
p1877
(lp1878
Vdangerous access array bounds dangerous accessing array outside bounds c sometimes happen read outside array understand access memory used parts program even beyond trying set value index outside array program sometimes crashes sometimes runs giving unexpected results would like know dangerous really damages program bad hand breaks something outside program somehow managed access totally unrelated memory bad imagine read lot anything happen segmentation might least bad problem pointercrossesthearraybounds harddisk might turn pink unicorns might singing window nice really danger questions: 1 reading values way outside array damage anything apart program would imagine looking things change anything would instance change last time opened attribute file happened reach 2 setting values way outside array damage anything apart program stackoverflow question 3 run small programs within xcode provide extra protection around program cannot reach outside memory harm xcode 4 recommendations run inherently buggy code safely use osx 107 xcode 46 first stackoverflow question took time reading much could subject probably missed many resources let know feel enough research andor see problems question 
p1879
aVbesides program dont think break anything worst case try read write memory address corresponds page kernel didnt assign proceses generating proper exception killed mean process 
p1880
aVrunning program root privileged user wont harm system generally might good idea writing data random memory location wont directly damage program running computer process runs memory space try access memory allocated process operating system stop program executing segmentation fault directly without running root directly accessing files like devmem danger program interfere program running operating system nevertheless probably heard terms danger blindly writing random data random memory locations accident sure damage anything able damage example program might want delete specific file given file name stored somewhere program accident overwrite location file name stored might delete different file instead 
p1881
aVwrite: read lot anything happen segmentation might least bad problem harddisk might turn pink unicorns might singing window nice really danger lets put way: load gun point outside window without particular aim fire danger issue know code overwrites something crashes program fine stop defined state however crash issues start arise resources control program might resources might get control program might know least one major issue caused overflow issue seemingly meaningless statistics function messed unrelated conversion table production database result _very_ expensive cleanup afterwards actually would much cheaper easier handle issue would formatted hard disks words: pink unicorns might least problem idea operating system protect optimistic possible try avoid writing bounds 
p1882
aVnsarrays objectivec assigned specific block memory exceeding bounds array means would accessing memory assigned array means: 1 memory value theres way knowing data valid based data type 2 memory may contain sensitive information private keys user credentials 3 memory address may invalid protected 4 memory changing value accessed another program thread 5 things use memory address space memorymapped ports 6 writing data unknown memory address crash program overwrite os memory space generally cause sun implode aspect program always want know code exceeding bounds array lead unknown values returned causing application crash provide invalid data 
p1883
aVgeneral operating systems today popular ones anyway run applications protected memory regions using virtual memory manager turns terribly easy per say simply read write location exists real space outside regions assigned allocated process direct answers: 1 reading almost never directly damage another process however indirectly damage process happen read key value used encrypt decrypt validate program process reading bounds somewhat adverse unexpected affects code making decisions based data reading 2 way could really damage something writing loaction accessible memory address memory address writing actually hardware register location actually data storage controlling piece hardware ram location fact still wont normally damage something unless writing one time programmable location rewritable something nature 3 generally running within debugger runs code debug mode running debug mode tend always stop code faster done something considered practice downright illegal 4 never use macros use data structures already array index bounds checking built etc additional add information really systems using operating system memory protection windows writing code embedded system even system utilizing operating system realtime memory protection windows virtual addressed windows one practice lot caution reading writing memory also cases safe secure coding practices always employed avoid security issues 
p1884
aVfar iso c standard official definition language concerned accessing array outside bounds _undefined behavior_ literal meaning is: behavior upon use nonportable erroneous program construct erroneous data international standard imposes requirements nonnormative note expands this: possible undefined behavior ranges ignoring situation completely unpredictable results behaving translation program execution documented manner characteristic environment without issuance diagnostic message terminating translation execution issuance diagnostic message thats theory whats reality best case youll access piece memory thats either owned currently running program might cause program misbehave thats _not_ owned currently running program probably cause program crash something like segmentation fault might attempt write memory program owns thats marked readonly probably also cause program crash thats assuming program running operating system attempts protect concurrently running processes code running bare metal say part os kernel embedded system protection misbehaving code supposed provide protection case possibilities damage considerably greater including cases physical damage hardware things people nearby even protected os environment protections arent always 100 operating system bugs permit unprivileged programs obtain root administrative access example even ordinary user privileges malfunctioning program consume excessive resources cpu memory disk possibly bringing entire system lot malware viruses etc exploits buffer overruns gain unauthorized access system one historical example: ive heard old systems core memory single memory location tight loop could literally cause chunk memory melt possibilities include destroying crt display moving readwrite head disk drive harmonic frequency drive cabinet causing walk across table fall onto floor theres always skynet bottom line this: could write program something bad _deliberately_ least theoretically possible buggy program could thing _accidentally_ practice _very_ unlikely buggy program running macos x system going anything serious crash possible _completely_ prevent buggy code really bad things 
p1885
aVim working compiler dsp chip deliberately generates code accesses one past end array c code loops structured end iteration prefetches data next iteration datum prefetched end last iteration never actually used writing c code like invokes undefined behavior formality standards document concerns maximal portability often program accesses bounds cleverly optimized simply buggy code fetches garbage value unlike optimized loops aforementioned compiler code _uses_ value subsequent computations thereby corrupting theim worth catching bugs like worth making behavior undefined even reason alone: runtime produce diagnostic message like array overrun line 42 mainc systems virtual memory array could happen allocated address follows unmapped area virtual memory access bomb program aside note c permitted create pointer one past end array pointer compare greater pointer interior array means c implementation cannot place array right end memory one plus address would wrap around look smaller addresses array nevertheless access uninitialized bounds values sometimes valid optimization technique even maximally portable instance valgrind tool report accesses uninitialized data accesses happen value later used way could affect outcome program get diagnostic like conditional branch xxx:nnn depends uninitialized value sometimes hard track originates accesses trapped immediately would lot false positives arising compiler optimized code well correctly handoptimized code speaking working codec vendor giving errors ported linux run valgrind vendor convinced several bits value used actually came uninitialized memory bits carefully avoided logic good bits value used valgrind doesnt ability track individual bit uninitialized material came reading word past end bit stream encoded data code knows many bits stream use bits actually since access beyond end bit stream array cause harm dsp architecture virtual memory array memorymapped ports address wrap valid optimization technique undefined behavior really mean much according iso c simply including header defined c standard calling function defined program c standard examples undefined behavior undefined behavior doesnt mean defined anyone planet defined iso c standard course sometimes undefined behavior really _is_ absolutely defined anyone 
p1886
aVmay want try using memcheck manualhtmlmcmanualoverview tool valgrind test code wont catch individual array bounds violations within stack frame catch many sorts memory problem including ones would cause subtle wider problems outside scope single function manual: memcheck memory error detector detect following problems common c c programs accessing memory shouldnt eg overrunning underrunning heap blocks overrunning top stack accessing memory freed using undefined values ie values initialised derived undefined values incorrect freeing heap memory doublefreeing heap blocks mismatched use mallocnewnew versus freedeletedelete overlapping src dst pointers memcpy related functions memory leaks eta: though kazs answer says panacea doesnt always give helpful output especially youre using _exciting_ access patterns 
p1887
aVchecking bounds lead ugly side effects including security holes one ugly ones arbitrary code execution classical example: fixed size array use strcpy put usersupplied string user give string overflows buffer overwrites memory locations including code address cpu return function finishes means user send string cause program essentially call execbinsh turn shell executing anything wants system including harvesting data turning machine botnet node see smashing stack fun profit done 
p1888
aVever systems level programming embedded systems programming bad things happen write random memory locations older systems many microcontrollers use memory mapped io writing memory location maps peripheral register wreak havoc especially done asynchronously example programming flash memory programming mode memory chips enabled writing specific sequence values specific locations inside address range chip another process write location chip going would cause programming cycle fail cases hardware wrap addresses around significant bitsbytes address ignored writing address beyond end physical address space actually result data written right middle things finally older cpus like mc68000 locked point hardware reset get going havent worked couple decades believe encountered bus error nonexistent memory trying handle exception would simply halt hardware reset asserted biggest recommendation blatant plug product personal interest affiliated way based couple decades c programming embedded systems reliability critical gimpels pc lint detect sort errors make better cc programmer _constantly_ harping bad habits id also recommend reading misra c coding standard snag copy someone havent seen recent ones ye olde days gave good explanation shouldshouldnt things cover dunno 2nd 3rd time get coredump hangup application opinion whatever company produced goes half 4th 5th time whatever package becomes shelfware drive wooden stake center packagedisc came make sure never comes back haunt 
p1889
asS'34384380'
p1890
(lp1891
Vexactly coutcin know java want learn c cant understand cout character output stream cin character input global variables messagecout doesnt work coutmy message works 
p1892
aVconsider arrows streams ltlt stands output stream stands input stream cout ltlt means output screen cin means asks user input variable cout also use like example add strings one stream like cout ltlt ltlt world ltlt john cin way ask input multiple variables cin b ask user input two times one variable 
p1893
aVcout instance class std::ostream yes global variable operatorchar ostream os hasnt declared relevant header messagecout give error something like cant find operator takes arguments const char std::ostream possibly lot errors sometimes compilers get confused sort things cin thing except std::istream really want mess peoples heads could do: templatetypename std::ostream operatort x std::ostream os os x return os course wont work message string cout probably one reasons done way note simply slight abuse operator overloading custom type lefthand side standard nonstandard type right hand side cout different variable custom type 
p1894
aVstd::cout std::cin indeed global variables code doesnt compile thats way language works put stream left operator variables streaming intoout output use literals expressions well variables 
p1895
aViostream header file contain classes handling input output operations console like create object say cin input class handling input operation console header file said cout object created class handling output operation console header file consider cin imagine creating pipe connected console program object cin taking inputs console provide keyboard dumping program thats reason see operator cin find analogy pipe operator taking job specifying direction object cin whereas cout imagine creating pipe connected console program object cout taking input program dumping console thats reason see ltlt operator cout find analogy pipe operator taking job specifying direction object cout basically need first specify object would creating operations assigning operator accomplish task include header file like could use objects anywhere throughout program messagecout doesnt function way expect object operator accomplish task whereas coutltltmy message technical aspects described mats petersson give general picture whats actually happening pictorially hope helps 
p1896
asS'183994'
p1897
(lp1898
Vunderstanding unix permissions attributes ive never really got chmod worked today followed explained big deal example ive read youve got three different permission groups: owner u group g everyone o based three groups know that: file owned user user permissions determine access group file users group group permission determine access user file owner group permission used ive also learned youve got following permissions: read r write w execute x created directory test newly acquired knowledge: mkdir test tests: chmod urwx test drwx chmod grx test drwxrx chmod ux test drwrx fooling around time think finally got hang chmod way set permission using command still questions: d start stand whats name use containing slot values hold set unset value d 7421 7421 7421 people sometimes use 0777 instead 777 set permissions shouldnt asking multiple questions ill try ask one question unix based system linux distributions concerning permissions first part d stand whats use part permissions would like add new whole unixlinux platform stupid question please excuse asking 
p1899
aVd means directory file link find l cant setunset use 0777 permissions giving full control readwriteexecute every usergroup system lazy way solve problems usersgroups cant access directoriesfiles example list content directory get this: rwrr 1 root root 42596 jun 7 2012 preloadable_libintlso _preloadable_libintlso_ file owned user root group root _owner_ read write access _group_ read access _other user_ read access translated 644 change 777 look like this: rwxrwxrwx 1 root root 42596 jun 7 2012 preloadable_libintlso 
p1900
aVill answer questions three parts: file types permissions use cases various forms chmod file types first character ls l output represents file type d means directory cant set unset depends file created find complete list file types ls documentation informationislistedhtmlwhatinformationislisted youre likely come across : regular file created program write file b: block special file typically disk partition devices created mknod c: character special file also created mknod see dev examples d: directory created mkdir l: symbolic link created ln p: named pipe created mkfifo s: socket created nc u d: door permissions chmod 0777 used set permissions one chmod execution rather combining changes u etc four digits octal value representing set permissions: suid sgid sticky see user permissions group permissions permissions octal value calculated sum permissions: read 4 write 2 execute 1 first digit: suid 4 binaries bit set run owner user commonly root sgid 2 binaries bit set run owner group used games high scores could shared often security risk combined vulnerabilities games files created directories bit set belong directorys owner group default handy creating shared folders sticky restricted deletion 1 files directories bit set deleted owner directorys owner root see tmp common example see chmod manpage details note im ignoring security features alter users permissions files selinux file acls special bits handled differently depending type file regular file directory underlying system mentioned chmod manpage system used test coreutils 823 ext4 filesystem running linux kernel 3167ckt2 behavious follows file special bits always cleared unless explicitly set chmod 0777 equivalent chmod 777 commands clear special bits give everyone full permissions file directory special bits never fully cleared using fourdigit numeric form effect chmod 0777 also equivalent chmod 777 misleading since special bits remain asis previous version answer got wrong clear special bits directories need use us gs andor ot explicitly specify negative numeric value chmod 7000 clear special bits directory ls l output suid sgid sticky appear place x entry: suid instead users x sgid instead groups x sticky instead others x lowercase letter indicates special bit executable bit set uppercase letter indicates special bit set various forms chmod behaviour described using full four digits chmod confusing least turns confused useful want set special bits well permission bits otherwise bits cleared youre manipulating file preserved youre manipulating directory chmod 2750 ensures youll get least sgid exactly urwxgrxo chmod 0750 wont necessarily clear special bits using numeric modes instead text commands ugorwxxst probably case habit aim command youre used using numeric modes often easier specify full mode way useful able think permissions using numeric modes since many commands use install mknod text variants come handy: simply want ensure file executed anyone chmod ax regardless permissions likewise x adds execute permission one execute permissions already set file directory handy restoring permissions globally without specialcase files v directories thus chmod r ugrxuwo equivalent applying chmod r 750 directories executable files chmod r 640 files 
p1901
aVpermissions linux important try make short explanation pieces file mode every unix file set permissions determine whether read write run file running ls l displays permissions here\u2019s example display: rwrr 1 user somegroup 7041 mar 26 19:34 somefile attach image pieces file mode: enter image description type different thing example: d directory c character device l symlink p named pipe socket b block device d door common linux systems ported want set permissions directory use r attribute example: chmod r 777 somedirectory chmod 777 vs 0777 chmod command usually expects input octal number leading zero refers value stickysgidsuid bit triplet c however would make difference since 777 would translated 01411 octal thus setting sticky bit see chmod2 man page read permissions owner executable bit group others rather strange combination edit 1 found picture linux permissions attach understand easy: unix file permissions 
p1902
aVreading: d questions: tells unix file type: default unix 3 types files \u005c regular files d \u005c directory files special filesthis category 5 sub types it: b \u005c block file c \u005c character device file p \u005c named pipe file pipe file l \u005c symbolic link file \u005c socket file read more: 0777 vs 777: sticky bit specified directorys sticky bit set filesystem treats files directories special way files owner directorys owner root user rename delete file without sticky bit set user write execute permissions directory rename delete contained files regardless files owner 0777 sets 777 file permissions stickey bit 0 special modes 777 setting 777 file permissions without changing sticky bit read more: sticky bit chmod 
p1903
aVgetting question answered research outcome found article explains well would like share parts article future references viewing permissions order use chmod change permissions file directory first need know current mode access view contents directory terminal cd directory using: ls l l switch important using ls without display names files folders directory example using ls l home directory: total 128 drwxrxrx 2 peter users 4096 jul 5 21:03 desktop drwxrxrx 6 peter users 4096 jul 5 17:37 documents drwxrxrx 2 peter users 4096 jul 5 13:45 downloads drwxrxrx 2 peter users 4096 jun 24 03:36 movies drwxrxrx 2 peter users 4096 jun 24 03:38 music drwxrxrx 2 peter users 4096 jun 26 00:09 pictures rwrr 1 peter users 354 jul 6 17:15 chmodtest columns mean first column type file: denotes normal file d denotes directory ie folder containing files folders p denotes named pipe aka fifo l denotes symbolic link letters permissions first column interested second one many links file safely ignore third column two valuesnames: first one example peter name user owns file second value users example group owner belongs read groups next column size file directory bytes information dates times file directory last modified course name file directory permissions mean first three letters first d permissions owner next three letters permissions apply group final three letters permissions apply everyone else set three letters made r w x r always first position w always second position x always third position r read permission w write permission x execute permission hyphen place one letters means permission granted letter present granted folders case folders mode bits interpreted follows: r read stands ability read table contents given directory w write stands ability write table contents given directory create new files folders rename delete existing files folders execute bit set otherwise permission meaningless x execute stands ability enter given directory command cd access files folders directory changing permissions using chmod command chmod command linux unixlike operating systems allows change permissions access mode file directory alter permissions two different ways: \u005c textbased chmod \u005c numberbased chmod text method change permissionsor access modeof file use chmod command terminal commands general structure: chmod whopermissions filename range letters signifies going give permission follows: u user file g group file belongs o users ie everyone else use instead type ugo permissions already discussed r w x chmod command lets us add subtract permissions existing set using instead different commands essentially rewrite permissions ie change permission r rw still need include r well w chmod command missed r would take away r permission rewritten using avoid adding taking away current set permissions number method chmod also set permissions using numbers using numbers another method allows edit permissions three owner group others time basic structure code this: chmod xxx filedirectory xxx 3 digit number digit anything 1 7 first digit applies permissions owner second digit applies permissions group third digit applies permissions others number notation values r w x number value: r4 w2 x1 come three digit number need consider permissions want owner group user total values example say wanted grant owner directory read write execution permissions wanted group everyone else read execute permissions would come numerical values like so: owner: rwx 4217 group: rx 4015 415 other: rx 4015 415 final number 755 chmod 755 filename equivalent using following: chmod urwx filename chmod gorx filename foldersdirectories set 755 allow reading writing execution owner deny writing everyone else files normally 644 allow reading writing owner reading everyone else refer last note lack x permissions non executable files deal 
p1904
asS'496448'
p1905
(lp1906
Vcorrectly use extern keyword c question function referenced extern keyword c failing see used practice writing program functions use made available header files included would useful extern get access something exposed header file could thinking extern works incorrectly please correct edit: extern something default declaration without keyword header file 
p1907
aVfunction defined different dll lib compiler defers linker find typical case calling functions os api 
p1908
aVfile program first compiled object file object files linked together need extern tells compiler function exists code somewhere else dont panic 
p1909
aVextern changes linkage keyword function variable assumed available somewhere else resolving deferred linker theres difference extern functions variables: variables doesnt instantiate variable ie doesnt allocate memory needs done somewhere else thus important want import variable somewhere else functions tells compiler linkage extern default use keyword static indicate function bound using extern linkage dont need use explicitly 
p1910
aVfunctions actually _defined_ source files _declared_ headers case use _extern_ _declaring_ prototype header time functions one following like best practice: static normal functions arent visible outside c file static inline inlines c h files extern declaration headers next kind see keyword whatsoever normal functions meant accessed using extern declarations 
p1911
aVdeclarations functions variables header files extern exceptions rule inline functions defined header variables although defined header local translation unit source file header gets included into: static source files extern shouldnt used functions variables defined file prefix local definitions static nothing shared definitions theyll external symbols default reason use extern source file declare functions variables defined source files header file provided declaring function prototypes extern actually unnecessary people dislike waste space function declarations already tendency overflow line limits others like way functions variables treated way 
p1912
aVc extern implied function prototypes prototype declares function defined somewhere else words function prototype external linkage default using extern fine redundant static linkage required function must declared static prototype function header normally c file 
p1913
aValready stated extern keyword redundant functions variables shared across compilation units declare header file extern keyword define single source file without extern keyword single source file one sharing header files name best practice 
p1914
aVextern tells compiler data defined somewhere connected linker help responses talking practical example use extern example 1 show pitfall: file stdioh: int errno stuff mycfile1c: include stdioh code mycfile2c: include stdioh code mycfile1o mycfile2o linked c files separate copies errno problem errno suppose constant linked files example 2 fix file stdioh: extern int errno stuff file stdioc int errno mycfile1c: include stdioh code mycfile2c: include stdioh code mycfile1o mycfile2o linked linker point errno thus solving implementation extern 
p1915
aVgood article came extern keyword along examples: though agree using extern function declarations redundant supposed compiler setting recommend using extern function declarations needed 
p1916
aVmany years later discover question reading every answers comments though could clarify details could useful people get thru goggle search question specifically using extern functions ignore use extern global variables lets define 3 function prototypes filename: my_projecth extern int function_1void static int function_2void int function_3void header file used main source code follow filename: my_projectc include my_projecth void mainvoid int v1 function_1 int v2 function_2 int v3 function_3 int function_2void return 1234 order compile link must define function_2 source code file call function two functions could defined different source code _c may located binary file _obj lib dll may source code lets include header my_projecth different c file understand better difference project add following file filename: my_big_project_splittedc include my_projecth void old_main_testvoid int v1 function_1 int v2 function_2 int v3 function_3 int function_2void return 5678 int function_1void return 12 int function_3void return 34 important features notice: function defined static header file compiler linker must find instance function name module use include file function part c library replaced one module redefining prototype static module example replace call malloc free add memory leak detection feature specifier extern really needed functions static found function always assumed extern however extern default variables normally header file define variables visible across many modules need use extern exception would header file guaranteed included one one module many project manager would require variable placed beginning module inside header file large projects video game emulator mame even require variable appear first function using 
p1917
asS'6074279'
p1918
(lp1919
Vuse fprintf writing data file want write data c program file excel read file plot graph data im sure exact syntax use fprintf stdlibh declared top program declared file fp main im getting file fp undeclared could problem edit: program compiles runs output file doesnt contain data end loop computations fp fopen out_filetxt w open file writing fprintffp x f y f vx f vy f time f xyvxvytime 
p1920
aV include stdioh enough careful structures name file uppercase file finally dont forget close file calling fclose 
p1921
aVstdio file type file uppercase 
p1922
aVlogic look something like this: fp fopen out_filetxt w open file writing condition calculations fprintffp x f y f vx f vy f time f xyvxvytime fclosefp 
p1923
asS'12452018'
p1924
(lp1925
Vfprintf isnt writing file trying use following c code print array passed output text hexadecimal format one line problems opening file first wrote problems working opened output file array changed fileoutname parameter cant get print anything tried changing back things nothing seems work also debug seems like poutfile bad pointer like said still creates file wont write anything help would appreciated thanks printoutputint output char fileoutname int 0 file poutfile poutfile fopen fileoutname w whileoutputi 0 fprintf poutfile 0x04x\u005cn outputi 
p1926
aV output text hexadecimal format one line line fprintf poutfile 0x04x\u005cn 5 always formats number 5 probably fprintf poutfile 0x04x\u005cn outputi 
p1927
aValways clean youre missing fclosepoutfile 
p1928
aVyoure counting element beyond bounds array 0 may case unless youre explicitly setting thats okay usually pass arrays along size safer easier read portable printoutputint output int size char fileoutname int i0 file poutfile poutfile fopen fileoutname w whileisize fprintf poutfile 0x04x\u005cn outputi fclosepoutfile also highly recommend getting used using preincrement operator instead postincrement situations like probably wont make difference large inputs complex types reduce execution time hence instead 
p1929
asS'26188265'
p1930
(lp1931
Vc declare struct definition following source code problem: include stdioh typedef struct foo int bar b foo typedef struct bar int int b bar int mainvoid foo f fa 1 fba 2 fbb 3 printfd d d\u005cn fa fba fbb return 0 want declare bar struct foo struct keep order struct declarations foo struct first cant occurs errorsone error: unknown type name bar compile time 
p1932
aVcompiler needs able determine size foo bar unknown time foo defined compiler determine size foo way around using pointer since pointers size use forward declaration structure reference pointer means foo never automatically allocate memory bar consequence memory allocated separately avoid include stdioh include stdlibh typedef struct bar bar typedef struct foo foo struct foo int bar b struct bar int int b void dynamicvoid foo f fa 1 fb barmallocsizeofbar fba 2 fbb 3 printfd d d\u005cn fa fba fbb freefb void automaticvoid foo f bar b fa 1 fb b fba 2 fbb 3 printfd d d\u005cn fa fba fbb int mainvoid dynamic automatic 
p1933
aVbar struct declaration precede foo struct declaration case want use pointers allocate memory c another struct member struct struct declared compiler see 
p1934
aVtada define bar struct int int b typedef struct foo int bar b foo undef bar typedef struct bar int int b bar int mainvoid foo f fa 1 fba 2 fbb 3 printfd d d\u005cn fa fba fbb return 0 please dont 
p1935
asS'6087581'
p1936
(lp1937
Vauto keyword used storage class specifier c11  auto keyword used storage class specifier c11 following code legal c11 int main auto int x 
p1938
aVcode illformed c11 auto c11 would used deduce type variable initializer cant used storage class specifier correct usage int main auto x 12 x int auto y 123 y double 
p1939
aV auto int x circular literally declaring type int given information reason simply use: int x wanted declare x type another variable scope use decltype using sometype float sometype y decltypey x 
p1940
asS'5727'
p1941
(lp1942
Vbarriers understanding pointers done overcome pointers leading factor confusion many new even old college level students c c tools thought processes helped understand pointers work variable function beyond level good practice things done bring somebody level ahhah got without getting bogged overall concept basically drill like scenarios 
p1943
aV pointers leading factor confusion many new even old college level students cc language concept placeholder value variables maps onto something taught school algebra isnt existing parallel draw without understanding memory physically laid within computer one thinks kind thing theyre dealing low level things ccbyte communications level tools thought processes helped understand pointers work variable function beyond level addresses boxes remember learning program basic microcomputers pretty books games sometimes poke values particular addresses picture bunch boxes incrementally labelled 0 1 2 explained one small thing byte could fit boxes lot computers many 65535 next address good practice things done bring somebody level ahhah got without getting bogged overall concept basically drill like scenarios drill make struct: struct char char b char c char d mystruct mystructa r mystructb mystructc mystructd u char my_pointer my_pointer mystructb cout start: my_pointer my_pointer endl my_pointer cout after: my_pointer my_pointer endl my_pointer mystructa cout then: my_pointer my_pointer endl my_pointer my_pointer 3 cout end: my_pointer my_pointer endl example except c: example except c: struct char char b char c char d mystruct mystructa r mystructb mystructc mystructd u char my_pointer my_pointer mystructb printfstart: my_pointer c\u005cn my_pointer my_pointer printfafter: my_pointer c\u005cn my_pointer my_pointer mystructa printfthen: my_pointer c\u005cn my_pointer my_pointer my_pointer 3 printfend: my_pointer c\u005cn my_pointer output: start: my_pointer after: my_pointer then: my_pointer r end: my_pointer u perhaps explains basics example 
p1944
aVdont think pointers concept particularly tricky students mental models map something like quick box sketches help difficulty least ive experienced past seen others deal management pointers cc unncessarily convoluted 
p1945
aVdont see confusing pointers point location memory stores memory address cc specify type pointer points example: int my_int_pointer says my_int_pointer contains address location contains int problem pointers point location memory easy trail location proof look numerous security holes cc applications buffer overflow incrementing pointer past allocated boundary 
p1946
aVreason pointers seem confuse many people mostly come little background computer architecture since many dont seem idea computers machine actually implemented working cc seems alien drill ask implement simple bytecode based virtual machine language chose python works great instruction set focussed pointer operations load store directindirect addressing ask write simple programs instruction set anything requiring slightly simple addition going involve pointers sure get 
p1947
aVthink main reason people trouble generally taught interesting engaging manner id like see lecturer get 10 volunteers crowd give 1 meter ruler get stand around certain configuration use rulers point show pointer arithmetic moving people around point rulers itd simple effective memorable way showing concepts without getting bogged mechanics get c c seems get harder people im sure finally putting theory dont properly grasp practice pointer manipulation inherently harder languages cant remember transition well knew pointers pascal moved c got totally lost 
p1948
aVpointers concept many confusing first particular comes copying pointer values around still referencing memory block ive found best analogy consider pointer piece paper house address memory block references actual house sorts operations thus easily explained ive added delphi code comments appropriate chose delphi since main programming language c exhibit things like memory leaks way wish learn highlevel concept pointers ignore parts labelled memory layout explanation intended give examples memory could look like operations lowlevel nature however order accurately explain buffer overruns really work important added diagrams _disclaimer: intents purposes explanation example memory layouts vastly simplified theres overhead lot details would need know need deal memory lowlevel basis however intents explaining memory pointers accurate enough_ lets assume thouse class used looks like this: type thouse class private fname : array09 char public constructor createname: pchar end initialize house object name given constructor copied private field fname reason defined fixedsize array memory overhead associated house allocation ill illustrate like this: ttttnnnnnnnnnn fname array overhead tttt area overhead typically various types runtimes languages like 8 12 bytes imperative whatever values stored area never gets changed anything memory allocator core system routines risk crashing program allocate memory get entrepreneur build house give address house contrast real world memory allocation cannot told allocate find suitable spot enough room report back address allocated memory words entrepreneur choose spot thousecreatemy house memory layout: ttttnnnnnnnnnn 1234my house keep variable address write address new house piece paper paper serve reference house without piece paper youre lost cannot find house unless youre already var h: thouse begin h : thousecreatemy house memory layout: h v ttttnnnnnnnnnn 1234my house copy pointer value write address new piece paper two pieces paper get house two separate houses attempts follow address one paper rearrange furniture house make seem _the house_ modified manner unless explicitly detect actually one house _note_ usually concept problem explaining people two pointers mean two objects memory blocks var h1 h2: thouse begin h1 : thousecreatemy house h2 : h1 copies address house h1 v ttttnnnnnnnnnn 1234my house h2 freeing memory demolish house later reuse paper new address wish clear forget address house longer exists var h: thouse begin h : thousecreatemy house hfree h : nil first construct house get hold address something house use code left exercise reader free lastly clear address variable memory layout: h v free ttttnnnnnnnnnn 1234my house h points nowhere free note memory might still xx34my house contain data dangling pointers tell entrepreneur destroy house forget erase address piece paper later look piece paper youve forgotten house longer goes visit failed results see also part invalid reference var h: thouse begin h : thousecreatemy house hfree forgot clear h hopenfrontdoor likely fail using h call free _might_ work pure luck likely fail customers place middle critical operation h v free ttttnnnnnnnnnn 1234my house h v free xx34my house see h still points remnants data memory since might complete using might fail memory leak lose piece paper cannot find house house still standing somewhere though later want construct new house cannot reuse spot var h: thouse begin h : thousecreatemy house h : thousecreatemy house uhoh happened first house hfree h : nil overwrote contents h variable address new house old one still standing somewhere code way reach house left standing words allocated memory stay allocated application closes point operating system tear memory layout first allocation: h v ttttnnnnnnnnnn 1234my house memory layout second allocation: h v ttttnnnnnnnnnnttttnnnnnnnnnn 1234my house 5678my house common way get method forget free something instead overwriting delphi terms occur following method: procedure openthefrontdoorofanewhouse var h: thouse begin h : thousecreatemy house hopenfrontdoor uhoh free address go end method executed theres place variables address house exists house still memory layout: h v losing pointer ttttnnnnnnnnnn 1234my house h points nowhere losing pointer ttttnnnnnnnnnn 1234my house see old data left intact memory reused memory allocator allocator keeps track areas memory used reuse unless free freeing memory keeping invalid reference demolish house erase one pieces paper also another piece paper old address go address wont find house might find something resembles ruins one perhaps even find house house originally given address thus attempts use though belongs might fail horribly sometimes might even find neighbouring address rather big house set occupies three address main street 13 address goes middle house attempts treat part large 3address house single small house might also fail horribly var h1 h2: thouse begin h1 : thousecreatemy house h2 : h1 copies address house h1free h1 : nil h2openfrontdoor uhoh happened house house torn reference h1 h1 cleared well h2 still old outofdate address access house longer standing might might work variation dangling pointer see memory layout buffer overrun move stuff house possibly fit spilling neighbours house yard owner neighbouring house later comes home hell find sorts things hell consider reason chose fixedsize array set stage assume second house allocate reason placed first one memory words second house lower address first one also theyre allocated right next thus code: var h1 h2: thouse begin h1 : thousecreatemy house h2 : thousecreatemy house somewhere longer 10 characters 0123456789 10 characters memory layout first allocation: h1 v ttttnnnnnnnnnn 5678my house memory layout second allocation: h2 h1 v v ttttnnnnnnnnnnttttnnnnnnnnnn 1234my house somewhereouse overwritten part often cause crash overwrite important parts data stored really randomly changed instance might problem parts name h1house changed terms crashing program overwriting overhead object likely crash try use broken object overwriting links stored objects object linked lists follow address piece paper get house house another piece paper new address next house chain var h1 h2: thouse begin h1 : thousecreatehome h2 : thousecreatecabin h1nexthouse : h2 create link home house cabin follow chain house nexthouse reference means last one visit houses could use following code: var h1 h2: thouse h: thouse begin h1 : thousecreatehome h2 : thousecreatecabin h1nexthouse : h2 h : h1 h nil begin hlockalldoors hcloseallwindows h : hnexthouse end memory layout added nexthouse link object noted four lllls diagram: h1 h2 v v ttttnnnnnnnnnnllllttttnnnnnnnnnnllll 1234home 5678cabin link basic terms memory address memory address basic terms number think memory big array bytes first byte address 0 next one address 1 upwards simplified good enough memory layout: h1 h2 v v ttttnnnnnnnnnnttttnnnnnnnnnn 1234my house 5678my house might two address leftmost address 0: h1 4 h2 23 means linked list might actuall look like this: h1 4 h2 28 v v ttttnnnnnnnnnnllllttttnnnnnnnnnnllll 1234home 0028 5678cabin 0000 link typical store address points nowhere zeroaddress basic terms pointer pointer variable holding memory address typically ask programming language give number programming languages runtimes tries hide fact number beneath number really hold meaning best think pointer black box ie dont really know care actually implemented long works 
p1949
aVexample good set diagrams helps greatly understanding pointers joel spolsky makes good points understanding pointers guerrilla guide interviewing article: reason people seem born without part brain understands pointers aptitude thing skill thing \u2013 requires complex form doublyindirected thinking people cant 
p1950
aVfirst comp sci class following exercise granted lecture hall roughly 200 students professor writes board: int john john stands professor writes: int sally john sally stands points john professor: int bill sally bill stands points john professor: int sam sam stands professor: bill sam bill points sam think get idea think spent hour went basics pointer assignment 
p1951
aVcomplexities pointers go beyond easily teach students point using pieces paper house addresses great learning tools great job introducing basic concepts indeed learning basic concepts _vital_ successfully using pointers however production code common get much complex scenarios simple demonstrations encapsulate ive involved systems structures pointing structures pointing structures structures also contained embedded structures rather pointers additional structures pointers get really confusing youve got multiple levels indirection start ending code like this: widgetwazzlefizzle fazzlefoozlewazzle get confusing really quickly imagine lot lines potentially levels throw arrays pointers node node pointers trees linked lists gets worse still ive seen really good developers get lost started working systems even developers understood basics really well complex structures pointers dont necessarily indicate poor coding either though composition vital piece good objectoriented programming languages raw pointers inevitably lead multilayered indirection systems often need use thirdparty libraries structures dont match style technique situations like complexity naturally going arise though certainly fight much possible think best thing colleges help students learn pointers use good demonstrations combined projects require pointer use one difficult project pointer understanding thousand demonstrations demonstrations get shallow understanding deeply grasp pointers really use 
p1952
aVdont think pointers confusing people understand concept many pointers think many levels indirection comfortable doesnt take many put people edge fact changed accidently bugs program also make difficult debug things go wrong code 
p1953
aVfound ted jensens pointers arrays c excellent resource learning pointers divided 10 lessons beginning explanation pointers theyre finishing function pointers moving beejs guide network programming teaches unix sockets api begin really fun things 
p1954
aVlike house address analogy ive always thought address mailbox way visualize concept dereferencing pointer opening mailbox instance following linked list: 1 start paper address 2 go address paper 3 open mailbox find new piece paper next address linear linked list last mailbox nothing end list circular linked list last mailbox address first mailbox note step 3 dereference occurs youll crash go wrong address invalid assuming could walk mailbox invalid address imagine theres black hole something turns world inside : 
p1955
aVanalogy ive found helpful explaining pointers hyperlinks people understand link web page points another page internet copy amp paste hyperlink point original web page go edit original page follow either links pointers youll get new updated page 
p1956
aVconfuse things bit sometimes work handles instead pointers handles pointers pointers back end move things memory defragment heap pointer changes midroutine results unpredictable first lock handle make sure nothing goes anywhere bit coherently : 
p1957
aVthink makes pointers tricky learn pointers youre comfortable idea memory location set bits represent int double character whatever first see pointer dont really get whats memory location mean holds _address_ dont agree notion either get dont become easier understand start finding real uses like passing large structures functions 
p1958
aVpost office box number piece information allows access something else arithmetic post office box numbers may problem letter goes wrong box somebody moves another state forwarding address dangling pointer hand post office forwards mail pointer pointer 
p1959
aVproblem pointers concept execution language involved additional confusion results teachers assume concept pointers thats difficult jargon convoluted mess c c makes concept vast amounts effort poored explaining concept like accepted answer question pretty much wasted someone like already understand explaining wrong part problem give idea im coming im someone understands pointers perfectly well use competently assembler language assembler language referred pointers referred addresses comes programming using pointers c make lot mistakes get really confused still sorted let give example api says: int doitchar buffer buffer pointer buffer want could want: number representing address buffer give say doitmybuffer doitmybuffer number representing address address buffer doitmybuffer doitmybuffer doitmybuffer number representing address address address buffer maybe thats doitmybuffer doitmybuffer even doitmybuffer language involved doesnt make clear involves words pointer reference dont hold much meaning clarity x holds address y function requires address y answer additionally depends heck mybuffer begin doit intends language doesnt support levels nesting encountered practice like hand pointer function creates new buffer modifies pointer point new location buffer really want pointer pointer pointer knows go modify contents pointer time guess meant pointer time im wrong regardless much experience get guessing pointer overloaded pointer address value variable holds address value function wants pointer want address pointer variable holds want address pointer variable im confused 
p1960
aVthink might actually syntax issue cc syntax pointers seems inconsistent complex needs ironically thing actually helped understand pointers encountering concept iterator c standard template library assume iterators conceived generalization pointer sometimes cant see forest learn ignore trees 
p1961
aVbad way grasp via iterators keep looking youll see alexandrescu start complaining many exc devs never understood iterators modern pointer dumping language jump c still believe decent iterators hmm problem iterators complete odds runtime platforms javaclr trying achieve: new simple everyone isadev usage good said purple book said even c: indirection powerful concept never way iterators useful help abstraction algorithms another example compiletime place algorithm simple know code data language c: ienumerable linq massive framework 300mb runtime penalty indirection lousy dragging apps via heaps instances reference types le pointer cheap 
p1962
aVreason hard understand difficult concept syntax inconsistent int mypointer first learned leftmost part variable creation defines type variable pointer declaration work like c c instead say variable pointing type left case: _mypointer pointing int_ didnt fully grasp pointers tried using c unsafe work exact way logical consistent syntax pointer type _mypointer pointer int_ int mypointer dont even get started function pointers 
p1963
aVcould work pointers knew c kind knew cases trialerror thing gave complete understanding assembly language serious instruction level debugging assembly language program youve written able understand lot things 
p1964
aVconfusion comes multiple abstraction layers mixed together pointer concept programmers dont get confused ordinary references javapython pointers different expose characteristics underlying memoryarchitecture good principle cleanly separate layers abstraction pointers 
p1965
aVreason hard time understanding pointers first many explanations include lot crap passing reference confuse issue use pointer parameter youre _still_ passing value value happens address rather say int someone else already linked highlight moment began understand pointers: pointers arrays c: chapter 3 pointers strings int putsconst char moment ignore const parameter passed puts pointer value pointer since parameters c passed value value pointer address points simply address thus write putsstra seen passing address stra0 moment read words clouds parted beam sunlight enveloped pointer understanding even youre vb net c developer never use unsafe code still worth understanding pointers work wont understand object references work youll commonbutmistaken notion passing object reference method copies object 
p1966
aVthink main barrier understanding pointers bad teachers almost everyone taught lies pointers: _nothing memory addresses_ allow point _arbitrary locations_ course difficult understand dangerous semi magical none true pointers actually fairly simple concepts _as long stick c language say them_ dont imbue attributes usually turn work practice nevertheless arent guaranteed language arent part actual concept pointer tried write explanation months ago blog post itll help someone note anyone gets pedantic yes c standard say pointers _represent_ memory addresses say pointers memory addresses nothing memory addresses may used thought interchangeably memory addresses distinction important 
p1967
aVevery cc beginner problem problem occurs pointers hard learn explained learners gather verbally visually best way explaining use train example suits verbal visual example locomotive pointer hold anything wagon locomotive tries pull point classify wagon hold animalsplants people mix 
p1968
aVthought id add analogy list found helpful explaining pointers back day computer science tutor first lets: set stage: consider parking lot 3 spaces spaces numbered: 1 2 3 way like memory locations sequential contiguous sort like array right cars like empty array parking_lot3 0 add data parking lot never stays empty long would pointless one would build lets say day moves lot fills 3 cars blue car red car green car: 1 2 3 oo oo oo b r g oo oo oo cars type car one way think cars sort data say int different values blue red green could color enum enter pointer take parking lot ask find blue car extend one finger use point blue car spot 1 like taking pointer assigning memory address int finger parking_lot finger pointer answer question looking _at_ finger tells nothing look youre finger _pointing to_ dereferencing pointer find car data looking reassigning pointer ask find red car instead redirect finger new car pointer one showing new data parking spot red car found type car pointer hasnt physically changed still _your_ finger data showing changed parking spot address double pointers pointer pointer works one pointer well ask pointer pointing red car use hand point finger first finger like int finger_two finger want know blue car follow first fingers direction second finger car data dangling pointer lets say youre feeling much like statue want hold hand pointing red car indefinitely red car drives away 1 2 3 oo oo b g oo oo pointer still pointing red car _was_ longer lets say new car pulls orange car ask red car youre still pointing youre wrong thats red car thats orange pointer arithmetic ok youre still pointing second parking spot occupied orange car 1 2 3 oo oo oo b o g oo oo oo well new question want know color car _next_ parking spot see youre pointing spot 2 add 1 youre pointing next spot finger1 since wanted know data check spot finger deference pointer finger1 see green car present data location 
p1969
aVanswers asserted pointers arent really hard havent gone address directly pointer hard comes years back tutored first year cs students one year since clearly sucked clear idea pointer hard whats hard understanding would want pointer dont think divorce question use pointer explaining broader software engineering issues every variable _not_ global variable one factor similar code functions get use _pointers_ specialize behaviour call site 
p1970
aVway liked explain terms arrays indexes people might familiar pointers generally know index say imagine ram array 10bytes ram: unsigned char ram10 10 14 4 3 2 1 20 19 50 9 pointer variable really index first byte variable ram pointerindex unsigned char index 2 value obviously third element number 4 pointer pointer take number use index like ramramindex would draw array list paper use show things like many pointers pointing memory pointer arithmetic pointer pointer 
p1971
asS'9290819'
p1972
(lp1973
Vexecuting c program linux terminal compiled program ububtu 1010 terminal gcc file_namec o new_file command compiled successfully creating executable file named new_file trying execute command new_file says permission denied new_file ive checked permission properties file found ive permission read amp write im user system please help figure problem 
p1974
aVgive exe permissions so: chmod x new_file create new file gcc default isnt executable gave permissions execution chmod see file specific case gave execution permissions plus means gave x means execution file want revoke permission type: chmod x filename 
p1975
aVcompiling file placed aout try use aout 
p1976
asS'38280895'
p1977
(lp1978
Vunderstanding extern storage class specifier c consider given c codes : includestdioh extern int int main printfd return 0 gives compilation error initialize extern int i10 output 10 includestdioh extern int i10 initialization statement int main printfd return 0 also assign int i10then output 10 includestdioh extern int int i10 assignment int main printfd return 0 includestdioh extern int int main int i10 assignment printfd return 0 variation : includestdioh extern int int i20 int main int i10 printfd return 0 since int local variable output 10 please explain important point extern storage class c read somewhere declaration declares name type variable function definition causes storage allocated variable body function defined variable function may many declaration one defition variable function 
p1979
aVextern int declaration tells compiler somewhere another source exists actual declaration global scope actual declaration therefore inappropriate assign value declaration second try invalid first attempt invalid since dont actual declaration third ok though actual declaration wouldnt extern int declaration last samples involves local global scope case variable local scope used thats dont get 20 printed 
p1980
aVextern storage class specifier used give reference global variable visible program files use extern variable cannot initialized however points variable name storage location previously defined 
p1981
aVconsider int declared outside functions programme including main means file scope static storage duration space allocated important consider extern int declared outside functions programme including main means file scope static storage duration declared defined means space allocated assumed defined somewhere else may include file consider extern int i10 declared outside functions programme including main case youre initializing extern variable case space allocated initialized 10 keyword extern neglected means declared note extern int mandatory variable defined somewhere else ie another source file case compiletime error 
p1982
aVcode references symbol via extern modifier means symbol actually defined elsewhere rather current file exception extern modififier used symbol actually defined current file ok 
p1983
asS'30826065'
p1984
(lp1985
Vcant always use register storage class c read book whenever declare variable storage class register would stored register subject availability register available default storage type auto would assigned whenever declare variable without explicitly mentioning storage class default storage type assigned auto question declare every variable register storage class register available anyways treated default auto class luckily registers available would stored one understand cannot use amp operator longer im going work pointers addresses declare variables register storage class seems bad practise edit: searched web unavailability address point mentioned cant rest variables declared register mentioned 
p1986
aVcannot make variables register c c language specifications explicitly forbids taking address register variable however register qualifier role todays optimizing compilers gcc compilers happily freely use machine register variables qualified register even keep memory machine register variable qualified register essentially compiler _ignoring_ register qualifier except forbid taking address complex register allocation algorithms heuristics given variable might stay machine register parts function code put memory parts optimization point view current compilers handle auto register qualified variables way hence register qualifier useless except forbid addressof operator notice also cpu cache much important processor registers want handtune c code performance often bad idea since compiler better better take care caching issues see afaik future versions c c languages would officially deprecate register qualifier auto qualifier could happen future language specifications would reuse keyword purposes c11 reused auto using register source code probably mistake since might make code harder port future versions c c 
p1987
aVregister keyword hint compiler _you_ think variable handled quicker others possible side effect taking address variable allowed register arrays undefined behaviour modern compiler use registers anyway much possible keyword needed anymore compiler also clever you: use register variable x one part variable y another part program use registers two five fields struct things cannot even express register keyword case using register may completely pointless variable looks like used much less others know better even big may 
p1988
asS'5678216'
p1989
(lp1990
Vpossible c array initialization syntaxes possible array init syntaxes possible c gets really confusing know array initializer separate declaration note: ive searched msdn googled isnt allinone guide im using net 35 c 
p1991
aVcurrent declaration initialization methods simple array string array new string2 creates array length 2 default values string array new string b creates populated array length 2 string array b creates populated array length 2 note techniques obtaining arrays exist linq toarray extensions ienumerablet also note declarations first two could replace string left var c 3 information right enough infer proper type third line must written displayed array initialization syntax alone enough satisfy compilers demands youre whole brevity thing could written var array new string2 creates array length 2 default values var array new string b creates populated array length 2 string array b creates populated array length 2 
p1992
aVarray creation syntaxes c _expressions_ are: new int3 new int3 10 20 30 new int 10 20 30 new 10 20 30 first one size may nonnegative integral value array elements initialized default values second one size must constant number elements given must match must implicit conversion given elements given array element type third one elements must implicitly convertible element type size determined number elements given fourth one type array element inferred computing best type one given elements types elements must implicitly convertible type size determined number elements given syntax introduced c 30 also syntax may used declaration: int x 10 20 30 elements must implicitly convertible element type size determined number elements given isnt allinone guide refer c 40 specification section 76104 array creation expressions 
p1993
aV int array new int4 array0 10 array1 20 array2 30 string week new string sundaymondaytuesday string array sunday monday multi dimensional array dim j integer dim strarr1 2 string strarr0 0 first 00 strarr0 1 second 01 strarr1 0 third 10 strarr1 1 fourth 11 
p1994
aV enumerablerepeatstringempty counttoarray create array empty strings repeated count times case want initialize array yet special default element value careful reference types elements refer object 
p1995
aV nonempty arrays var data0 new int3 var data1 new int3 1 2 3 var data2 new int 1 2 3 var data3 new 1 2 3 var data4 1 2 3 compilable use int data5 1 2 3 instead empty arrays var data6 new int0 var data7 new int var data8 new int data9 new compilable var data10 compilable use int data11 instead argument method expressions assigned var keyword passed arguments foonew int2 foonew int2 1 2 foonew int 1 2 foonew 1 2 foo 1 2 compilable foonew int0 foonew int foo compilable 
p1996
aV var contacts new new name eugene zabokritski phonenumbers new 2065550108 4255550001 new name hanying feng phonenumbers new 6505550199 
p1997
aVcase want initialize fixed array preinitialized equal nonnull default elements use this: var array enumerable repeatstringempty 37 toarray also please take part discussion 
p1998
aVrepeat without linq float floats systemarrayconvertallnew float16 v 10f 
p1999
aV example create array custom class class definition public class dummyuser public string email get set public string language get set initialize array: private dummyuser arrdummyuser new dummyuser new dummyuser email abcxyz@emailcom language english new dummyuser email def@emailcom language spanish 
p2000
aValso create dynamic arrays ie first ask size array user creating consolewriteenter size array int n converttoint16consolereadline int dynamicsizedarray new intn created array size n consolewritelineinput elements forint i0ini dynamicsizedarrayi converttoint32consolereadline consolewritelineelements array : foreach int dynamicsizedarray consolewritelinei consolereadkey 
p2001
asS'39967416'
p2002
(lp2003
Vaccessing nested structures im trouble accessing checkups struct contained within dog since dog contained within contained assumed would point checkups dog container seems causing error trying add checkup date replace one used create linked list containers contaning dog struct container struct dog dog struct container next list null used hold dog information linked list checkups struct dog char name30 char breed30 struct checkup checkups used create linked list checkups containing dates struct checkup char date30 struct checkup next code try add new date checkups tried add program crashes direction would occurring would greatly appreciated void add_checkupchar name char date struct container templist list struct checkup tempcheck struct checkup mallocsizeofstruct checkup templist null strcmptemplistdogname name 0 strcpytempcheckdate date strcpytemplistdogcheckups tempcheck templistnext 
p2004
aVusing strcpy set value struct checkup attempts copy data _pointed to_ source pointer array assumed pointed destination pointer fact see particular reason suppose destination pointer even valid certainly theres reason suppose source data form nullterminated array char original code badly wrong simple assignment likely correct: templistdogcheckups tempcheck note however presents serious risk memory leakage previous value templistdogcheckups lost note also doesnt match behavior implied _add__ part function name like set_ want able maintain one checkup per dog would need work 
p2005
asS'3898021'
p2006
(lp2007
Vregarding mainint argc char argv  possible duplicates: arguments main mainfor int argc char argv mean argvmean every program starting mainint argc char argv definition dont understand means would glad somebody could explain use arguments dont use program just: int main name program one elements argv argc count number arguments argv arguments sent argv send 
p2008
aVargc number command line arguments argv array strings representing command line arguments gives option react arguments passed program expecting none might well use int main 
p2009
aVargc argument count argv argument vector get number values passed arguments application launched way use parameters version application started act different way also use int mainvoid prototype c third less known nonstandard prototype third argument envp contains environment variables resources: wikipedia main function c c 
p2010
aVargc means number argument passed program char argv passed arguments argv0 always program name im 100 sure think int main valid cc 
p2011
aVpassing arguments program example command line program invoked gcc mysortc o mysort mysort 2 8 9 1 4 5 program mysort executed command line parameters inside main int argc char argv would result argument count argc 7 since 7 arguments counting program argument vector argv mysort 2 8 9 1 4 5 following complete example cat mysortc include stdioh int main int argc char argv printf argc d\u005cn argc int 0 argc printf argv d s\u005cn argv gcc mysortc o mysort mysort 2 8 9 1 4 5 argc 7 argv 0 mysort argv 1 2 argv 2 8 argv 3 9 argv 4 1 argv 5 4 argv 6 5 char strings 2 8 etc converted number using character number conversion function eg atol link 
p2012
aVargc number command line arguments given program runtime argv array arrays characters rather array cstrings containing arguments know youre going need command line arguments declare main taking void argument instead: int mainvoid two prototypes defined main per standards compilers allow return type void well wikipedia 
p2013
aVrun application parameters app something somethingelse int argc represents number parameters char argv array actual parameters passed application way work inside application 
p2014
aVcomplangc faq whats correct declaration main question 1112a 
p2015
aVarguments argc argv main used way send arguments program possibly familiar way use good ol terminal user could type cat file word cat program takes file outputs standard output stdout program receives number arguments argc vector arguments argv argument count would two program name counts first argument argument vector would contain catfile_null_ last element null pointer commonly would write like this: int specifies type variable function returns main must return integer main int argc char argv code return 0 indicates everything went well program require arguments equally valid write mainfunction following fashion: int main code return 0 zero indicates success nonzero value indicates failureerror early versions c language int main implied today considered error posixcompliant systems windows exists possibility use third parameter char envp contains vector programs environment variables variations argument list main function exists detail since nonstandard also naming variables _convention_ actual meaning always good idea adhere confuse others would equally valid define main int mainint c char v char e code return 0 second question several ways send arguments program would recommend look execfamily functions probably easier use system use system usually frowned upon guaranteed work every system tested bashzsh shell installed nixsystem system fail 
p2016
asS'27437327'
p2017
(lp2018
Vvariable behavioiur switch case  includestdioh int main int i9 switchi static int i1 i3 iii case 3: ii11 case 4: ii22 case 5: ii33 default: ii44 printfdi printfdi doesnt understand actual behavioiur output 45 9 could one give valid reason 1 works 2 thanks advance 
p2019
aVstatements case: executed inside switch except variable declaration includestdioh int main int i9 switchi static int i1 printfi d\u005cn i3 iii case 3: ii11 case 4: ii22 case 5: ii33 default: ii44 printfdi printfdi output would print string switch similar writing switchi static int i1 case 3: ii11 case 4: ii22 case 5: ii33 default: ii44 printfdi since value 9 default case executed prints 45 also scope variable declared inside switch limited inside switch block control comes scope value 9 declared block main 
p2020
aVtwo one visible block makes switch body outside switchi switches outer one initialized 9 goes default: case runs following code default:: default: ii44 printfdi using declared inside switch block one initialized 1 prints 45 doesnt affect outside switch though switch blocks closing brace second printf: printfdi uses outside switch one initialized 9 prints 9 essentially switch body block variable declared block local block hide another variable name outer scope 
p2021
aVswitch statement works follows: 1 switch statement evaluates expression parentheses case value 9 jumps appropriate case case default since case 9 exists 2 variables first case declared case new variable named declared value 1 _note shares name previously declared separate variables new variable overrides previous end switch statement_ since jump directly default label none code label run 3 code runs either encounters break end switch statement variables declared inside switch statement disappear case old variable accessible default label program adds 44 new variable previously 1 adds 44 giving new value 45 prints value switch statement however new variable unloaded old variable becomes accessible still old value 9 value printed 
p2022
asS'16414622'
p2023
(lp2024
Varray initialization c meaning initialization: char arr10 0 im familiar char arr10 0 sets elements zero char arr10 12 sets first two elements 1 2 ascii rest 0 im familiar format quick test showed probably like char arr10 0 meaning im aware 
p2025
aVyes equivalent version without trailing comma see question trailingcommainprogramminglanguagegrammars discussion trailing commas 
p2026
aVchar arr10 0 char arr10 0 case char arr10 5 different 5 stored a0 remaining filled zero suggest use global variables increase data section size 
p2027
aVinitialize array c initialize members value: int myarray10 5 5 5 5 5 5 5 5 5 5 elements missing values initialized 0: int myarray10 1 2 initialize 12000 initialize elements 0: int myarray10 0 elements 0 c empty initialization list also initialize every element 0: int myarray10 elements 0 c objects static storage duration initialize 0 initializer specified: static int myarray10 elements 0 compiler gcc use following syntax: int array1024 0 1023 5 int a10 0 4 5 5 9 3 
p2028
aVstandard trailing comma may appear last expression array initializer ignored 
p2029
aVdifference int arr3 0 int arr3 0 ref: c11 679: initializer: assignmentexpression initializerlist initializerlist forms initializer lists considered initializers form comma end preferred many makes easier rearrange add elements list code maintenance int arr3 0 declares array three elements initializes first element 0 partial initialization rest array automatically initialized zeros ref c11 679: fewer initializers braceenclosed list elements members aggregate fewer characters string literal used initialize array known size elements array remainder aggregate shall initialized implicitly objects static storage duration wrote answer another question closed liked answer though im reposting original question 
p2030
asS'4901765'
p2031
(lp2032
Vcout stands  possible duplicate: c mean cout cin cerr clog coutcincerrandclog someone please explain cout stands 
p2033
aVcout standard output stream print strings numbers using operator: include iostreamh int mainint char cout world endl return 0 
p2034
aVc stands console default systems standard output set console text messages shown although generally redirected also stand character stands output thus console output character output 
p2035
aVill hazard guess channel 
p2036
asS'19813949'
p2037
(lp2038
Vread line file c want read lines file linebyline working tried do: file file char line null int len 0 char read filefopenargv1 r file null return 1 read getlineline len file 1 printfretrieved line length :\u005cn read printfs line line freeline return 0 suggestions isnt working 
p2039
aVsecond argument getline wrong size_t youre passing int received compiler warnings problem make it: size_t len call: getlineline len file also return value type ssize_t char really read manual page getline writing code use function 
p2040
aVget work correctly theres changes change int len size_t len correct type getline syntax incorrect be: read getlineline len file 1 printf line also modified print number returned instead char string interpretation: printfretrieved line length d:\u005cn read 
p2041
aValternatively also use code read whole file line line print lines char buf1000 ptr_file fopeninput3txtr ptr_file return 1 fgetsbuf1000 ptr_filenull printfsbuf 
p2042
asS'1787875'
p2043
(lp2044
Vuse extern storage class specifier c following example usage extern specifer behave global variable int x files onec twoc want use threec declared variable threec extern int x would happen compile link files answer is: compilation files succeed however linker flag error linking due multiple declarations x would difference behavior c way refer int x threec simultaneously files c c c guess use namespaces acheive right 
p2045
aVavoid generating duplicate symbols declare extern int x single header file h file c files use x include header file define initialize int x _one_ c files 
p2046
aVmight interested answers question inc99andlinking summary: linker may may fail link file depends initialization variable definitely fail variable different initializations different files 
p2047
aVdefault global variables _external linkage_ means used source files translation units instead declare global variables static keyword _internal linkage_ meaning usable source files variables external linkage cant multiple variables name linker complain two variables name though long least one internal linkage course cant reference source file extern declaration saying compiler name variable external linkage defined another translation unit allowing refer variable c exactly except addition namespaces global variables put inside namespace name without linker errors provided different namespaces course references variables either refer full name namespace::var_name use using declaration establish local namespace context c also anonymous namespaces entirely equivalent using static keyword global variables c: variables functions declared inside anonymous namespace internal linkage answer original question right compilation would succeed linking would fail due multiple definitions variable x external linkage specifically translation units onec twoc threec way refer simultaneously variables x youll need rename x one modules switch c put least one x inside namespace 
p2048
aVc could this: onec static int x int one_x x twoc static int x int two_x x threec extern int one_x extern int two_x refer unambiguously x file onec x file twoc file threec however might bit effort worth perhaps coming descriptive names global variables instead toying around theoretical ways circumvent cs single global namespace 
p2049
aVremember extern global static variable 
p2050
asS'14027317'
p2051
(lp2052
Vdifference file scope program scope variable declared globally said program scope variable declared globally static keyword said file scope example: int x 0 program scope static int y 0 file scope static float z 00 file scope int main int block scope return 0 difference two 
p2053
aVc programs written several files combined linker final execution entire program one file difference realworld complex software includes use libraries functions distinct files difference significant 
p2054
aVvariables declared static cannot directly accessed files contrary nonstatic ones accessed files declared extern files example: fooc int foodata static int foodata_private void foo foodata 1 foodata_private 2 fooh void foo mainc include fooh include stdioh int main extern int foodata ok extern int foodata_private error wont compile foo printfd\u005cn foodata ok return 0 generally one avoid global variables however realworld applications often useful common move extern int foo declarations shared header file fooh example 
p2055
aVvariable file scope visible declaration point end file file refers program file contains source code one program files within large program variables program scope visible within files file defined functions blocks entire program info check : scope storage classes c 
p2056
aVc99 theres nothing called program scope example variable x file scope terminates end translation unit variables y z declared static also file scope internal linkage c99 6223 declaration file scope identifier object function contains storage class specifier static identifier internal linkage also variable x external linkage means name x accessible translation units throughout program c99 6225 declaration identifier object file scope storageclass specifier linkage external 
p2057
asS'23359693'
p2058
(lp2059
Vputchar works putchar works c programming loop forputcharcputcharaputcharr putchart output: catratratratrat one explain loop works whats functionality putchar thanks 
p2060
aVputchar described standard: writes character standard output stdout success character written returned happen loop pseudocode for99 97 114 printfc enter loop header print c print result ascii value 97 0 interpreted true print enter loop end first run print r reenter loop 
p2061
aVputchar writes char standard output loops structured way: fora b c d _a_ gets executed beginning hence output get c beginning _b_ get executed next iteration condition check see whether need iterate _c_ incrementation step gets executed _b_ executed _d_ gets executed _b_ returned true putchar returns character written 1 case error char successfully written standard output case run infinite loop unless point reason putchara fails 
p2062
asS'12873568'
p2063
(lp2064
Vstack frame structure function sub scope following code took reference understand sub scope dummy scope present within function impacts structure stack frame include stdioh int main int main_scope0 scope life time variable throughout main two statements assume seperate stack frame created braces free access scope exists modify lifetime exists variable main_scope anywhere within main main_scope printfmain_scope:d\u005cnmain_scope expected statement throw error saying multiple definition main_scopebut isnt int main_scope2 printfvalue redefined main_scope:d\u005cnmain_scope printffinally main_scope s:d\u005cn__function__main_scope return 0 sample output main_scope:1 value redefined main_scope:2 finally main_scope main:1 based behavior presume following stack frame creation scope way auto variables declareddefined main within sub scope share stack frame variables declareddefined main free accessed anywhere within function even within sub scope hand variables declareddefined sub scope loses scope blockbut life time valid long stack frame present question: points right isnt code failing giving multiple definitions variable one within main within 
p2065
aVhardware stack irrelevant grow local variables function entry shrink function exit grow shrink every time new local variable defined destroyed enclosing left whats relevant visibility variables int main_scope0 main_scope printfmain_scope:d\u005cnmain_scope main_scope variable assigned 0 recent visible declaration main_scope int main_scope2 previous declaration main_scope obscured new one youre going access new one printfvalue redefined main_scope:d\u005cnmain_scope printffinally main_scope s:d\u005cn__function__main_scope previous scope inside left main_scope going one assigned 0 perfectly legal define object innersubscope name outersuperscope latter obscured duration scope reference places variable definitions occur eg inside first expression statement: int 0 10 variable visible inside fors body hide well defining another 
p2066
aVlocal variable _hides_ outer variable main_scope int main int i1 int i2 printfd whenever use always local one thats used outer hidden local local deallocated scope exits perfectly legal c note illegal c example certainly stack frame created inner main_scope itll deallocated program goes inner scope 
p2067
asS'28686049'
p2068
(lp2069
Vscope static function c ive heard function declared static placed stack heap im studying found quite interesting looks like true really true way put function heap lifetime 
p2070
aV_functions_ placed stack heap function ie code implements typically placed region memory often marked os readonly thats loaded executable file program starts static keyword function definition affects visibility name static functions name visible within translation unit defines still called translation units source files use pointer rather calling function name storage variables defined within function typically allocated stack theyre defined static global memory region defined static heap used memory allocated malloc similar functions note c standard use terms stack heap different c compilers might use differently local variables function allocated stacklike manner standard says nothing stack implemented example necessarily contiguous memory 
p2071
asS'27870225'
p2072
(lp2073
Vstruggling unset environment variable bash previously set environment variable using: echo export avariableexample bash_profile using: unset avariable env var remains open new shell wrong even running: source bash_profile work 
p2074
aVopening new shell first thing source bash_profile variable set want get rid permanently edit bash_profile remove line question take effect new sessions want unset current shell unset fine youve seen wont affect new invocations shell 
p2075
aVthis: binbash filebash_profile readarray file cat file rm rf file item file@ item export echo item file fi done beware going save array content bash_profile file delete try generate lines excepting line matches regular expresion need put export check could remove lines depending content bash_profile beware pretty sure line bash_profile containing string export line want remove script otherwise modify regexp conditional careful permissions owner file usually 644 launch user owning home dir youll problems repeat bad practice careful cheers 
p2076
asS'23774466'
p2077
(lp2078
Vadding return statement main function c important adding return statement main function c important programs make runs without disadvantage programs omitted return statement main function 
p2079
aVconvention tell operating system program exited successfullyreturning 0 errorfor example returning error code remain standards compliant use return exit_success return exit_failure 
p2080
aVwant code legal ie works compilers support standard youve defined main as: int main return 0 return integer case 0 according standard youve defined function certain return type return return type otherwise isnt legal may compile thanks forgiving compilers hence relied upon doesnt mean correct 
p2081
aV iso c standard isoiec 14882:1998 specifically requires main return int explicit shall constraint upon wellformed programs shall return type int otherwise type implementation defined implementations shall allow following definitions main: int main \u2026 int mainint argc char argv \u2026 iso c standard isoiec 9899:1999 actually mandate c standard comes surprise many people despite many documents say including usenet complangc faq document great length actual text c standard allows main returning types use either int void though better use int returning inform os program exited see practical example: int main int printfenter positive number: scanfd ifa0 return 1 return 0 sure best example could help understand concept better hope helps 
p2082
asS'333889'
p2083
(lp2084
Vheader files cpp files c c header files cpp files 
p2085
aVpreprocessor way declaring interfaces put interface method declarations header file implementation cpp applications using library need know interface access include 
p2086
aVc final executable code carry symbol information less pure machine code thus need way describe interface piece code separate code description header file 
p2087
aVwell main reason would separating interface implementation header declares class whatever implemented cpp file defines perform features reduces dependencies code uses header doesnt necessarily need know details implementation classesheaders needed reduce compilation times also amount recompilation needed something implementation changes perfect would usually resort techniques like pimpl idiom separate interface implementation good start 
p2088
aVpeople designed library format didnt want waste space rarely used information like c preprocessor macros function declarations since need info tell compiler function available later linker job come second file shared information could stored languages cc store information output java bytecode example dont use precompiled format get always distributed source form compile fly python perl 
p2089
aVoften want definition interface without ship entire code example shared library would ship header file defines functions symbols used shared library without header files would need ship source within single project header files used imho least two purposes: clarity keeping interfaces separate implementation easier read code compile time using interface possible instead full implementation compile time reduced compiler simply make reference interface instead parse actual code idealy would need done single time 
p2090
aV c compilation compilation c done 2 major phases: 1 first compilation source text files binary object files: cpp file compiled file compiled without knowledge cpp files even libraries unless fed raw declaration header inclusion cpp file usually compiled obj o object file 2 second linking together object files thus creation final binary file either library executable hpp fit process poor lonesome cpp file compilation cpp file independent cpp files means acpp needs symbol defined bcpp like: acpp void dosomething dosomethingelse defined bcpp bcpp void dosomethingelse etc wont compile acpp way know dosomethingelse exists unless declaration acpp like: acpp void dosomethingelse bcpp void dosomething dosomethingelse defined bcpp ccpp uses symbol copypaste declaration copypaste alert yes problem copypastes dangerous difficult maintain means would cool way copypaste still declare symbol include text file commonly suffixed h hxx h preferred c files hpp: bhpp decided declare every symbol defined bcpp void dosomethingelse acpp include bhpp void dosomething dosomethingelse defined bcpp bcpp include bhpp void dosomethingelse etc ccpp include bhpp void dosomethingagain dosomethingelse defined bcpp include work including file essence parse copypaste content cpp file example following code ahpp header: ahpp void somefunction void someotherfunction source bcpp: bcpp include ahpp void dosomething etc become inclusion: bcpp void somefunction void someotherfunction void dosomething etc one small thing include bhpp bcpp current case needed bhpp dosomethingelse function declaration bcpp dosomethingelse function definition declaration general case bhpp used declarations inline code could corresponding definition example enums plain structs etc include could needed bcpp uses declaration bhpp good taste source include default header conclusion header file thus necessary c compiler unable search symbol declarations alone thus must help including declarations one last word: put header guards around content hpp files sure multiple inclusions wont break anything believe main reason existence hpp files explained 
p2091
aVc concept originated 30 years old back viable way link together code multiple files today awful hack totally destroys compilation time c causes countless needless dependencies class definitions header file expose much information implementation 
p2092
aVc inherited c unfortunately 
p2093
aVresponding madkeithvs answer whyhaveheaderfilesandcppfilesinc333902333902 reduces dependencies code uses header doesnt necessarily need know details implementation classesheaders needed reduce compilation times also amount recompilation needed something implementation changes another reason header gives unique id class something like class class b : public class c include acpp include bcpp errors try build project since part b headers would avoid kind headache 
p2094
asS'897366'
p2095
(lp2096
Vpointer pointers work c pointers pointers work c would use 
p2097
aVpointer pointer well pointer pointer meaningfull example sometype bidimensional array: one array filled pointers arrays write dpointer56 access array contains pointers arrays 5th position get pointer let fpointer name access 6th element array referenced array fpointer6 
p2098
aVpointer pointers address value thats terrible know basically lets pass pointer value address another pointer modify another pointer pointing sub function like: void changeptrint pp ppsomeval 
p2099
aVmay want read : pointers pointers hope helps clarify basic doubts 
p2100
aVpointer pointer also called handle one usage often object moved memory removed one often responsible lock unlock usage _object_ moved accessing often used memory restricted environment ie palm os computerhowstuffworkscom link wwwflippinbitscom link handlevspointer 
p2101
aVpointers pointers work c first pointer variable like variable holds address variable pointer pointer variable like variable holds address variable variable happens pointer would use use need return pointer memory heap using return value example: int getvalueof5int p p 5 return 1success int get1024heapmemoryint p p malloc1024 ifp 0 return 1error else return 0success call like this: int x getvalueof5xi want fill int varaible pass address point x holds 5 int p get1024heapmemorypi want fill int variable pass address point p holds memory address 1024 bytes memory allocated heap uses like main argument every c program pointer pointer argv element holds array chars command line options must careful though use pointers pointers point 2 dimensional arrays better use pointer 2 dimensional array instead dangerous void test double int i1 sizeofa0i1 4 sizeofdouble double matrixrowscolumns int i2 sizeofmatrix0i2 240 columns sizeofdouble example pointer 2 dimensional array done properly: int mypointerto2dimarrayrowscolumns cant use pointer 2 dimensional array though want support variable number elements rows columns know hand would use 2 dimensional array 
p2102
aVvariable contains address something thats pointer another variable contains address first variable thats pointer pointer 
p2103
aVlets assume 8 bit computer 8 bit addresses thus 256 bytes memory part memory numbers top addresses: 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 58 63 55 h e l l o \u005c0 see address 63 string starts case occurrence memory const char c defines c pointer readonly string thus contains value 63 c must stored somewhere: example location 58 course point characters also pointers eg: const char cp c cp points c contains address c 58 go even consider: const char cpp cp cpp stores address cp value 55 based example guessed it: stored address 60 _why_ one uses pointers pointers: name array usually yields address first element array contains elements type reference array type consider array arrays type t: naturally reference 2d array type hence pointer pointer even though array strings sounds onedimensional fact twodimensional since strings character arrays hence: char function f need accept argument type alter variable type many reasons numerous list 
p2104
aVreference pointer required example wish modify value address pointed pointer variable declared calling functions scope inside called function pass single pointer argument modifying local copies pointer original pointer calling scope pointer pointer modify latter 
p2105
aVcovering pointers programming course university given two hints begin learning first view pointer fun binky think haddocks eyes carrolls _through lookingglass_ \u201cyou sad\u201d knight said anxious tone: \u201clet sing song comfort you\u201d \u201cis long\u201d alice asked heard good deal poetry day \u201cits long\u201d said knight \u201cbut beautiful everybody hears sing either brings tears eyes else \u201d \u201cor else what\u201d said alice knight made sudden pause \u201cor else doesnt know name song called \u2018haddocks eyes\u2019\u201d \u201coh thats name song alice said trying feel interested \u201cno dont understand\u201d knight said looking little vexed \u201cthats name called name really \u2018the aged aged man\u2019\u201d \u201cthen ought said \u2018thats song called\u2019\u201d alice corrected \u201cno oughtnt: thats quite another thing song called \u2018ways means\u2019: thats called know\u201d \u201cwell song then\u201d said alice time completely bewildered \u201ci coming that\u201d knight said \u201cthe song really \u2018asitting gate\u2019: tunes invention\u201d 
p2106
aVlike real world code example pointer pointer usage git 20 commit 7b1004b linus said: actually wish people understood really core lowlevel kind coding big complex stuff like lockless name lookup simply good use pointerstopointers etc example ive seen many people delete singlylinked list entry keeping track prev entry delete entry something like prev prevnext entrynext else list_head entrynext whenever see code like go person doesnt understand pointers sadly quite common people understand pointers use pointer entry pointer initialize address list_head traverse list remove entry without using conditionals pp entrynext applying simplification lets us lose 7 lines function even adding 2 lines comment struct combine_diff_path p pprev ptmp struct combine_diff_path p tail curr kumar comments pointersworkinc22354860noredirect1comment36251111_22354860 blog post linus understanding pointers linusonunderstandingpointers grisha trubetskoy imagine linked list defined as: typedef struct list_entry int val struct list_entry next list_entry need iterate beginning end remove specific element whose value equals value to_remove obvious way would be: list_entry entry head assuming head exists first entry list list_entry prev null entry line 4 entryval to_remove one remove line 5 prev prevnext entrynext remove entry line 7 else head entrynext special case first entry line 9 move next entry prev entry entry entrynext is: iterating list entry null means we\u2019ve reached end list line 4 come across entry want removed line 5 assign value current next pointer previous one thus eliminating current element line 7 special case beginning iteration previous entry prev null remove first entry list modify head line 9 linus saying code could simplified making previous element pointer pointer rather pointer code looks like this: list_entry pp head pointer pointer list_entry entry head entry entryval to_remove pp entrynext pp entrynext entry entrynext code similar previous variant notice longer need watch special case first element list since pp null beginning simple clever also someone thread commented reason better pp entrynext atomic certainly atomic expression contains two dereference operators one assignment neither three things atomic common misconception alas pretty much nothing c ever assumed atomic including operators 
p2107
aVworks: variable store another pointer would use : many uses one function wants construct array return caller returns array roll nos 11 12 paramater return value total number students int fun int int j intmalloc 2sizeofint 11 eg newly allocated memory 0x2000 store 11 j j j 12 eg newly allocated memory 0x2004 store 12 return 2 int main int int n fun hey dont know many students class please send roll numbers int j0 jn j printf roll d \u005cn ij return 0 
p2108
aVconsider figure program understand concept better double pointer diagram per figure ptr1 single pointer address variable num ptr1 num similarly ptr2 pointer pointerdouble pointer address pointer ptr1 ptr2 ptr1 pointer points another pointer known double pointer example ptr2 double pointer values diagram : address variable num : 1000 address pointer ptr1 is: 2000 address pointer ptr2 is: 3000 example: include stdioh int main int num 10 int ptr1 int ptr2 take address var ptr1 num take address ptr1 using address operator ptr2 ptr1 print value printfvalue num d\u005cn num printfvalue available ptr1 d\u005cn ptr1 printfvalue available ptr2 d\u005cn ptr2 output: value num 10 value available ptr1 10 value available ptr2 10 
p2109
asS'13202074'
p2110
(lp2111
Vsecure read bash read command know builtin bash command called read want scripts: read passwrod prompts input input visible alternative command make input invisible 
p2112
aVuse terminal settings turn echo off: binbash disable echo stty echo prompt read password printf password: read password turn echo back stty echo printf \u005cn 
p2113
aVuse lines: stty echo read p password: passw echo stty echo turn echo password reading 
p2114
aVtime learn manual bash bash bash 41 edition relevant option read read ers aname d delim text n nchars n nchars p prompt timeout u fd name one line read standard input file descriptor fd supplied argument \u2018u\u2019 option first word assigned first name second word second name leftover words intervening separators assigned last name fewer words read input stream names remaining names assigned empty values characters value ifs variable used split line words backslash character \u005c may used remove special meaning next character read line continuation names supplied line read assigned variable reply return code zero unless endoffile encountered read times case return code greater 128 invalid file descriptor supplied argument u options supplied following meanings: aname words assigned sequential indices array variable aname starting 0 elements removed aname assignment name arguments ignored d delim first character delim used terminate input line rather newline e readline see chapter 8 command line editing page 93 used obtain line readline uses current default line editing previously active editing settings text readline used read line text placed editing buffer editing begins n nchars read returns reading nchars characters rather waiting complete line input honor delimiter fewer nchars characters read delimiter n nchars read returns reading exactly nchars characters rather waiting complete line input unless eof encountered read times delimiter characters encountered input treated specially cause read return nchars characters read p prompt display prompt without trailing newline attempting read input prompt displayed input coming terminal r option given backslash act escape character backslash considered part line particular backslashnewline pair may used line continuation silent mode input coming terminal characters echoed timeout cause read time return failure complete line input read within timeout seconds timeout may decimal number fractional portion following decimal point option effective read reading input terminal pipe special file effect reading regular files timeout 0 read returns success input available specified file descriptor failure otherwise exit status greater 128 timeout exceeded u fd read input file descriptor fd hence typo fixed need: read p password: password may want add echo immediately since newline isnt echoed either though included password 
p2115
aV read p password: passw works bash 
p2116
asS'17052443'
p2117
(lp2118
Vc function inside struct im trying create function inside structure far code: typedef struct client_t client_t pno struct client_t pid_t pid char passwordtam_max 50 chars pno next pno addclient code int main client_t client code clientaddclient error: _clienth:24:2: error: expected \u2018:\u2019 \u2018\u2019 \u2018\u2019 \u2018\u2019 \u2018attribute\u2019 \u2018\u2019 token_ correct way 
p2119
aVwork c functions structs feature c goes clientaddclient call call member function object oriented programming ie c convert source cpp file make sure compiling accordingly need stick c code sort equivalent: typedef struct client_t client_t pno struct client_t pid_t pid char passwordtam_max 50 chars pno next pno addclientpno pclient code int main client_t client code addclientclient 
p2120
aVcant done directly emulate thing using function pointers explicitly passing parameter: typedef struct client_t client_t pno struct client_t pid_t pid char passwordtam_max 50 chars pno next pno addclientclient_t pno client_t_addclientclient_t self code int main client_t client clientaddclient client_t_addclient probably really done init fn code clientaddclientclient turns however doesnt really buy awful lot wont see many c apis implemented style since may well call external function pass instance 
p2121
aVothers noted embedding function pointers directly inside structure usually reserved special purposes like callback function probably want something like virtual method table typedef struct client_ops_t client_ops_t typedef struct client_t client_t pno struct client_t client_ops_t ops struct client_ops_t pno addclientclient_t pno removeclientclient_t pno addclient client_t client return clientopsaddclientclient pno removeclient client_t client return clientopsremoveclientclient adding operations change size client_t structure kind flexibility useful need define many kinds clients want allow users client_t interface able augment operations behave kind structure appear real code openssl bio layer looks similar also unix device driver interfaces layer like 
p2122
aVinclude stdioh typedef struct int somefunction int foo return 0 struct ahello ahellosomefunction foo return ahello int main struct ahello printfprint hello: d\u005cn ahellosomefunction return 0 
p2123
asS'13237279'
p2124
(lp2125
Vbash read command try use read command catch user enters read p please enter name n 20 name figured cant rectify entered make backspace remove add 
p2126
aVeasiest way use e flag read make use readline read e p please enter name n 20 name could also change terminal settings stty backspace instead delete erase 
p2127
aVpipe text entered user text col b example: nameecho namecol b portable using option e read command e supported unix systems example aix think gnulinux extension 
p2128
asS'1464174'
p2129
(lp2130
Vsize_t vs intptr_t c standard guarantees size_t type hold array index means logically size_t able hold pointer type ive read sites found googles legal andor always work: void v malloc10 size_t size_t v c99 standard introduced intptr_t uintptr_t types signed unsigned types guaranteed able hold pointers: uintptr_t p size_t v difference using size_t uintptr_t unsigned able hold pointer type seem functionally identical real compelling reason use uintptr_t better yet void rather size_t clarity opaque structure field handled internal functions reason token ptrdiff_t signed type capable holding pointer differences therefore capable holding pointer distinct intptr_t arent types basically serving trivially different versions function cant one cant another c99 add two essentially superfluous types language im willing disregard function pointers dont apply current problem feel free mention sneaking suspicion central correct answer 
p2131
aVpossible size largest array smaller pointer think segmented architectures pointers may 32bits single segment may able address 64kb example old realmode 8086 architecture arent commonly use desktop machines anymore c standard intended support even small specialized architectures still embedded systems developed 8 16 bit cpus example 
p2132
aV size_t type hold array index means logically size_t able hold pointer type necessarily hark back days segmented 16bit architectures example: array might limited single segment 16bit size_t would could multiple segments 32bit intptr_t type would needed pick segment well offset within know things sound weird days uniformly addressable unsegmented architectures standard must cater wider variety whats normal 2009 know 
p2133
aVwould imagine goes type names better conveys intentions code example even though unsigned short wchar_t size windows think using wchar_t instead unsigned short shows intention use store wide character rather arbitrary number 
p2134
aVregarding statement: c standard guarantees size_t type hold array index means logically size_t able hold pointer type called fallacy misconception resulting incorrect reasoning may _think_ latter follows former thats necessarily pointers array indexes _not_ thing quite plausible envisage conforming implementation limits arrays 65536 elements allows pointers address value massive 128bit address space c99 states upper limit size_t variable defined size_max low 65535 see c99 tr3 7183 unchanged c11 pointers would fairly limited restricted range modern systems practice youll probably find assumption holds thats standard guarantees actually _doesnt_ guarantee 
p2135
aVlooking backwards forwards recalling various oddball architectures scattered landscape im pretty sure trying wrap existing systems also provide possible future systems sure way things settled far needed many types even lp64 rather common paradigm needed size_t ssize_t system call interface one imagine constrained legacy future system using full 64bit type expensive might want punt io ops larger 4gb still 64bit pointers think wonder: might developed might come future perhaps 128bit distributedsystem internetwide pointers 64 bits system call perhaps even legacy 32bit limit : image legacy systems might get new c compilers also look existed around besides zillion 286 realmode memory models cdc 60bit word 18bit pointer mainframes cray series never mind normal ilp64 lp64 llp64 always thought microsoft pretensious llp64 p64 certainly imagine committee trying cover bases 
p2136
aVill let answers stand regarding reasoning segment limitations exotic architectures isnt simple _difference names_ reason enough use proper type proper thing youre storing size use size_t youre storing pointer use intptr_t person reading code instantly know aha size something probably bytes oh heres pointer value stored integer reason otherwise could use unsigned long everything size everything type names carry meaning useful since helps describe program 
p2137
aV int main int a40153 int a0 a0 int a1 a1 int a2 2a int a3 3a return a2 implying intptr_t must always substitute size_t visa versa 
p2138
asS'4003087'
p2139
(lp2140
Vwhats major difference union struct c  possible duplicate: difference structure union c andaunioninc could understand struct means bit confused difference union struct union like share memory exactly means 
p2141
aVunion members share _same_ memory struct share memory different space memory allocated member struct example: union foo int x int y foo f fx 10 printfd\u005cn fy assign value 10 foo::x output value foo::y _also_ 10 since x y share memory note since members union share memory compiler must allocate enough memory fit _largest_ member union union containing char long would need enough space fit long use struct: struct foo int x int y foo f fx 10 fy 20 printfd d\u005cn fx fy assign 10 x 20 y print see x 10 y 20 x y share memory edit: also take note gmans comment example provided union demonstration purposes practice shouldnt write one data member union access another data member usually simply cause compiler interpret bit pattern another type may get unexpected results since undefined behavior 
p2142
aVmember union shares memory means change one change others members different types unpredictable results exactly unpredictable hard predict unless aware underlying bit patterns make data members 
p2143
aVsuppose one way think union set aliases varying type block memory member union alias given type alias refers address memory bits address interpreted determined alias type amount memory union occupies always equal possibly larger largest sized member union due alignment restrictions 
p2144
aVive used unions convert bytes types find easier bitshifting union intconverter int intvalue struct byte hi byte lo bytevalue intconverter cv cvintvalue 1100 printfx x\u005cn cvbytevaluehi cvbytevaluelo int 16bit used micro controller 
p2145
aVmay useful uncontrived example good say uncontrived bitbanging uses union extremely treacherous bitbanging unions taken bigendian littleendian hardware break initially mystifying ways course ive written bitbanging unions tear apart floating point numbers implement ordersofmagnitudefasterthanthelibrary math functions add assertions members supposed addresses struct option1 int type members struct option2 int type members struct option3 int type members union combo int type guaranteed exactly overlap structs ints type struct option1 struct option2 struct option3 void foounion combo switchintype case 1: struct option1 bar process option1 type request case 2: struct option2 bar process option2 type request case 3: struct option3 bar process option3 type request kind construction common x programming situations one wishes make function receive many different types messages different argument layout requirements 
p2146
aVrun program find output include lt stdioh int main union _testunion long long x long long y testunion struct _teststruct long long x long long y teststruct printfsizeof union d\u005cnsizeoftestunion printfsizeof struct d\u005cnsizeofteststruct return find size struct double union union allocated space one variable struct allocated two 
p2147
aVanswers correct union essentially way access data different ways example accessinterpret 4 bytes memory 1 integers 4 characters structs know straightforward collection different seprate objects memory usually require unions much later stage programming compared structs 
p2148
asS'159449'
p2149
(lp2150
Vvalid shebang line following question unix: else needed top line goes \u005cbin\u005cawk f make run command thinking whatever name script need given permission using chmod make run 
p2151
aVfirst line full pathname program executed pathnames linux forward slash directories ie: binawk f binbash usrbinperl first script would run script program using awk second using bash third using perl youll also make file executable with: chmod x myscriptsh 
p2152
aV\u005cbin\u005cawk f valid shebang line isnt useful one declares file must interpreted program called \u005cbin\u005cawk current directory thus answer question literally two ways run file command: create file called \u005cbin\u005cawk current directory presumably copying linking version awk also script needs made executable ln binawk \u005cbin\u005cawk chmod x pathtoscript pathtoscript invoke awk explicitly awk f pathtoscript modifying file allowed shebang line edited make sense: replace backslashes slashes make file executable undoubtedly intended answer merely would correct answer 
p2153
asS'87560'
p2154
(lp2155
Vshebang determine shell runs script may silly question ask still declared shebang binbash beginning my_shell_scriptsh always invoke script using bash my@compbash my_shell_scriptsh use eg my@compsh my_shell_scriptsh script determines running shell using shebang happening ksh shell im using aix 
p2156
aVyes way silly question reference answer starting script called shebang bang line nothing absolute path bash interpreter consists number sign exclamation point character followed full path interpreter binbash scripts linux execute using interpreter specified first line almost bash scripts often begin binbash assuming bash installed bin ensures bash used interpret script even executed another shell shebang introduced dennis ritchie version 7 unix 8 bell laboratories also added bsd line berkeley ignoring interpreter line shebang specify interpreter line default usually binsh recommended set binbash line 
p2157
aVgathered whenever file executable bit set invoked kernel analyzes file header order determine proceed far know add custom handlers custom file formats via lkms file appears text file combination beginning execution dispatched another executable usually shell sorts path specified directly said shebang line kernel proceeds execute shell pass file handle short doesnt matter shell invoke script kernel dispatch execution appropriate one either way 
p2158
aV_shebang_ human readable instance magic number wikipedia article magic number \u005cprogramming\u005c consisting byte string 0x23 0x21 used exec family functions determine whether file executed script binary shebang present exec run executable specified shebang instead note means invoke script specifying interpreter command line done cases given question exec execute interpreter specified command line wont even look script others noted want exec invoke interpreter specified shebang line script must executable bit set invoked my_shell_scriptsh behaviour easy demonstrate following script: binksh readlink procexe explanation: binksh defines ksh interpreter holds pid current process procpidexe symlink executable process least linux aix procobjectaout link executable readlink output value symbolic link example: note: im demonstrating ubuntu default shell binsh symlink dash ie bindash binksh symlink etcalternativesksh turn symlink binpdksh chmod x getshellsh getshellsh binpdksh bash getshellsh binbash sh getshellsh bindash 
p2159
asS'4603271'
p2160
(lp2161
Vc extern storage class lifespan c newbie come java background would like confirm following: reading c dissection ira pohl book states lifespan fileextern variablefunction duration program _which makes sense variable declared class_ want know also case variable declared class variable declared class make variable use auto storage class thanks 
p2162
aVmember variable class lifespan corresponding lifespan classs instances unless declared static struct foo int x static int y foo therefore x program lifespan: static foo foo one auto: int main foo foo one dynamically allocated lives foo deleted: int main foo foo new foo case y program lifespan 
p2163
asS'8706192'
p2164
(lp2165
Vkind pointer use ok last time wrote c living std::auto_ptr std lib available boost::shared_ptr rage never really looked smart pointer types boost provided understand c11 provides types boost came someone simple algorithm determine use smart pointer preferably including advice regarding dumb pointers raw pointers like rest boost smart pointers something like 
p2166
aVuse unique_ptrt time except need reference counting case use shared_ptrt rare cases weak_ptrt prevent reference cycles almost every case transferrable unique ownership fine raw pointers: good need covariant returns nonowning pointing happen theyre terrifically useful otherwise array pointers: unique_ptr specialization automatically calls delete result safely unique_ptrint pnew int42 example shared_ptr youd still need custom deleter wouldnt need specialized shared unique array pointer course things usually best replaced std::vector anyway unfortunately shared_ptr provide array access function youd still manually call get unique_ptrt provides operator instead operator operator case bounds check makes shared_ptr slightly less userfriendly although arguably generic advantage boost dependency makes unique_ptr shared_ptr winners scoped pointers: made irrelevant unique_ptr like auto_ptr theres really nothing c03 without move semantics situation complicated c11 advice simple still uses smart pointers like intrusive_ptr interprocess_ptr however theyre _very_ niche completely unnecessary general case 
p2167
aVdeciding smart pointer use question _ownership_ comes resource management object _owns_ object b control lifetime object b example member variables owned respective objects lifetime member variables tied lifetime object choose smart pointers based object owned note ownership software system separate ownership would think outside software example person might home doesnt necessarily mean person object control lifetime house object conflating real world concepts software concepts surefire way program hole sole ownership object use std::unique_ptrt shared ownership object \u005c cycles ownership use std::shared_ptrt \u005c cycles define direction use std::shared_ptrt one direction std::weak_ptrt object owns potential owner use normal pointers eg parent pointers object owns otherwise guaranteed existence use references caveat: aware costs smart pointers memory performance limited environments could beneficial use normal pointers manual scheme managing memory costs: custom deleter eg use allocation pools incur overhead per pointer may easily avoided manual deletion std::shared_ptr overhead reference count increment copy plus decrement destruction followed 0count check deletion held object depending implementation bloat code cause performance issues compile time templates smart pointers contribute negatively compile times examples: struct binarytree tree m_parent std::unique_ptrbinarytree m_children2 use std::array binary tree parent existence tree implies existence parent nullptr root uses normal pointer binary tree value semantics sole ownership children std::unique_ptr struct listnode std::shared_ptrlistnode m_next std::weak_ptrlistnode m_prev list node owns next previous lists define direction use shared_ptr next weak_ptr prev break cycle 
p2168
aVshared ownership: shared_ptr weak_ptr standard adopted pretty much boost counterparts use need share resource dont know one last alive use weak_ptr observe shared resource without influencing lifetime break cycles cycles shared_ptr shouldnt normally happen two resources cant note boost additionally offers shared_array might suitable alternative shared_ptrstd::vectort const next boost offers intrusive_ptr lightweight solution resource offers referencecounted management already want adopt raii principle one adopted standard unique ownership: boost also scoped_ptr copyable specify deleter std::unique_ptr boost::scoped_ptr steroids default choice need smart pointer allows specify deleter template arguments _movable_ unlike boost::scoped_ptr also fully usable stl containers long dont use operations need copyable types obviously note boost array version: scoped_array standard unified requiring std::unique_ptrt partial specialization delete pointer instead deleteing default_deleter std::unique_ptrt also offers operator instead operator operator note std::auto_ptr still standard _deprecated_ §d10 deprautoptr class template auto_ptr deprecated _note:_ class template unique_ptr 2071 provides better solution _\u2014end note_ ownership: use dumb pointers raw pointers references nonowning references resources know resource outlive referencing object scope prefer references use raw pointers need either nullability resettability want nonowning reference resource dont know resource outlive object references pack resource shared_ptr use weak_ptr \u005c test parent shared_ptr alive lock return shared_ptr nonnull resource still exists want test whether resource dead use expired two may sound similar different face concurrent execution expired guarantees return value single statement seemingly innocent test like ifwptrexpired something_assuming_the_resource_is_still_alive potential race condition 
p2169
aVcases use unique_ptr: factory methods members pointerspimpl included storing pointers stl containtersto avoid move use large local dynamic objects cases use shared_ptr: sharing objects across threads binding capturing pointersuse lambda std::bind sharing objects general custom deleters cases use weak_ptr: large map acts general referenceex map open sockets feel free edit add 
p2170
asS'1200621'
p2171
(lp2172
Vdeclare array declare array java 
p2173
aVeither use array declaration array literal declare affect variable right away array literals cannot used reassigning array primitive types: int myintarray new int3 int myintarray 123 int myintarray new int123 classes example string same: string mystringarray new string3 string mystringarray abc string mystringarray new stringabc examples see documentation page initializingarrayst201607261943570177 
p2174
aValternatively either method works string arrayname new string10 string arrayname new string10 declares array called arrayname size 10 elements 0 9 use 
p2175
aVvarious ways declare array java: float floatarray initialize later int integerarray new int10 string array new string b find information sun site javadoc 
p2176
aV type variablename new typecapacity type variablename commadelimited values type variablename new typecapacity type variablename commadelimited values also valid prefer brackets type easier see variables type actually array 
p2177
aVfind helpful understand part: type name new type5 type _type_ _variable_ called name name called _identifier_ literal type base type brackets mean array type base array types turn types allows make multidimensional arrays like type array type type keyword new says allocate memory new array number bracket says large new array much memory allocate instance java knows base type type takes 32 bytes want array size 5 needs internally allocate 32 5 160 bytes also create arrays values already int name 1 2 3 4 5 creates empty space fills values java tell primitives integers 5 size array determined implicitly 
p2178
aValso case want something dynamic list interface perform well flexible: liststring listofstring new arrayliststring listofstringaddfoo listofstringaddbar string value listofstringget0 assertequals value foo 
p2179
aVfollowing shows declaration array array initialized: int myintarray new int3 following shows declaration well initialization array: int myintarray 123 following also shows declaration well initialization array: int myintarray new int123 third one shows property anonymous arrayobject creation pointed reference variable myintarray write new int123 anonymous arrayobject created write: int myintarray declaration array following statement makes declaration complete: myintarraynew int3 
p2180
aVtwo types array one dimensional array syntax default values: int num new int5 less preferred int num new int5 syntax values given variablefield initialization: int num 12345 less preferred int num 1 2 3 4 5 note: convenience int num preferable clearly tells talking array otherwise difference multidimensional array declaration int num new int52 int num new int52 int num new int52 initialization num001 num012 num101 num112 num201 num212 num301 num312 num401 num412 int num 12 12 12 12 12 ragged array nonrectangular array int num new int5 num0 new int1 num1 new int5 num2 new int2 num3 new int3 defining columns explicitly another way: int num 1 12 12345 12 123 accessing: int i0 inumlength int j0jnumilengthj systemoutprintlnnumij alternatively: int : num int : systemoutprintlni ragged arrays multidimensional arrays explanation see multidimensional array detail official java tutorials 
p2181
aVwant create arrays using reflections like this: int size 3 int intarray int arraynewinstanceintclass size 
p2182
aVtake primitive type int example several ways declare int array: int new intcapacity int new int value1 value2 value3 etc int value1 value2 value3 etc use int instead int reflection use type arraynewinstancetypeclass capacity note method parameters indicates variable arguments essentially number parameters fine easier explain code: public static void varargsint fixed1 string fixed2 int varargs varargs0 100 fixed1 0 fixed2 varargs 100 varargs0 100 200 fixed1 0 fixed2 varargs 100 200 inside method varargs treated normal int type used method parameters int new int compile note passing int method type cannot use third way statement int b c d etc compiler assumes means int declaring variable passing array method declaration must either new typecapacity new type multidimensional arrays multidimensional arrays much harder deal essentially 2d array array arrays int means array ints key int declared intxy maximum index ix1y1 essentially rectangular int35 is: 0 0 1 0 2 0 0 1 1 1 2 1 0 2 1 2 2 2 0 3 1 3 2 3 0 4 1 4 2 4 
p2183
aVdeclaring array object references: class animal class horse extends animal public static void mainstring args array animal hold animal horse subtypes animal allowed animal a1 new animal10 a10 new animal a11 new horse array animal hold animal horse subtype horse animal a2 new horse10 a20 new animal a21 new horse array horse hold horse subtype allowed supertype horse subtype animal horse h1 new horse10 h10 new animal allowed h11 new horse declared horse h2 new animal10 allowed 
p2184
aVarray sequential list items int item value int one_dimensional_array value value value value int two_dimensional_array value value value value value value value value value value value value object concept object item new object object one_dimensional_array new object new object new object object two_dimensional_array new object new object new object new object new object new object new object new object new object case objects need either assign null initialize using new type classes like string integer special cases handled following string world equivalent string new stringhello new stringworld integer b 1234 5678 equivalent integer b new integer1234 new integer5678 general create arrays thats m dimensional int array m times brackets m times bracket array000 m times 0 m times bracket worthy note creating m dimensional array expensive terms space since create m dimensional array n dimensions total size array bigger nm since array reference mdimension m1dimensional array references total size following space nm nm1 nm2 n0 array reference actual data 
p2185
aV int singledimensionalarray new int2 int multidimensionalarray new int34 
p2186
aVtwo main ways make array: one empty array: int array new intn n number spaces allocate array one initialized array: int array 1234 also make multidimensional arrays like this: int array2d new intxy x y specify dimensions int array2d 123 456 
p2187
aVcreating arrays class objects use javautilarraylist define array: public arraylistclassname arrayname arrayname new arraylistclassname assign values array: arraynameaddnew classnameclass parameters go read array: classname variablename arraynamegetindex note: variablename reference array meaning manipulating variablename manipulate arrayname loops: repeats every value array classname variablename : arrayname note using loop prevents editing arrayname loop allows edit arrayname conventional loop: int 0 arraynamesize manipulate array 
p2188
asS'13073952'
p2189
(lp2190
Vdeclaration may storage class specifier placed example lets consider static storage class specifier examples valid illformed uses storage class specifier: static int valid int static b valid static int c valid int static d valid int static e illformed static int const f valid int static const g valid int const static h valid int const static illformed typedef int pointer static pointer j valid pointer static k valid declarations marked valid accepted visual c 2012 g 472 clang 31 declarations marked illformed rejected compilers seems odd storage class specifier applies declared variable declared variable static type declared variable e illformed k wellformed rules govern valid placement storage class specifiers ive used static example question applies storage class specifiers preferably complete answer cite relevant sections c11 language standard explain 
p2191
aVsummary anywhere declaration specifier see section 71 isoiec 148822012 ie qualifiers associated pointer declarator type specifier static doesnt make sense within context pointer declarator consider following cases: declare normal int pointer int declaration list like this: int b type specifier int two declarations using type specifier int pointer declarator declares pointer int consider: int static b error int static b error int static b error look wrong reason defined sections 71 81 c c require storage specifiers go type specifier declarator clear following also wrong since three also wrong: int static error last example typedef int pointer static pointer j valid pointer static k valid valid equivalent pointer type defined type specifier put type specifier storage specifeir order note equivalent would equivalent saying static int j static int k int static j int static k 
p2192
aVemploy golden rule pointers also doesnt apply pointers follows naturally intuitively avoids lot mistakes pitfalls declaring variables cc violated therere rare exceptions like references came c kampr appendix section 84 meaning declarators states: declarator taken assertion construction form declarator appears expression yields object indicated type storage class declare variable cc really think expression apply get type 1 variable name 2 comes expression valid declaration statement applied variable name 3 comes remaining information properties declaration like type storage storage characteristic aways confer outcome expressions contrary constness example makes sense declaration storage must come somewhere else thats 2 int const pp valid int static pp invalid clearly shows storage makes sense 2 breaks golden rule piece information goes well middle expression neither constrain way const tells storage whats declared think kampr wanted us use inverted reasoning declaring variables frequently common habit used avoids complex declaration mistakes difficulties valid strict sense variations occur like x xsize indexing constness etc 2 expression _maps well_ declaration usage form one thats valid elsewhere strictly golden rule bonus uninitiated include iostream int f3 static int m3 1 2 3 return m int main forint 0 sizeoff sizeoff0 std::cout fi std::endl return 0 reading declarations works almost like reading const cant placed type context operation get address could visualized new keyword like ref reference f: f function return: return reference reference3: reference array 3 elements int arrayi: element int function returns reference array 3 integers proper compile time information array size check sizeof anytime final golden tip anything placed type multiple declarations applied variables cant applied individually const cant put int: int const p following valid: int const p1 const p2 one can: int const p const int p following invalid: int const p1 const p2 exchangeable const applied all: int const p1 p2 const int p1 p2 declaration conventions aways put everything cant put type closer variable int int b anything put put volatile int c could glue const variable name like would 
p2193
aVper 71 simplified structure c declaration declspecifierseq initdeclaratorlist per 711 storage class specifiers belong initial common part decl specifierseq per 81 initdeclaratorlist sequence declarators per 84 part pointer declaration part individual declarator sequence immediately means everything follows part individual declarator storage class specifier placements invalid declarator syntax allow inclusion storage class specifiers rationale rather obvious: since storage class specifiers supposed apply _all_ declarators whole declaration placed common part declaration id say interesting somewhat related situation takes place specifiers present _both_ declspecifierseq individual declarators like const specifier example following declaration int const b const apply declarators first one grammar dictates former interpretation: const applies declarators ie part declspecifierseq 
p2194
asS'2372813'
p2195
(lp2196
Vreading one line time c method used read one line time file c using fgets function working reading space separated token 
p2197
aVfgets way go \u2026 
p2198
aVfgets function read single line file num characters num second parameter passed fgets passing big enough number read line example reads 500 characters 1 line whichever shorter char c500 fgetsc 500 pfile vs reads 1 character char c fgetsc1pfile 
p2199
aVuse either fgets know lines fit buffer use fgetc control reading 
p2200
aVcoding platform gnu c library available use getline: 
p2201
aVcomment complete answer dont enough points comment : heres function prototype fgets: char fgetschar restrict int n file restrict stream read n1 bytes newline eof info see 
p2202
aVwork cant use fgets reason int readlinefile f char buffer size_t len char c int memsetbuffer 0 len 0 len int c fgetcf feoff c \u005cr bufferi 0 else c \u005cn bufferi 0 return i1 else bufferi c else fprintfstderr read_line: recv returned d\u005cn c return 1 return 1 
p2203
aVuse fgets read line use getc chew newline endofline continue readingheres example forever reading line reads 500 characters 1 line whichever shorter char c500 chewup true fgetsc sizeofc pfile feofpfile chewup getcpfile chew newline terminator something c else break end file reached 
p2204
aVuse following program getting line line file include stdioh int main void char filename filetxt file file fopen filename r file null char line 1000 whilefgetslinesizeof linefile null read line file fprintfstdoutsline print file contents stdout fclosefile else perrorfilename print error message stderr return 0 
p2205
aVsource error: actually fault case using strtok function accidently modified original original string hence printing getting error thanks everyone helping : 
p2206
aVuse fscanf instead fgets fgets fscanf characters including spaces using fscanf separately access data saved fileeg file name class rollnow declare string two integers line 
p2207
asS'17515096'
p2208
(lp2209
Vstring array initialization java declare string array: string names new string3 cant assign values array declared like this: names ankitbohraxyz 
p2210
aVfollowing declaration: string names ankitbohraxyz want somewhere declaration: string names names new string ankitbohraxyz 
p2211
aV names ankitbohraxyz initializer used _solely_ constructing creating _new_ array object cannot used _set_ array use declared as: string names ankitbohraxyz may also use: namesnew string ankitbohraxyz 
p2212
aVmean like: string names ankitbohraxyz statement declare 
p2213
aVvalid java syntax names new string ankitbohraxyz 
p2214
aVfirst got nothing string arrays specifically declarative initialization arrays discussed everyone almost every answer declaring variable use: string names xyz however post declaration want assign instance array: names new string abc afaik _declaration syntax_ _syntactic sugar_ applicable anymore assigning values variables values assigned need create instance properly however ask us well good luck getting answer unless someone java committee answers explicit documentation citing said _syntactic sugar_ 
p2215
asS'31958891'
p2216
(lp2217
Vperl6: getc raw mode using perl 6 module term::termios termios usrbinenv perl6 use v6 use term::termios saved_termios : term::termiosnewfd 1getattr termios : term::termiosnewfd 1getattr termiosmakeraw termiossetattr:drain loop c ingetc print got: cord \u005cr\u005cn last c eq q saved_termiossetattr:drain run script press keys uparrow downarrow rightarrow leftarrow q output: arrowup: got: 27 got: 91 arrowdown: got: 65 got: 27 got: 91 arrowright: got: 66 got: 27 got: 91 arrowleft: got: 67 got: 27 got: 91 q: got: 68 another q: got: 113 would expected: arrowup: got: 27 got: 91 got: 65 arrowdown: got: 27 got: 91 got: 66 arrowright: got: 27 got: 91 got: 67 arrowleft: got: 27 got: 91 got: 68 q: got: 113 modify script get desired output 
p2218
aVreplace c ingetc c inread1 change rest code handle buffer instead string 
p2219
asS'1335786'
p2220
(lp2221
Vc: differences char pointer array consider: char amessage time char pmessage time read c programming language edition two statements dont thing always thought array convenient way manipulate pointers store data clearly case non trivial differences arrays pointers c 
p2222
aVtrue subtle difference essentially former: char amessage time defines array whose members live current scopes stack space whereas: char pmessage time defines pointer lives current scopes stack space references memory elsewhere one time stored elsewhere memory commonly string table also note data belonging second definition explicit pointer stored current scopes stack space unspecified exactly stored modified edit: pointed mark gman pavel also difference addressof operator used either variables instance amppmessage returns pointer type char pointer pointer chars whereas ampamessage returns pointer type char16 pointer array 16 chars like char needs dereferenced twice litb points 
p2223
aVarray contains elements pointer points first short form saying char amessage16 amessage0 n amessage1 o amessage15 \u005c0 array contains characters special initialization initializes determines size automatically array elements modifiable may overwrite characters second form pointer points characters stores characters directly since array string literal cannot take pointer write points char pmessage time pmessage p undefined behavior code would probably crash box may anything likes behavior undefined 
p2224
aVsecond one allocates string readonly section elf try following: include stdioh int mainchar argc char argv char amessage time char pmessage time amessage3 printfs\u005cnamessage pmessage3 printfs\u005cnpmessage get segfault second assignment pmessage3s 
p2225
aValong memory string time allocated two different places also keep mind array name acts pointer _value_ opposed pointer _variable_ pmessage main difference pointer variable modified point somewhere else array cannot char arr time char pchar later time char arr2 another string pchar arr2 ok pchar points another string arr arr2 compiler error array name used pointer value pointer variable 
p2226
aVarray const pointer cannot update value make point anywhere else pointer 
p2227
aVcant add usefully answers remark deep c secrets peter van der linden covers example detail asking kinds questions think love book ps assign new value pmessage cant assign new value amessage _immutable_ 
p2228
aVarray defined size available declaration time sizeofpsizeoftypeofarray return number elements array 
p2229
aVfirst form amessage defines variable array contains copy string time second form pmessage defines variable pointer lives different location copy string time try program out: include inttypesh include stdioh int main int argc char argv char amessage time char pmessage time printfamessage : 016prixptr\u005cn uintptr_tamessage printfamessage0: 016prixptr\u005cn uintptr_tamessage0 printfpmessage : 016prixptr\u005cn uintptr_tpmessage printfpmessage0: 016prixptr\u005cn uintptr_tpmessage0 printf\u005cnow time\u005c: 016prixptr\u005cn uintptr_tnow time return 0 youll see amessage equal amessage0 true pmessage pmessage0 fact youll see string stored amessage lives stack string pointed pmessage lives elsewhere last printf shows address string literal compiler string pooling one copy string time youll see address address amessage amessage gets _copy_ string initialized end point amessage stores string memory stack example pmessage points string stored elsewhere 
p2230
aVline: char amessage time compiler evaluate uses amessage pointer start array holding characters time compiler allocates memory time initializes string time know message stored amessage always refers start message amessage may given new value variable name string time line: char pmessage time declares variable pmessage _initialized_ given initial value starting address string time unlike amessage pmessage given new value case previous case compiler also stores time elsewhere memory example cause pmessage point begins time pmessage pmessage 4 
p2231
aVheres hypothetical memory map showing results two declarations: 0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x00008000: n o w 0x00008008: h e m e \u005c0 amessage: 0x00500000: n o w 0x00500008: h e m e \u005c0 pmessage: 0x00500010: 0x00 0x00 0x80 0x00 string literal time stored 16element array char memory address 0x00008000 memory may writable best assume never attempt modify contents string literal declaration char amessage time allocates 16element array char memory address 0x00500000 copies _contents_ string literal memory writable change contents amessage hearts content: strcpyamessage time declaration char pmessage time allocates single pointer char memory address 0x00500010 copies _address_ string literal since pmessage points string literal used argument functions need modify string contents: strcpyamessage pmessage okay strcpypmessage amessage okay strtokamessage okay strtokpmessage okay scanf15s amessage okay scanf15s pmessage okay changed pmessage point amessage: pmessage amessage used everywhere amessage used 
p2232
aVsummary key differences arrays pointers made myself: attention: pointer depth 1 int marr 11325374556 array implemented pointer first array element int pmarr marr dont use assignment pointer depth assigning pointer pointer makes equal pmarr points first arrayelement int point marr 1 attention: moves arraypointer memory sizeoftype 1 byte steps equal type arrayelements sizeofint pointer depth 2 int ppmarr pmarr use going one level deeper use address pointer types array pointer different seen checking types std::cout type marr is: typeidmarrname std::endl int marr gives pointer first array element std::cout type marr is: typeidmarrname std::endl int 6 marr gives pointer whole array std::cout type pmarr is: typeidpmarrname std::endl int pmarr gives pointer first array element std::cout type pmarr is: typeidpmarrname std::endl int pmarr gives pointer pointer first array elelemt gets us one level deeper 
p2233
aVpointer variable holds memory address notice playinf string literals another issue differences explained inline: basically: include stdioh int main char amessage time attention created string literal char pmessage time reusing string literal arrays pointers pmessage null right amessage null compilation error printf d\u005cn sizeof amessage size string literal printf d\u005cn sizeof pmessage size pmessage platform dependent size memory bus 1248 bytes printf p p\u005cn pmessage pmessage values different printf p p\u005cn amessage amessage values sense retrieving amessage string literals pmessage amessage printf string literal defined sharing space demostration time0 w printf modified \u005cn amessage pmessage hope useful return 0 
p2234
aVanswers must answered question would like suggest read paragraph embryonic c development c language authored sir dennis ritchie 
p2235
aV differences char pointer array c99 n1256 draft two completely different uses array literals: 1 initialize char: char c abc magic described 67814 initialization: array character type may initialized character string literal optionally enclosed braces successive characters character string literal including terminating null character room array unknown size initialize elements array shortcut for: char c b c \u005c0 like regular array c modified 2 everywhere else: generates an: unnamed array char type string literals cc static storage gives ub modified write: char c abc similar to: __unnamed magic modifying gives ub static char __unnamed abc char c __unnamed note implicit cast char char always legal modify c0 also modify __unnamed ub documented 645 string literals: 5 translation phase 7 byte code value zero appended multibyte character sequence results string literal literals multibyte character sequence used initialize array static storage duration length sufficient contain sequence character string literals array elements type char initialized individual bytes multibyte character sequence 6 unspecified whether arrays distinct provided elements appropriate values program attempts modify array behavior undefined 67832 initialization gives direct example: example 8: declaration char abc t3 abc defines plain char array objects whose elements initialized character string literals declaration identical char b c \u005c0 b c contents arrays modifiable hand declaration char p abc defines p type pointer char initializes point object type array char length 4 whose elements initialized character string literal attempt made use p modify contents array behavior undefined gcc 48 x8664 elf implementation program: include stdioh int main char abc printfs\u005cn return 0 compile decompile: gcc ggdb stdc99 c mainc objdump sr maino output contains: char abc 8: 48 c7 45 f8 00 00 00 movq 0x00x8rbp f: 00 c: r_x86_64_32s rodata conclusion: gcc stores char rodata section text char: char abc obtain: 17: c7 45 f0 61 62 63 00 movl 0x6362610x10rbp gets stored stack relative rbp note however default linker script puts rodata text segment execute write permission observed with: readelf l aout contains: section segment mapping: segment sections 02 text rodata 
p2236
asS'31716936'
p2237
(lp2238
Vruntime entity load time entity difference runtime entity load time entity static storage class load time entity program: includestdioh void main int i10 static int xi ifxi printfequal else ifxi printfgreater else printfless program produce compile time error cant able assign value static variable x 
p2239
aVcode static int xi produces error cause c const variable constqualified compile time constant use compile time constant initialize global static variable related: c11 chapter §679 expressions initializer object static thread storage duration shall constant expressions string literals answer _difference runtime entity load time entity_ memory allocation point view load time allocation handled compiler runtime allocation handled library functions like malloc calloc free also refer previous answer mine 
p2240
asS'28962014'
p2241
(lp2242
Vbss segment 16 default per knowledge segmentation c program is: high address envcmd line args vars stack segment uninitialized auto vars heap segment dynamic allocated memory bss segment uninitialized staticglobal vars data segment initialized staticglobal vars text segment initialized auto varsexec instructions low address rhel 54 64bit machine c program include stdioh int main do: size aout text data bss dec hex filename 1259 540 16 1815 717 aout unable understand bss16 declaringinitializing globalstatic vars 
p2243
aVworse windows gcc: mainc: include stdioh int main int argc char argv return 0 compile: c:\u005cgcc mainc size: c:\u005csize aexe text data bss dec hex filename 6936 1580 1004 9520 2530 aexe bss includes whole linked executable case various libraries linked use static c initialisation using nostartfiles gets much better result windows also try nostdlib nodefaultlibs compile: c:\u005cgcc nostartfiles mainc size: c:\u005csize aexe text data bss dec hex filename 488 156 32 676 2a4 aexe remove libraries including c library get executable exactly youve compiled bss size 0: mainc: include stdioh int _main int argc char argv return 0 compile: c:\u005cgcc nostartfiles nostdlib nodefaultlibs mainc size: c:\u005csize aexe text data bss dec hex filename 28 20 0 48 30 aexe executable wont run however 
p2244
asS'2094666'
p2245
(lp2246
Vpointers c: use ampersand asterisk im starting pointers im slightly confused know means address variable used front pointer variable get value object pointed pointer things work differently youre working arrays strings youre calling functions pointer copy variable difficult see pattern logic inside use 
p2247
aVok looks like post got editted double foo4 double bar_1 foo0 see use get address beginning array structure following foo_1double bar int size return barsize1 foo_2double bar int size return barsize1 thing 
p2248
aVpointers values: int p variable p pointer integer type int integer value turn pointer value : int i2 p integer i2 assigned integer value pointer p pointing turn value pointer : int p2 pointer p2 point address integer edit: case arrays treated much like pointers think pointers youll using get values inside explained also another common way using operator: int a2 array integers int value first element int i2 a0 another way get first element get second element: int a2 array int 1 value second element int i2 a1 value second element indexing operator special form operator works like this: ai two statements thing 
p2249
aVactually pat theres nothing need know : would add following bits: two operations opposite ends spectrum takes variable gives address takes address gives variable contents arrays degrade pointers pass functions actually multiple levels indirection char p means p pointer pointer char things working differently really: arrays already mentioned degrade pointers first element array passed functions dont preserve size information strings c character arrays convention represent string characters terminated zero \u005c0 character pass address variable function dereference pointer change variable normally variables passed value except arrays 
p2250
aVthink bit confused read good tutorialbook pointers good startersclearly explains yeah dont forget read book pointers c kenneth reek difference clear example: include stdioh int main int x p p x initialise pointertake address x p 0 set x zero printfx d\u005cn x printfp d\u005cn p p 1 increment p points ie x printfx d\u005cn x p increment p points ie x printfx d\u005cn x return 0 
p2251
aVdeclaring pointer variable function parameter use : int x null int y mallocsizeofint z null int fint x nb: declared variable needs want take address value use amp want read write value pointer use int int b b fa b fa arrays usually treated like pointers declare array parameter function easily declare pointer means thing pass array function actually passing pointer first element function pointers things dont quite follow rules take address function without using amp call function pointer without using 
p2252
aVpattern dealing arrays functions little hard see first dealing arrays useful remember following: array expression appears contexts type expression implicitly converted nelement array pointer value set point first element array exceptions rule array expression appears operand either sizeof operators string literal used initializer declaration thus call function array expression argument function receive pointer array: int arr10 fooarr void fooint arr _dont_ use operator arguments corresponding scanf: char strstring_length scanfs str implicit conversion scanf receives char value points beginning str array holds true function called array expression argument str functions scanf printf functions etc practice probably never call function array expression using operator in: int arrn fooarr void fooint pn code common know size array function declaration function works pointers arrays specific sizes pointer 10element array different type pointer 11element array array expression appears operand operator type resulting expression pointer nelement array n different array pointers n pointer base type dealing functions pointers rule remember is: want change value argument reflected calling code must pass pointer thing want modify arrays throw bit monkey wrench works well deal normal cases first remember c passes _all_ function arguments value formal parameter receives copy value actual parameter changes formal parameter reflected actual parameter common example swap function: void swapint x int y int tmp x x y y x int 1 b 2 printfbefore swap: d b d\u005cn b swapa b printfafter swap: d b d\u005cn b youll get following output: swap: 1 b 2 swap: 1 b 2 formal parameters x y distinct objects b changes x y reflected b since want modify values b must pass _pointers_ swap function: void swapint x int y int tmp x x y y tmp int 1 b 2 printfbefore swap: d b d\u005cn b swapa b printfafter swap: d b d\u005cn b output swap: 1 b 2 swap: 2 b 1 note swap function dont change values x y values x y _point to_ writing x different writing x updating value x get location x update value location equally true want modify pointer value write int myfopenfile stream stream fopenmyfiledat r file myfopenin modifying value input parameter stream stream _points to_ changing stream effect value order work must pass pointer pointer: int myfopenfile stream stream fopenmyfiledat r file myfopenin arrays throw bit monkey wrench works pass array expression function function receives pointer array subscripting defined use subscript operator pointer way use array: int arrn initarr n void initint arr int n size_t 0 n arri ii note array objects may assigned ie cant something like int a10 b10 b want careful youre dealing pointers arrays something like void int foon foo wont work 
p2253
aVyeah quite complicated since used many different purposes cc appears front already declared variablefunction means either that: gives access value variable type variable pointer type overloaded operator b meaning multiply operator case another variable left appears variable function declaration means variable pointer: int int_value 1 int int_ptr point another int variable int int_array110 contain 10 int values basically int_array1 pointer aswell points first int array int int_array2 illegal without initializer list int int_array3 12345 two int int_array45 12345 indentical void func_takes_int_ptr1int int_ptr two indentical void func_takes int_ptr2int int_ptr legal appears variable function declaration generally means variable reference variable type appears front already declared variable returns address variable additionally know passing array function always pass array size array aswell except array something like 0terminated cstring char array 
p2254
aVput simply means addressof see placeholders functions modify parameter variable c parameter variables passed value using ampersand means pass reference means dereference pointer variable meaning get value pointer variable int fooint x x int mainint argc char argv int y 5 fooy y incremented scope printfvalue y d\u005cn y output 6 example illustrates call function foo using passby reference compare int fooint x x int mainint argc char argv int y 5 fooy y still 5 printfvalue y d\u005cn y output 5 heres illustration using dereference int mainint argc char argv int y 5 int p null p y printfvalue p d\u005cn p output 5 illustrates got addressof y assigned pointer variable p dereference p attaching front obtain value p ie p 
p2255
aVlooking wordy explanations instead turned video university new south wales rescuehere simple explanation: cell address x value 7 indirect way ask address value 7 7 indirect way ask value address x xso cell: x value: 7 cell: 7 value: x another way look it: john sits 7th seatthe 7th seat point john john give addresslocation 7th seat simple explanation helped hope help others well link excellent video: click another example: include stdioh int main int x normal integer int p pointer integer p integer p must pointer integer p x read assign address x p scanf d x put value x could also use p printf d\u005cn p note use get value getchar addon: always initialize pointer using themif pointer point anything might result crashing program operating system prevent accessing memory knows dont ownbut simply putting p x assigning pointer specific location 
p2256
asS'18688971'
p2257
(lp2258
Vc char array initialization im sure char array initialization following ways 1char buf10 2\u005c char buf10 3\u005c char buf10 case 2 think buf0 buf1 \u005c0 buf2 buf9 random content case 3 think buf0 buf1 \u005c0 buf2 buf9 random content correct case 1 buf buf0 \u005c0 buf1 buf9 random content 
p2259
aVinitialize array for: 1 first declaration: char buf10 equivalent char buf10 0 0 0 0 0 0 0 0 0 0 2 second declaration: char buf10 equivalent char buf10 0 0 0 0 0 0 0 0 0 3 third declaration: char buf10 equivalent char buf10 0 0 0 0 0 0 0 0 0 see random content: fewer initializers remaining array initialized 0 case even array declared inside function 
p2260
aV_edit: op editor silently changed single quotes original question double quotes point provided answer_ code result compiler errors first code fragment: char buf10 buf doubly illegal first c thing empty char use double quotes designate empty string with: char buf give pointer nul string ie singlecharacter string nul character cannot use single quotes nothing inside themthat undefined need designate nul character specify it: char buf \u005c0 backslash necessary disambiguate character 0 char buf 0 accomplishes thing former tad less ambiguous read think secondly cannot initialize arrays defined char buf10 declares defines array array identifier buf address memory cannot change buf points assignment buf anything rhs illegal second third code fragments illegal reason initialize array time definition: char buf 10 give 10character array first char space \u005c040 rest nul ie \u005c0 array declared defined initializer array elements past ones specified initial values automatically padded 0 random content declare define array dont initialize following: char buf 10 random content elements 
p2261
aVinterestingly enough possible initialize arrays way time program provided members struct union example program: include stdioh struct ccont char array32 struct icont int array32 int main int cnt char carray32 66 6111 b c \u005c0 \u005c0 int iarray32 67 42 25 struct ccont cc 0 struct icont ic 0 dont work carray 01 expected expression token carray 0 311 likewise carray char32 03 incompatible types assigning type char32 type char iarray int32 1 likewise scharintg perfectly work cc struct ccont arraya \u005c0 \u005c0 \u005c0 following gcc extension cc struct ccont array 0 2a \u005c0 \u005c0 ic struct icont array 4267 42 67 0 0 0 index ranges overlap latter override former compiler warning wall wextra ic struct icont array 0 142 1 267 42 67 67 0 0 cnt0 cnt5 cnt printf2d c 2d c\u005cniarraycnt carraycnticarraycntccarraycnt return 0 
p2262
aV 1 equivalent char buf10 char buf10 0 char buf10 0 0 0 0 0 0 0 0 0 0 2 equivalent char buf10 char buf10 char buf10 0 0 0 0 0 0 0 0 0 3 equivalent char buf10 char buf10 char buf10 0 0 0 0 0 0 0 0 0 
p2263
aVim sure commonly initialize array case dont need worry null end string main void somethingchar char s100 somethings printfs void somethingchar something pass output need add si \u005c0 unused slot already set \u005c0 
p2264
aVrelevant part c11 standard draft n1570 679 initialization says: 14 array character type may initialized character string literal utf8 string literal optionally enclosed braces successive bytes string literal including terminating null character room array unknown size initialize elements array 21 fewer initializers braceenclosed list elements members aggregate fewer characters string literal used initialize array known size elements array remainder aggregate shall initialized implicitly objects _static storage duration_ thus \u005c0 appended enough space remaining characters initialized value static char c would initialized within function finally 10 object automatic storage duration initialized explicitly value indeterminate object static thread storage duration initialized explicitly then: arithmetic type initialized positive unsigned zero thus char arithmetic type remainder array also guaranteed initialized zeroes 
p2265
asS'7676045'
p2266
(lp2267
Vuse read command bash try use read command bash like this: echo read str echo str nothing echoed think str contain string anybody please help understand behavior 
p2268
aVread script command fine however execute pipeline means subshell therefore variables reads visible parent shell either move rest script subshell too: echo read str echo str use command substitution get value variable subshell strecho echo str slightly complicated example strls read read echo echo str 
p2269
aVvalue disappears since read command run separate subshell: bash faq 24 
p2270
aVneed pipe echo ne menu read number 
p2271
aVbash alternatives involve subshell: read str end heredoc end read str herestring read str echo process substitution 
p2272
aVtypical usage might look like: i0 echo e hello1\u005cnhello2\u005cnhello3 read str echo i: str done output 1: hello1 2: hello2 3: hello3 
p2273
aVput two cents here: ksh reading variable _will_ work according ibm aix documentation kshs read _does_ affects current shell environment: setting shell variables read command affects current shell execution environment resulted spending good minutes figuring one liner ending read ive used zillion times aix didnt work linux ksh saves current environment bash doesnt 
p2274
aVanother alternative altogether use printf function printf v str moreover construct combined use single quotes appropriate helps avoid multiescape problems subshells forms interpolative quoting 
p2275
asS'103555'
p2276
(lp2277
Vunset variable command line tried following command set proxy yaourt: export all_proxy question unset proxy yaourt general unset value variable current shell 
p2278
aVremove environment variable run unset all_proxy note environment variable takes effect program program launches set environment variable one shell window doesnt affect shell windows youve added export all_proxy\u2026 initialization file remove run export arguments see environment variables set current shell remember make shell variable available programs started shell need export either running export var assignment varvalue combining two export varvalue 
p2279
aVunset bound variable bash use unset variable unset all_proxy case command actually deletes variable also set value variable empty variable variable difference two latter commands dont delete variable see difference using u flag set force treat unset variables error substituting: homeuser1 var homeuser1 echo var homeuser1 set u homeuser1 echo var homeuser1 unset var homeuser1 echo var bash: var: unbound variable example bash complains var unbound unsetting value expected error note happen second echo command meaning var value empty null 
p2280
asS'32032044'
p2281
(lp2282
Vmutable variable memory location following understanding mutable variables c 1 special storage class 2 mutable variable modified constant object 3 example case want use mutable variable case dont want execute expensive operation get result unless specifically asked specifically asked program execute operation cache result mutable variable question terms memory compiler store mutable variable memory since modifiable read memory sure 
p2283
aVpresumably compiler specific imagine compilers would simply choose always locate classes entire class mutable members nonconst memory allow 
p2284
aVmutable mutable type qualifier compiler like const volatile members class stored continuous chunk memory except static ones define member const doesnt mean compiler place ro memory const declaration wont effect anything run time keyword compiler perform appropriate checks optimizations compilation define class method const still need modify specific member class like mutex like mentioned cache value let compiler know specific member mutable otherwise get compilation error 
p2285
aVentirely compiler may perform escape analysis determine object never modified case may written readonly section binary mutable storage class specifier relaxes compile time requirement objects required allocated declaration order though regardless storage class specifier variables region memory however nothing would preclude readonly bit set const region bytes machine supported 
p2286
aVmembers class size determined sizeof least 1 true mutable members well means class members must occupy range locations memory thing special mutable member value changed even within const object compiler achieves typically compiler enforces constness compile time words object const members logically const well attempt made modify call nonconst operation member code compile unless member mutable actually need const object members popped readonly memory run time actually done need special treatment allow mutable members changed even changes members prevented example objects members might placed modifiable memory non mutable ones marked eg operating system support cannot changed runtime common reason using mutable members store results expensive operations repeatable give results inputs results arent needed expensive operations also needed result needs accessed repeatedly mutable members allow storing results first time rather repeatedly expensive operations 
p2287
asS'6508819'
p2288
(lp2289
Vconvert date formats bash date format: 27 jun 2011 want convert 20110627 possible bash 
p2290
aV since yesterday date dyesterday ymd precise recommended date d27 jun 2011 ymd assuming similar yesterdays date question date dlastmonday ymd going @seths comment could date 27 jun 2011 date ddate ymd method read stdin read p get date date printf yyyymmdd format date ddate ymd outputs following: get date 27 june 2011 yyyymmdd format 20110627 really want use awk echo 27 june 2011 awk print date d\u005c1fs2fs3\u005c ymd bash note bash redirects awks output shell executed fs field separator case use 0 print line useful one date line dates inputformatshtmldateinputformats note works gnu date read that: solaris version date unable support d resolve replacing sunfreewarecom version date 
p2291
aV date d 25 jun 2011 ymd outputs 20110625 
p2292
aVsingle date command seems work well : date d 27 jun 2011 f 
p2293
aVbash: convert_date local months jan feb mar apr may jun jul aug sep oct nov dec local i0 i11 2 monthsi break done printf 4d02d02d\u005cn 3 i1 1 invoke like d convert_date 27 jun 2011 old date string stored variable d_old27 jun 2011 d convert_date d_old quoted 
p2294
aVmaybe something changed since 2011 worked me: date ymd 20150330 need d get appearing result 
p2295
aVosx im using f specify input format j attempt set date output format specifier example: date j f mdy h:m:s p 82215 8:15:00 mdy 082215 example: date j f d b y 27 jun 2011 ymd 20110627 
p2296
asS'2892787'
p2297
(lp2298
Vwould precede main function c data type many familiar world program c include stdioh main printf world return 0 precede main function int in: int main also ive seen word void entered inside in: int mainvoid seems like extra typing nothing maybe best practice pays dividends situations also precede main int youre returning character string anything one would expect: char mainvoid im also foggy return 0 end function 
p2299
aVmain function returns integer status code tells operating system whether program exited successfully return 0 indicates success returning value indicates failure since integer string returns int char char calling printf anything returning function older versions c allow default return type int however better explicitly specify return type c unlike c function doesnt take parameters declared int myfuncvoid 
p2300
aVcalled exit status program finishes want let callee know program exited exited normally youll return 0 etc exit statuses 
p2301
aVoperating systems uses exit codes applications typically 0 exit code success application successfully completed return value main gets returned os main usually returns integer since 0 success c programs return 0 end 
p2302
aVreasoning behind provide form error reporting mechanism whenever program returns zero value typically means believes completed task successfully nonzero values program failed reason every number might correspond certain error message several system api calls c return return codes indicate whether processing successful since concept exception c best way tell calls successful 
p2303
aVint main function declaration return type function function returns integer function return piece data typical return 0 function completed successfully number 255 returned program execute successfully show error happened return 0 int data type show program executed correctly 
p2304
aVtraditional use int mainint argc char argv integer return indicate program executed returning 0 indicates program executed successfully whereas 1 would indicate failure sort usually exit codes would specific would used method debugging since exceptions c sense dont exist c 
p2305
aVfollowing valid c89 main return 0 modern c c99 isnt allowed anymore need explicitly tell type variables return type functions becomes int main return 0 also legal omit return 0 modern c legal write int main behavior returned 0 people put void parentheses ensures proper typechecking function calls empty set parentheses c mean information amount type parameters exposed outside function caller exactly know void f defined void fint later different unit int main ffoo call f causes undefined behavior compiler cant verify type argument f expects modules write void int compiler would know void fint int arguments accepted int mainvoid ffoo char isnt int main good habit put void since good elsewhere c allowed recursively call main case differences may even matter sadly compilers support modern c many c compilers may still get warnings using modern c features also may see programs declare main return different things int programs use _freestanding_ c implementation c implementations impose restrictions main since dont even know require function first place common portable interface programs entry point c specification requires strictly conforming programs declare main return type int require _hosted_ c implementations accept programs 
p2306
aV precede main function int in: c c 89 anyway thats one seem referring functions return int default arent preceded data type preceding int ultimately matter preference also ive seen word void entered inside in: also matter preference mostly however two quite different: fvoid means function f accepts zero arguments f means function f accepts unspecified number arguments fvoid correct way declare function takes arguments c seems like extra typing nothing maybe best practice pays dividends situations benefit clarity youre going argue less typing good think naming functions variables files everything characters possible also precede main int youre returning character string anything one would expect: char mainvoid world would return character string main absolutely reason also declaration main return character character string im also foggy return 0 end function program returns value operating system ends value used inform os certain things example virus scanner could return 1 virus found 0 virus wasnt found 2 error occurred usually 0 means error everything went well 
p2307
asS'201101'
p2308
(lp2309
Vinitialize members array value large array c c makes difference want initialize members value could swear knew simple way could use memset case isnt way built right c syntax 
p2310
aVunless value 0 case omit part initializer corresponding elements initialized 0 theres easy way dont overlook obvious solution though: int myarray10 5 5 5 5 5 5 5 5 5 5 elements missing values initialized 0: int myarray10 1 2 initialize 12000 initialize elements 0: int myarray10 0 elements 0 c empty initialization list also initialize every element 0 allowed int myarray10 elements 0 c remember objects static storage duration initialize 0 initializer specified: static int myarray10 elements 0 0 doesnt necessarily mean allbitszero using better portable memset floating point values initialized 0 pointers null value etc 
p2311
aVinitializing normal data types like int arrays use bracket notation zero values last still space array: put values 18 two zeroes int list10 12345678 
p2312
aVwhole static initializer thing detailed real bummer array size changes array embiggens dont add appropriate extra initializers get garbage memset gives runtime hit work code size hit done right immune array size changes would use solution nearly cases array larger say dozen elements really important array statically declared id write program write program make part build process 
p2313
aV int 0 array_size myarrayi value think better int myarray10 5 5 5 5 5 5 5 5 5 5 incase size array changes 
p2314
aVarray happens int anything size int mem patterns size fits exact times int ie zeroes 0xa5a5a5a5 best way use memset otherwise call memcpy loop moving index 
p2315
aVwant ensure every member array explicitly initialized omit dimension declaration: int myarray 1 2 3 4 5 6 7 8 9 compiler deduce dimension initializer list unfortunately multidimensional arrays outermost dimension may omitted: int mypoints3 1 2 3 4 5 6 7 8 9 ok int mypoints 1 2 3 4 5 6 7 8 9 
p2316
aVanother way: static void unhandled_interruptstruct trap_frame frame int irq void arg code intentionally left blank static struct irqtbl_s vector_tblxchal_num_interrupts 0 xchal_num_interrupts1 unhandled_interrupt null see: cextensions designated inits ask question: one use c extensions code sample embedded system never see light another compiler 
p2317
aVcompiler gcc use following syntax: int array1024 0 1023 5 check detailed description: designatedinitshtml 
p2318
aVsee requirements question solution must generic: initialization unspecified possibly multidimensional array built unspecified possibly structure elements initial member value: include stringh void array_init void start size_t element_size size_t elements void initval memcpy start initval element_size memcpy charstartelement_size start element_sizeelements1 testing include stdioh struct int char b array23 init int main init struct sa 3 b x array_init array sizeofarray00 23 init int i0 i2 int j0 j3 j printfarrayiia b c\u005cnijarrayijaarrayijb result: array00a 3 b x array01a 3 b x array02a 3 b x array10a 3 b x array11a 3 b x array12a 3 b x edit: startelement_size changed charstartelement_size 
p2319
aVstatically initializing large array value without multiple copypaste use macros: define val_1x 42 define val_2x val_1x val_1x define val_4x val_2x val_2x define val_8x val_4x val_4x define val_16x val_8x val_8x define val_32x val_16x val_16x define val_64x val_32x val_32x int myarray53 val_32x val_16x val_4x val_1x need change value replacement one place edit: possible useful extensions courtesy jonathan leffler leffler easily generalize with: define val_1x x define val_2x val_1x val_1x etc variant created using: define structval_1 __va_args__ define structval_2 structval_1__va_args__ structval_1__va_args__ etc works structures compound arrays define structval_48 structval_32__va_args__ structval_16__va_args__ struct pair char key16 char val32 struct pair p_data structval_48key value int a_data4 structval_4812 19 23 37 macro names negotiable 
p2320
aVslightly tongueincheek answer write statement array initial_value favourite arraycapable language mine fortran many others link c code youd probably want wrap external function 
p2321
aVsaw code used syntax: char array 0 1 world becomes particularly useful youre making array uses enums index: enum err_ok err_fail err_memory define _itemx x x char array _itemerr_ok _itemerr_fail _itemerr_memory keeps things order even happen write enum values order technique found arrayshtml 
p2322
aVuse memset function void memsetvoid array int value unsigned sizeofarray 
p2323
aVfast way initialize array type given value works well large arrays algorithm follows: initialize first element array usual way copy part set part set doubling size next copy operation 1 000 000 elements int array 4 times faster regular loop initialization i5 2 cores 23 ghz 4gib memory 64 bits: loop runtime 0004248 seconds memfill runtime 0001085 seconds include stdioh include timeh include stringh define arr_size 1000000 void memfillvoid dest size_t destsize size_t elemsize char nextdest char dest elemsize size_t movesize donesize elemsize destsize elemsize destsize movesize donesize destsize donesize : destsize memcpynextdest dest movesize nextdest movesize destsize movesize donesize movesize int main clock_t timestart double runtime int aarr_size timestart clock 0 arr_size ai 9 runtime doubleclock timestart doubleclocks_per_sec printfloop runtime f seconds\u005cnruntime timestart clock a0 10 memfilla sizeofa sizeofa0 runtime doubleclock timestart doubleclocks_per_sec printfmemfill runtime f seconds\u005cnruntime return 0 
p2324
aV 1 array declared static global elements array already default default value 0 2 compilers set arrays default 0 debug mode 3 easy set default 0 : int array10 0 4 however values use memset loop example: int array10 memsetarray1 10 sizeofint 
p2325
aVnobody mentioned index order access elements initialized array example code give illustrative example include iostream void printarrayint a33 std::cout a11 a00 \u005ct\u005ct a12 a01 \u005ct\u005ct a13 a02 std::endl std::cout a21 a10 \u005ct\u005ct a22 a11 \u005ct\u005ct a23 a12 std::endl std::cout a31 a20 \u005ct\u005ct a32 a21 \u005ct\u005ct a33 a22 std::endl std::cout std::endl int wmainint argc wchar_t argv int a133 11 12 13 21 22 23 basic 31 32 33 format int a23 11 12 13 first outer dimension 21 22 23 may omitted compiler 31 32 33 automatically deduce int a333 11 12 13 elements 21 22 23 second inner dimension 31 32 33 grouped together int a43 11 12 13 first dimension 21 22 23 omitted 31 32 33 inner elements grouped printarraya1 printarraya2 printarraya3 printarraya4 part shows order elements stored memory int b int a1 output four arrays int i0 i9 std::cout bi \u005ct return 0 output is: a11 11 a12 12 a13 13 a21 21 a22 22 a23 23 a31 31 a32 32 a33 33 a11 11 a12 12 a13 13 a21 21 a22 22 a23 23 a31 31 a32 32 a33 33 a11 11 a12 12 a13 13 a21 21 a22 22 a23 23 a31 31 a32 32 a33 33 a11 11 a12 12 a13 13 a21 21 a22 22 a23 23 a31 31 a32 32 a33 33 11 12 13 21 22 23 31 32 33 
p2326
aVcutting chatter short answer turn optimization compile time wont better this: int ivalue5array1000 fori0i1000i arrayivalue added bonus: code actually legible : 
p2327
as.